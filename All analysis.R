save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
  stopifnot(!missing(x))
  stopifnot(!missing(filename))
  pdf(filename, width=width, height=height)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}
s <- seq(100,1000,100)
surv_up <- data.frame()
a <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/brca/result/','100','_surv_p_up.csv',sep = ''),row.names = 1)
for (i in c(1:10)) {
  surv_up[1:nrow(a),i] <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/brca/result/',s[i],'_surv_p_up.csv',sep = ''),row.names = 1)
}##读取表达量越高，生存越好的数据
write.csv(surv_up,'result/brca/data/surv_up.csv')
surv_down <- data.frame()
a <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/brca/result/','100','_surv_p_down.csv',sep = ''),row.names = 1)
for (i in c(1:10)) {
  surv_down[1:nrow(a),i] <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/brca/result/',s[i],'_surv_p_down.csv',sep = ''),row.names = 1)
}##读取表达量越高，生存越差的数据
write.csv(surv_down,'result/brca/data/surv_down.csv')
a <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/brca/result/','100','_surv_p_down.csv',sep = ''),row.names = 1)
surv_total <- data.frame()
for (i in c(1:10)) {
  surv_total[1:nrow(a),i] <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/brca/result/',s[i],'_surv_p_t.csv',sep = ''),row.names = 1)
}
write.csv(surv_total,'result/brca/data/surv_total.csv')
BRCA <- numeric()
for (i in 1:10) {
  BRCA[i] <- length(which(surv_total[,i]>=0.8))
}
plot(BRCA)

##由于300个样本时有一个数据达到1，说明此时对于对生存有影响的基因样本量已经饱和了，我们取300样本量的0.8为cutoff
surv_t_sig <- surv_total[surv_total[,7]>=0.8,]
surv_up_sig <- surv_up[surv_up[,7]>=0.8,]
surv_down_sig <- surv_down[surv_down[,7]>=0.8,]
write.csv(surv_t_sig,'result/brca/sig_gene/surv_total_sig_gene.csv')
write.csv(surv_up_sig,'result/brca/sig_gene/surv_up_sig_gene.csv')
write.csv(surv_down_sig,'result/brca/sig_gene/surv_down_sig_gene.csv')

library(clusterProfiler) #clusterProfiler的主体
library(org.Hs.eg.db) #人类的参考基因组数据包
library(stringr) #处理表格数据的包
library(msigdbr) #对GSEA官网的通路数据
geneset <- as.list(1:3)
names(geneset) <- c('surv_up','surv_down','surv_total')
geneset[[1]] <- rownames(surv_up_sig)
geneset[[2]] <- rownames(surv_down_sig)
geneset[[3]] <- rownames(surv_t_sig)
geneset_KEGG <- as.list(1:3)
names(geneset_KEGG) <- names(geneset)
for (i in 1:3) {tryCatch({
  geneset_id <- bitr(rownames(geneset[[i]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                     toType = c('ENTREZID'), #totype指需要转换成的ID类型
                     OrgDb='org.Hs.eg.db')
  geneset_KEGG[[i]] <- enrichKEGG(geneset_id[,2], #数据源
                                  organism = 'hsa', #物种
                                  keyType = 'kegg', #"kegg"/'ncbi-geneid'/'ncib-proteinid'/'uniprot'之一，KEGG就写kegg
                                  pvalueCutoff = 1,
                                  pAdjustMethod = 'BH',#P值校正方法
                                  qvalueCutoff = 1)
}, error = function(e) {print('error')})
}

##基因与网络
string_raw <- read.csv('/database/string/gene_gene_interaction_string.csv',row.names = 1)
ref_path_mitotic <- read.table('reference/cell_cycle_mitotic.txt')
ref_path_mitotic <- as.matrix(ref_path_mitotic)
ref_path_mitotic <- as.vector(ref_path_mitotic)
write.csv(ref_path_mitotic,'reference/cell_cycle_mitotic.csv',row.names = F)

surv_down_path <- string_raw[which(string_raw[,1]%in%rownames(surv_down_sig)),]
surv_down_path <- surv_down_path[which(surv_down_path[,3]>=900),]
a <- surv_down_path[,2][!duplicated(surv_down_path[,2])]
a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- a[a[,1]%in%ref_path_mitotic,]
surv_down_path_KEGG <- enrichKEGG(a[,2], #数据源
                                  organism = 'hsa', #物种
                                  keyType = 'kegg', #"kegg"/'ncbi-geneid'/'ncib-proteinid'/'uniprot'之一，KEGG就写kegg
                                  pvalueCutoff = 0.05,
                                  pAdjustMethod = 'BH',#P值校正方法
                                  qvalueCutoff = 0.05)
surv_down_path_GO <- enrichGO(a[,2], #数据源
                              pvalueCutoff = 0.05, #P值阈值
                              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                              OrgDb = org.Hs.eg.db, #人类参考基因组
                              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                              readable = TRUE) #是否将基因ID转换为基因名

##提取网络
regular <- list()
regular[[1]] <- data.frame()
regular[[2]] <- data.frame()
regular[[3]] <- data.frame()
string_raw <- read.csv('/database/string/gene_gene_interaction_string.csv',row.names = 1)
string <- string_raw[string_raw[,3]>=800,]

for (j in 1:length(geneset[[1]])) {
  c <- geneset[[2]][j]
  for (i in 1:10) {
    a <- string[string[,1]%in%c,]
    b <- a[,2][a[,2]%in%ref_path_mitotic]
    b <- b[!duplicated(b)]
    regular[[1]][j,i] <- length(b)/length(ref_path_mitotic)
    c <- a[,2][!duplicated(a[,2])]
  }
}

for (j in 1:length(geneset[[2]])) {
  c <- geneset[[1]][j]
  for (i in 1:10) {
    a <- string[string[,1]%in%c,]
    b <- a[,2][a[,2]%in%ref_path_mitotic]
    b <- b[!duplicated(b)]
    regular[[2]][j,i] <- length(b)/length(ref_path_mitotic)
    c <- a[,2][!duplicated(a[,2])]
  }
}

for (j in 1:length(gene)) {
  c <- gene[j]
  for (i in 1:10) {
    a <- string[string[,1]%in%c,]
    b <- a[,2][a[,2]%in%ref_path_mitotic]
    b <- b[!duplicated(b)]
    regular[[3]][j,i] <- length(b)/length(ref_path_mitotic)
    c <- a[,2][!duplicated(a[,2])]
  }
}

gene <- sample(1:17395,100)
gene <- rownames(surv_down)[gene]

rownames(regular) <- geneset[[2]]


###开始写代码
library(stringr)
cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
for (i in 1:length(cancer_name)) {
  a <- dir(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/',cancer_name[i],'/result/',sep = ''))
  a <- as.data.frame(a)
  a <- str_split(a[,1],'[_]',simplify = T)##按照某符号拆分某列
  a <- a[,1]
  a <- a[!duplicated(a)]
  a <- as.numeric(a)
  s <- seq(min(a),max(a),min(a))
  surv_up <- data.frame()
  surv_down <- data.frame()
  surv_t <- data.frame()
  a <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/',cancer_name[i],'/result/',s[1],'_surv_p_t.csv',sep = ''))
  a <- a[!is.na(a[,1]),]
  for (j in c(1:10)) {
    b <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/',cancer_name[i],'/result/',s[j],'_surv_p_t.csv',sep = ''))
    b <- b[!is.na(b[,1]),]
    surv_t[1:nrow(a),j] <- b[,2]
  }
  colnames(surv_t) <- s
  rownames(surv_t) <- a[,1]
  
  a <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/',cancer_name[i],'/result/',s[1],'_surv_p_up.csv',sep = ''))
  a <- a[!is.na(a[,1]),]
  for (j in c(1:10)) {
    b <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/',cancer_name[i],'/result/',s[j],'_surv_p_up.csv',sep = ''))
    b <- b[!is.na(b[,1]),]
    surv_up[1:nrow(a),j] <- b[,2]
  }
  colnames(surv_up) <- s
  rownames(surv_up) <- a[,1]
  
  a <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/',cancer_name[i],'/result/',s[1],'_surv_p_down.csv',sep = ''))
  a <- a[!is.na(a[,1]),]
  for (j in c(1:10)) {
    b <- read.csv(paste('/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process/',cancer_name[i],'/result/',s[j],'_surv_p_down.csv',sep = ''))
    b <- b[!is.na(b[,1]),]
    surv_down[1:nrow(a),j] <- b[,2]
  }
  colnames(surv_down) <- s
  rownames(surv_down) <- a[,1]
  dir.create(paste('result/',cancer_name[i],sep = ''))
  dir.create(paste('result/',cancer_name[i],'/data',sep = ''))
  write.csv(surv_up,paste('result/',cancer_name[i],'/data/surv_up.csv',sep = ''))
  write.csv(surv_down,paste('result/',cancer_name[i],'/data/surv_down.csv',sep = ''))
  write.csv(surv_t,paste('result/',cancer_name[i],'/data/surv_t.csv',sep = ''))
}
surv_data <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- numeric()
  for (i in 1:10) {
    a[i] <- length(which(surv_data[[j]][[1]][,i]>=0.8))
  }
  h <- numeric()
  for (i in 1:10) {
    l1 <- ((a[i]-a[1])**2+(i-1)**2)**0.5
    l2 <- ((a[10]-a[i])**2+(10-i)**2)**0.5
    l3 <- ((a[10]-a[1])**2+(10-1)**2)**0.5
    p <- (l1+l2+l3)/2
    area <- (p*(p-l1)*(p-l2)*(p-l3))**0.5
    h[i] <- area/l3
  }
  plot(a)
  surv_data[[j]][[1]] <- surv_data[[j]][[1]][which(rank(1/(surv_data[[j]][[1]][,which(h==max(h))]+1)) <= 150),]
  surv_data[[j]][[2]] <- surv_data[[j]][[2]][which(surv_data[[j]][[2]][,which(h==max(h))] >= min(surv_data[[j]][[1]][,which(h==max(h))])),]
  surv_data[[j]][[3]] <- surv_data[[j]][[3]][which(surv_data[[j]][[3]][,which(h==max(h))] >= min(surv_data[[j]][[1]][,which(h==max(h))])),]
}
surv_pathway <- list()
for (j in 1:length(cancer_name)) {
  surv_pathway[[j]] <- list()
  names(surv_pathway)[j] <- cancer_name[j]
  a <- bitr(rownames(surv_data[[j]][[1]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[1]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  a <- bitr(rownames(surv_data[[j]][[2]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[2]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  a <- bitr(rownames(surv_data[[j]][[3]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[3]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  names(surv_pathway[[j]]) <- names(surv_data[[j]])
  surv_pathway[[j]][[1]] <- as.data.frame(surv_pathway[[j]][[1]])
  surv_pathway[[j]][[2]] <- as.data.frame(surv_pathway[[j]][[2]])
  surv_pathway[[j]][[3]] <- as.data.frame(surv_pathway[[j]][[3]])
}

surv_data_k1 <- list()
surv_pathway_k1 <- list()
string_raw <- read.csv('/database/string/gene_gene_interaction_string.csv',row.names = 1)
for (j in 1:length(cancer_name)) {
  string <- string_raw[which(string_raw[,3]>=900),]
  surv_data_k1[[j]] <- list()
  surv_pathway_k1[[j]] <- list()
  ##富集
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[1]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1[[j]][[1]] <- a
  surv_pathway_k1[[j]][[1]] <- enrichGO(a[,2], #数据源
                                        pvalueCutoff = 0.05, #P值阈值
                                        qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                        OrgDb = org.Hs.eg.db, #人类参考基因组
                                        ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                        readable = TRUE) #是否将基因ID转换为基因名
  
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[2]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1[[j]][[2]] <- a
  surv_pathway_k1[[j]][[2]] <- enrichGO(a[,2], #数据源
                                        pvalueCutoff = 0.05, #P值阈值
                                        qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                        OrgDb = org.Hs.eg.db, #人类参考基因组
                                        ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                        readable = TRUE) #是否将基因ID转换为基因名
  
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[3]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1[[j]][[3]] <- a
  surv_pathway_k1[[j]][[3]] <- enrichGO(a[,2], #数据源
                                        pvalueCutoff = 0.05, #P值阈值
                                        qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                        OrgDb = org.Hs.eg.db, #人类参考基因组
                                        ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                        readable = TRUE) #是否将基因ID转换为基因名
  names(surv_data_k1)[j] <- cancer_name[j]
  names(surv_pathway_k1)[j] <- cancer_name[j]
  names(surv_data_k1[[j]]) <- c('surv_t','surv_up','surv_down')
  names(surv_pathway_k1[[j]]) <- c('surv_t','surv_up','surv_down')
  surv_pathway_k1[[j]][[1]] <- as.data.frame(surv_pathway_k1[[j]][[1]])
  surv_pathway_k1[[j]][[2]] <- as.data.frame(surv_pathway_k1[[j]][[2]])
  surv_pathway_k1[[j]][[3]] <- as.data.frame(surv_pathway_k1[[j]][[3]])
}
surv_data_k1_800 <- list()
surv_pathway_k1_800 <- list()
for (j in 1:length(cancer_name)) {
  string <- string_raw[which(string_raw[,3]>=800),]
  surv_data_k1_800[[j]] <- list()
  surv_pathway_k1_800[[j]] <- list()
  ##富集
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[1]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1_800[[j]][[1]] <- a
  surv_pathway_k1_800[[j]][[1]] <- enrichGO(a[,2], #数据源
                                            pvalueCutoff = 0.05, #P值阈值
                                            qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                            OrgDb = org.Hs.eg.db, #人类参考基因组
                                            ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                            readable = TRUE) #是否将基因ID转换为基因名
  
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[2]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1_800[[j]][[2]] <- a
  surv_pathway_k1_800[[j]][[2]] <- enrichGO(a[,2], #数据源
                                            pvalueCutoff = 0.05, #P值阈值
                                            qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                            OrgDb = org.Hs.eg.db, #人类参考基因组
                                            ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                            readable = TRUE) #是否将基因ID转换为基因名
  
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[3]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1_800[[j]][[3]] <- a
  surv_pathway_k1_800[[j]][[3]] <- enrichGO(a[,2], #数据源
                                            pvalueCutoff = 0.05, #P值阈值
                                            qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                            OrgDb = org.Hs.eg.db, #人类参考基因组
                                            ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                            readable = TRUE) #是否将基因ID转换为基因名
  names(surv_data_k1_800)[j] <- cancer_name[j]
  names(surv_pathway_k1_800)[j] <- cancer_name[j]
  names(surv_data_k1_800[[j]]) <- c('surv_t','surv_up','surv_down')
  names(surv_pathway_k1_800[[j]]) <- c('surv_t','surv_up','surv_down')
  surv_pathway_k1_800[[j]][[1]] <- as.data.frame(surv_pathway_k1_800[[j]][[1]])
  surv_pathway_k1_800[[j]][[2]] <- as.data.frame(surv_pathway_k1_800[[j]][[2]])
  surv_pathway_k1_800[[j]][[3]] <- as.data.frame(surv_pathway_k1_800[[j]][[3]])
}
surv_data_k1_999 <- list()
surv_pathway_k1_999 <- list()
for (j in 1:length(cancer_name)) {
  string <- string_raw[which(string_raw[,3]>=999),]
  surv_data_k1_999[[j]] <- list()
  surv_pathway_k1_999[[j]] <- list()
  ##富集
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[1]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1_999[[j]][[1]] <- a
  surv_pathway_k1_999[[j]][[1]] <- enrichGO(a[,2], #数据源
                                            pvalueCutoff = 0.05, #P值阈值
                                            qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                            OrgDb = org.Hs.eg.db, #人类参考基因组
                                            ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                            readable = TRUE) #是否将基因ID转换为基因名
  
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[2]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1_999[[j]][[2]] <- a
  surv_pathway_k1_999[[j]][[2]] <- enrichGO(a[,2], #数据源
                                            pvalueCutoff = 0.05, #P值阈值
                                            qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                            OrgDb = org.Hs.eg.db, #人类参考基因组
                                            ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                            readable = TRUE) #是否将基因ID转换为基因名
  
  a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[3]])]
  a <- a[!duplicated(a)]
  a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_data_k1_999[[j]][[3]] <- a
  surv_pathway_k1_999[[j]][[3]] <- enrichGO(a[,2], #数据源
                                            pvalueCutoff = 0.05, #P值阈值
                                            qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                            OrgDb = org.Hs.eg.db, #人类参考基因组
                                            ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                            readable = TRUE) #是否将基因ID转换为基因名
  names(surv_data_k1_999)[j] <- cancer_name[j]
  names(surv_pathway_k1_999)[j] <- cancer_name[j]
  names(surv_data_k1_999[[j]]) <- c('surv_t','surv_up','surv_down')
  names(surv_pathway_k1_999[[j]]) <- c('surv_t','surv_up','surv_down')
  surv_pathway_k1_999[[j]][[1]] <- as.data.frame(surv_pathway_k1_999[[j]][[1]])
  surv_pathway_k1_999[[j]][[2]] <- as.data.frame(surv_pathway_k1_999[[j]][[2]])
  surv_pathway_k1_999[[j]][[3]] <- as.data.frame(surv_pathway_k1_999[[j]][[3]])
}

##超几何分布检测
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- numeric()
  for (i in 1:10) {
    a[i] <- length(which(surv_data[[j]][[1]][,i]>=0.8))
  }
  h <- numeric()
  for (i in 1:10) {
    l1 <- ((a[i]-a[1])**2+(i-1)**2)**0.5
    l2 <- ((a[10]-a[i])**2+(10-i)**2)**0.5
    l3 <- ((a[10]-a[1])**2+(10-1)**2)**0.5
    p <- (l1+l2+l3)/2
    area <- (p*(p-l1)*(p-l2)*(p-l3))**0.5
    h[i] <- area/l3
  }
  plot(a)
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(rank(1/(surv_data_sig[[j]][[1]][,which(h==max(h))]+1)) <= 150),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which(h==max(h))] >= min(surv_data_sig[[j]][[1]][,which(h==max(h))])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which(h==max(h))] >= min(surv_data_sig[[j]][[1]][,which(h==max(h))])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name
surv_enrich <- list()
surv_enrich[[1]] <- data.frame()
surv_enrich[[2]] <- data.frame()
for (i in 1:length(cancer_name)) {
  a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%rownames(surv_data[[i]][[1]])]
  surv_enrich[[1]][i,1] <- phyper(length(which(rownames(surv_data_sig[[i]][[2]])%in%a))-1,
                                  length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                  length(rownames(surv_data_sig[[i]][[2]])), lower.tail = F)
  surv_enrich[[1]][i,2] <- c(paste(length(which(rownames(surv_data_sig[[i]][[2]])%in%a)),'/',length(rownames(surv_data_sig[[i]][[2]])),sep = ''))
  surv_enrich[[1]][i,3] <- phyper(length(which(rownames(surv_data_sig[[i]][[3]])%in%a))-1,
                                  length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                  length(rownames(surv_data_sig[[i]][[3]])), lower.tail = F)
  surv_enrich[[1]][i,4] <- c(paste(length(which(rownames(surv_data_sig[[i]][[3]])%in%a)),'/',length(rownames(surv_data_sig[[i]][[3]])),sep = ''))
  a <- immune_system[,2][immune_system[,2]%in%rownames(surv_data[[i]][[1]])]
  surv_enrich[[2]][i,1] <- phyper(length(which(rownames(surv_data_sig[[i]][[2]])%in%a))-1,
                                  length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                  length(rownames(surv_data_sig[[i]][[2]])), lower.tail = F)
  surv_enrich[[2]][i,2] <- c(paste(length(which(rownames(surv_data_sig[[i]][[2]])%in%a)),'/',length(rownames(surv_data_sig[[i]][[2]])),sep = ''))
  surv_enrich[[2]][i,3] <- phyper(length(which(rownames(surv_data_sig[[i]][[3]])%in%a))-1,
                                  length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                  length(rownames(surv_data_sig[[i]][[3]])), lower.tail = F)
  surv_enrich[[2]][i,4] <- c(paste(length(which(rownames(surv_data_sig[[i]][[3]])%in%a)),'/',length(rownames(surv_data_sig[[i]][[3]])),sep = ''))
}##超几何分布检测
names(surv_enrich) <- c('mitotic_cell_cycle','immune_system')
rownames(surv_enrich[[1]]) <- cancer_name
rownames(surv_enrich[[2]]) <- cancer_name
colnames(surv_enrich[[1]]) <- c('surv_up','up_ratio','surv_down','down_ratio')
colnames(surv_enrich[[2]]) <- c('surv_up','up_ratio','surv_down','down_ratio')
##导出文件
write.csv(surv_enrich[[1]],'result/all/mitotic_cell_cycle_150.csv')
write.csv(surv_enrich[[2]],'result/all/immune_system_150.csv')

mitotic_cell_cycle <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic_cell_cycle.txt',sep = '\t')##读取有丝分裂基因
immune_system <- read.table('/database/Gene Ontology/homo_sapiens/immune_system/immune_system.txt',sep = '\t')
surv_data_k1 <- list()
surv_pathway_k1 <- list()
for (j in 1:length(cancer_name)) {
  string <- string_raw[which(string_raw[,3]>=800),]##基因网络
  # string <- string_raw##基因网络
  surv_data_k1[[j]] <- list()
  surv_data_k1[[j]][[1]] <- list()
  surv_data_k1[[j]][[2]] <- list()
  surv_pathway_k1[[j]] <- list()
  surv_pathway_k1[[j]][[1]] <- data.frame()
  surv_pathway_k1[[j]][[2]] <- data.frame()
  names(surv_pathway_k1[[j]]) <- c('surv_up','surv_down')
  for (i in 1:nrow(surv_data_sig[[j]][[2]])) {
    a <- string[,2][string[,1]==rownames(surv_data_sig[[j]][[2]])[i]]
    surv_data_k1[[j]][[1]][[i]] <- a[!duplicated(a)]
    a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][[1]][i,1] <- phyper(length(which(surv_data_k1[[j]][[1]][[i]]%in%a))-1,
                                             length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                             length(surv_data_k1[[j]][[1]][[i]]), lower.tail = F)
    a <- immune_system[,2][immune_system[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][[1]][i,2] <- phyper(length(which(surv_data_k1[[j]][[1]][[i]]%in%a))-1,
                                             length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                             length(surv_data_k1[[j]][[1]][[i]]), lower.tail = F)
  }
  rownames(surv_pathway_k1[[j]][[1]]) <- rownames(surv_data_sig[[j]][[2]])
  colnames(surv_pathway_k1[[j]][[1]]) <- c('mitotic_cell_cycle','immune_system')
  for (i in 1:nrow(surv_data_sig[[j]][[3]])) {
    a <- string[,2][string[,1]==rownames(surv_data_sig[[j]][[3]])[i]]
    surv_data_k1[[j]][[2]][[i]] <- a[!duplicated(a)]
    a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][[2]][i,1] <- phyper(length(which(surv_data_k1[[j]][[2]][[i]]%in%a))-1,
                                             length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                             length(surv_data_k1[[j]][[2]][[i]]), lower.tail = F)
    a <- immune_system[,2][immune_system[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][[2]][i,2] <- phyper(length(which(surv_data_k1[[j]][[2]][[i]]%in%a))-1,
                                             length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                             length(surv_data_k1[[j]][[2]][[i]]), lower.tail = F)
  }
  rownames(surv_pathway_k1[[j]][[2]]) <- rownames(surv_data_sig[[j]][[3]])
  colnames(surv_pathway_k1[[j]][[2]]) <- c('mitotic_cell_cycle','immune_system')
  print(cancer_name[j])
}##对每个基因的邻居分别富集
for (j in 1:2) {
  string <- string_raw[which(string_raw[,3]>=800),]##基因网络
  # string <- string_raw##基因网络
  surv_data_k1[[j]] <- list()
  surv_data_k1[[j]][[1]] <- list()
  surv_data_k1[[j]][[2]] <- list()
  surv_pathway_k1[[j]] <- data.frame()
  for (i in 1:length(cancer_name)) {
    a <- string[,2][string[,1]%in%rownames(surv_data_sig[[i]][[j+1]])]
    surv_data_k1[[j]][[i]] <- a[!duplicated(a)]
    a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][i,1] <- phyper(length(which(surv_data_k1[[j]][[i]]%in%a))-1,
                                        length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                        length(surv_data_k1[[j]][[i]]), lower.tail = F)
    surv_pathway_k1[[j]][i,2] <- paste(length(which(surv_data_k1[[j]][[i]]%in%a)),'/',length(surv_data_k1[[j]][[i]]),sep = '')
    a <- immune_system[,2][immune_system[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][i,3] <- phyper(length(which(surv_data_k1[[j]][[i]]%in%a))-1,
                                        length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                        length(surv_data_k1[[j]][[i]]), lower.tail = F)
    surv_pathway_k1[[j]][i,4] <- paste(length(which(surv_data_k1[[j]][[i]]%in%a)),'/',length(surv_data_k1[[j]][[i]]),sep = '')
  }
  names(surv_data_k1[[j]]) <- cancer_name
  colnames(surv_pathway_k1[[j]]) <- c('mitotic_cell_cycle','mitotic_ratio','immune_system','immune_ratio')
  rownames(surv_pathway_k1[[j]]) <- cancer_name
}##对所有基因的邻居集合做分析
names(surv_pathway_k1) <- c('surv_up','surv_down')
write.csv(surv_pathway_k1[[1]],'result/all/surv_up_k1.csv')
write.csv(surv_pathway_k1[[2]],'result/all/surv_down_k1.csv')

##超几何分布检测2##针对更多阈值的基因
library(stringr)
mitotic_cell_cycle <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic_cell_cycle.txt',sep = '\t')##读取有丝分裂基因
immune_system <- read.table('/database/Gene Ontology/homo_sapiens/immune_system/immune_system.txt',sep = '\t')
cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- numeric()
  for (i in 1:10) {
    a[i] <- length(which(surv_data[[j]][[1]][,i]>=0.8))
  }
  h <- numeric()
  for (i in 1:10) {
    l1 <- ((a[i]-a[1])**2+(i-1)**2)**0.5
    l2 <- ((a[10]-a[i])**2+(10-i)**2)**0.5
    l3 <- ((a[10]-a[1])**2+(10-1)**2)**0.5
    p <- (l1+l2+l3)/2
    area <- (p*(p-l1)*(p-l2)*(p-l3))**0.5
    h[i] <- area/l3
  }
  plot(a)
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which(h==max(h))] >= 0.8),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which(h==max(h))] >= min(surv_data_sig[[j]][[1]][,which(h==max(h))])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which(h==max(h))] >= min(surv_data_sig[[j]][[1]][,which(h==max(h))])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name

surv_enrich <- list()
surv_enrich[[1]] <- data.frame()
surv_enrich[[2]] <- data.frame()
for (i in 1:length(cancer_name)) {
  a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%rownames(surv_data[[i]][[1]])]
  surv_enrich[[1]][i,1] <- phyper(length(which(rownames(surv_data_sig[[i]][[2]])%in%a))-1,
                                  length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                  length(rownames(surv_data_sig[[i]][[2]])), lower.tail = F)
  surv_enrich[[1]][i,2] <- c(paste(length(which(rownames(surv_data_sig[[i]][[2]])%in%a)),'/',length(rownames(surv_data_sig[[i]][[2]])),sep = ''))
  surv_enrich[[1]][i,3] <- phyper(length(which(rownames(surv_data_sig[[i]][[3]])%in%a))-1,
                                  length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                  length(rownames(surv_data_sig[[i]][[3]])), lower.tail = F)
  surv_enrich[[1]][i,4] <- c(paste(length(which(rownames(surv_data_sig[[i]][[3]])%in%a)),'/',length(rownames(surv_data_sig[[i]][[3]])),sep = ''))
  a <- immune_system[,2][immune_system[,2]%in%rownames(surv_data[[i]][[1]])]
  surv_enrich[[2]][i,1] <- phyper(length(which(rownames(surv_data_sig[[i]][[2]])%in%a))-1,
                                  length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                  length(rownames(surv_data_sig[[i]][[2]])), lower.tail = F)
  surv_enrich[[2]][i,2] <- c(paste(length(which(rownames(surv_data_sig[[i]][[2]])%in%a)),'/',length(rownames(surv_data_sig[[i]][[2]])),sep = ''))
  surv_enrich[[2]][i,3] <- phyper(length(which(rownames(surv_data_sig[[i]][[3]])%in%a))-1,
                                  length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                  length(rownames(surv_data_sig[[i]][[3]])), lower.tail = F)
  surv_enrich[[2]][i,4] <- c(paste(length(which(rownames(surv_data_sig[[i]][[3]])%in%a)),'/',length(rownames(surv_data_sig[[i]][[3]])),sep = ''))
}
names(surv_enrich) <- c('mitotic_cell_cycle','immune_system')
rownames(surv_enrich[[1]]) <- cancer_name
rownames(surv_enrich[[2]]) <- cancer_name
colnames(surv_enrich[[1]]) <- c('surv_up','up_ratio','surv_down','down_ratio')
colnames(surv_enrich[[2]]) <- c('surv_up','up_ratio','surv_down','down_ratio')
write.csv(surv_enrich[[1]],'result/all/mitotic_cell_cycle_0.8.csv')
write.csv(surv_enrich[[2]],'result/all/immune_system_0.8.csv')

##计算每个基因的k1超几何分布
surv_data_k1 <- list()
surv_pathway_k1 <- list()
for (j in 1:length(cancer_name)) {
  string <- string_raw[which(string_raw[,3]>=800),]##基因网络
  # string <- string_raw##基因网络
  surv_data_k1[[j]] <- list()
  surv_data_k1[[j]][[1]] <- list()
  surv_data_k1[[j]][[2]] <- list()
  surv_pathway_k1[[j]] <- list()
  surv_pathway_k1[[j]][[1]] <- data.frame()
  surv_pathway_k1[[j]][[2]] <- data.frame()
  names(surv_pathway_k1[[j]]) <- c('surv_up','surv_down')
  for (i in 1:nrow(surv_data_sig[[j]][[2]])) {
    a <- string[,2][string[,1]==rownames(surv_data_sig[[j]][[2]])[i]]
    surv_data_k1[[j]][[1]][[i]] <- a[!duplicated(a)]
    a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][[1]][i,1] <- phyper(length(which(surv_data_k1[[j]][[1]][[i]]%in%a))-1,
                                             length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                             length(surv_data_k1[[j]][[1]][[i]]), lower.tail = F)
    a <- immune_system[,2][immune_system[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][[1]][i,2] <- phyper(length(which(surv_data_k1[[j]][[1]][[i]]%in%a))-1,
                                             length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                             length(surv_data_k1[[j]][[1]][[i]]), lower.tail = F)
  }
  rownames(surv_pathway_k1[[j]][[1]]) <- rownames(surv_data_sig[[j]][[2]])
  colnames(surv_pathway_k1[[j]][[1]]) <- c('mitotic_cell_cycle','immune_system')
  for (i in 1:nrow(surv_data_sig[[j]][[3]])) {
    a <- string[,2][string[,1]==rownames(surv_data_sig[[j]][[3]])[i]]
    surv_data_k1[[j]][[2]][[i]] <- a[!duplicated(a)]
    a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][[2]][i,1] <- phyper(length(which(surv_data_k1[[j]][[2]][[i]]%in%a))-1,
                                             length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                             length(surv_data_k1[[j]][[2]][[i]]), lower.tail = F)
    a <- immune_system[,2][immune_system[,2]%in%rownames(surv_data[[j]][[1]])]
    surv_pathway_k1[[j]][[2]][i,2] <- phyper(length(which(surv_data_k1[[j]][[2]][[i]]%in%a))-1,
                                             length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                             length(surv_data_k1[[j]][[2]][[i]]), lower.tail = F)
  }
  rownames(surv_pathway_k1[[j]][[2]]) <- rownames(surv_data_sig[[j]][[3]])
  colnames(surv_pathway_k1[[j]][[2]]) <- c('mitotic_cell_cycle','immune_system')
  print(cancer_name[j])
}
names(surv_pathway_k1) <- cancer_name
surv_path_k1_count <- list()
for (j in 1:2) {
  surv_path_k1_count[[j]] <- data.frame()
  for (i in 1:length(cancer_name)) {
    surv_path_k1_count[[j]][i,1] <- length(which(surv_pathway_k1[[i]][[j]][,1]<0.05))/nrow(surv_pathway_k1[[i]][[j]])
    surv_path_k1_count[[j]][i,2] <- length(which(surv_pathway_k1[[i]][[j]][,2]<0.05))/nrow(surv_pathway_k1[[i]][[j]])
  }
  colnames(surv_path_k1_count[[j]]) <- c('mitotic_cell_cycle','immune_system')
  rownames(surv_path_k1_count[[j]]) <- cancer_name
}##统计
names(surv_path_k1_count) <- c('surv_up','surv_down')






##抽基因验证
gene <- rownames(surv_data[[1]][[1]])
test_data[[j]] <- gene[sample(1:length(gene),100,replace = F)]
test_data_k1 <- list()
test_pathway_k1 <- list()
##超几何分布检测
test_data_sig <- list()
for (j in 1:1000) {
  test_data_sig[[j]] <- list()
  test_data_sig[[j]][[1]] <- data.frame(1:100)
  test_data_sig[[j]][[2]] <- data.frame(1:100)
  test_data_sig[[j]][[3]] <- data.frame(1:100)
  rownames(test_data_sig[[j]][[2]]) <- gene[sample(1:length(gene),100,replace = F)]
  rownames(test_data_sig[[j]][[3]]) <- gene[sample(1:length(gene),100,replace = F)]
}##读取数据以及计算sig_gene
names(test_data_sig) <- cancer_name
test_enrich <- list()
test_enrich[[1]] <- data.frame()
test_enrich[[2]] <- data.frame()
for (i in 1:1000) {
  a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%gene]
  test_enrich[[1]][i,1] <- phyper(length(which(rownames(test_data_sig[[i]][[2]])%in%a))-1,
                                  length(a), length(gene)-length(a),
                                  length(rownames(test_data_sig[[i]][[2]])), lower.tail = F)
  test_enrich[[1]][i,2] <- c(paste(length(which(rownames(test_data_sig[[i]][[2]])%in%a)),'/',length(rownames(test_data_sig[[i]][[2]])),sep = ''))
  test_enrich[[1]][i,3] <- phyper(length(which(rownames(test_data_sig[[i]][[3]])%in%a))-1,
                                  length(a), length(gene)-length(a),
                                  length(rownames(test_data_sig[[i]][[3]])), lower.tail = F)
  test_enrich[[1]][i,4] <- c(paste(length(which(rownames(test_data_sig[[i]][[3]])%in%a)),'/',length(rownames(test_data_sig[[i]][[3]])),sep = ''))
  a <- immune_system[,2][immune_system[,2]%in%gene]
  test_enrich[[2]][i,1] <- phyper(length(which(rownames(test_data_sig[[i]][[2]])%in%a))-1,
                                  length(a), length(gene)-length(a),
                                  length(rownames(test_data_sig[[i]][[2]])), lower.tail = F)
  test_enrich[[2]][i,2] <- c(paste(length(which(rownames(test_data_sig[[i]][[2]])%in%a)),'/',length(rownames(test_data_sig[[i]][[2]])),sep = ''))
  test_enrich[[2]][i,3] <- phyper(length(which(rownames(test_data_sig[[i]][[3]])%in%a))-1,
                                  length(a), length(gene)-length(a),
                                  length(rownames(test_data_sig[[i]][[3]])), lower.tail = F)
  test_enrich[[2]][i,4] <- c(paste(length(which(rownames(test_data_sig[[i]][[3]])%in%a)),'/',length(rownames(test_data_sig[[i]][[3]])),sep = ''))
}##超几何分布检测
names(test_enrich) <- c('mitotic_cell_cycle','immune_system')
colnames(test_enrich[[1]]) <- c('test_up','up_ratio','test_down','down_ratio')
colnames(test_enrich[[2]]) <- c('test_up','up_ratio','test_down','down_ratio')
##导出文件
write.csv(test_enrich[[1]],'mitotic_cell_cycle_test_100.csv')


mitotic_cell_cycle <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic_cell_cycle.txt',sep = '\t')##读取有丝分裂基因
immune_system <- read.table('/database/Gene Ontology/homo_sapiens/immune_system/immune_system.txt',sep = '\t')
test_data_k1 <- list()
test_pathway_k1 <- list()
for (j in 1:1000) {
  string <- string_raw[which(string_raw[,3]>=800),]##基因网络
  # string <- string_raw##基因网络
  test_data_k1[[j]] <- list()
  test_data_k1[[j]][[1]] <- list()
  test_data_k1[[j]][[2]] <- list()
  test_pathway_k1[[j]] <- list()
  test_pathway_k1[[j]][[1]] <- data.frame()
  test_pathway_k1[[j]][[2]] <- data.frame()
  names(test_pathway_k1[[j]]) <- c('test_up','test_down')
  for (i in 1:nrow(test_data_sig[[j]][[2]])) {
    a <- string[,2][string[,1]==rownames(test_data_sig[[j]][[2]])[i]]
    test_data_k1[[j]][[1]][[i]] <- a[!duplicated(a)]
    a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%gene]
    test_pathway_k1[[j]][[1]][i,1] <- phyper(length(which(test_data_k1[[j]][[1]][[i]]%in%a))-1,
                                             length(a), length(gene)-length(a),
                                             length(test_data_k1[[j]][[1]][[i]]), lower.tail = F)
    a <- immune_system[,2][immune_system[,2]%in%gene]
    test_pathway_k1[[j]][[1]][i,2] <- phyper(length(which(test_data_k1[[j]][[1]][[i]]%in%a))-1,
                                             length(a), length(gene)-length(a),
                                             length(test_data_k1[[j]][[1]][[i]]), lower.tail = F)
  }
  rownames(test_pathway_k1[[j]][[1]]) <- rownames(test_data_sig[[j]][[2]])
  colnames(test_pathway_k1[[j]][[1]]) <- c('mitotic_cell_cycle','immune_system')
  for (i in 1:nrow(test_data_sig[[j]][[3]])) {
    a <- string[,2][string[,1]==rownames(test_data_sig[[j]][[3]])[i]]
    test_data_k1[[j]][[2]][[i]] <- a[!duplicated(a)]
    a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%gene]
    test_pathway_k1[[j]][[2]][i,1] <- phyper(length(which(test_data_k1[[j]][[2]][[i]]%in%a))-1,
                                             length(a), length(gene)-length(a),
                                             length(test_data_k1[[j]][[2]][[i]]), lower.tail = F)
    a <- immune_system[,2][immune_system[,2]%in%gene]
    test_pathway_k1[[j]][[2]][i,2] <- phyper(length(which(test_data_k1[[j]][[2]][[i]]%in%a))-1,
                                             length(a), length(gene)-length(a),
                                             length(test_data_k1[[j]][[2]][[i]]), lower.tail = F)
  }
  rownames(test_pathway_k1[[j]][[2]]) <- rownames(test_data_sig[[j]][[3]])
  colnames(test_pathway_k1[[j]][[2]]) <- c('mitotic_cell_cycle','immune_system')
  print(cancer_name[j])
}##对每个基因的邻居分别富集
for (j in 1:2) {
  string <- string_raw[which(string_raw[,3]>=800),]##基因网络
  # string <- string_raw##基因网络
  test_data_k1[[j]] <- list()
  test_data_k1[[j]][[1]] <- list()
  test_data_k1[[j]][[2]] <- list()
  test_pathway_k1[[j]] <- data.frame()
  for (i in 1:1000) {
    a <- string[,2][string[,1]%in%rownames(test_data_sig[[i]][[j+1]])]
    test_data_k1[[j]][[i]] <- a[!duplicated(a)]
    a <- mitotic_cell_cycle[,2][mitotic_cell_cycle[,2]%in%gene]
    test_pathway_k1[[j]][i,1] <- phyper(length(which(test_data_k1[[j]][[i]]%in%a))-1,
                                        length(a), length(gene)-length(a),
                                        length(test_data_k1[[j]][[i]]), lower.tail = F)
    test_pathway_k1[[j]][i,2] <- paste(length(which(test_data_k1[[j]][[i]]%in%a)),'/',length(test_data_k1[[j]][[i]]),sep = '')
    a <- immune_system[,2][immune_system[,2]%in%gene]
    test_pathway_k1[[j]][i,3] <- phyper(length(which(test_data_k1[[j]][[i]]%in%a))-1,
                                        length(a), length(gene)-length(a),
                                        length(test_data_k1[[j]][[i]]), lower.tail = F)
    test_pathway_k1[[j]][i,4] <- paste(length(which(test_data_k1[[j]][[i]]%in%a)),'/',length(test_data_k1[[j]][[i]]),sep = '')
  }
  names(test_data_k1[[j]]) <- cancer_name
  colnames(test_pathway_k1[[j]]) <- c('mitotic_cell_cycle','mitotic_ratio','immune_system','immune_ratio')
}##对所有基因的邻居集合做分析
names(test_pathway_k1) <- c('test_up','test_down')
test_path_k1_count <- list()
for (j in 1:2) {
  test_path_k1_count[[j]] <- data.frame()
  for (i in 1:1000) {
    test_path_k1_count[[j]][i,1] <- length(which(test_pathway_k1[[i]][[j]][,1]<0.05))/nrow(test_pathway_k1[[i]][[j]])
    test_path_k1_count[[j]][i,2] <- length(which(test_pathway_k1[[i]][[j]][,2]<0.05))/nrow(test_pathway_k1[[i]][[j]])
  }
  colnames(test_path_k1_count[[j]]) <- c('mitotic_cell_cycle','immune_system')
}##统计
##测试基因集与两个数据库之间的关系
##crispr和RNAi数据
#此处无需修改，运行一次即可
# cell_line_crispr <- read.csv('/database/depmap/CRISPR_(DepMap_21Q4_Public+Score,_Chronos).csv')
# RNAi_raw <- read.csv('/database/depmap/RNAi_(Achilles+DRIVE+Marcotte,_DEMETER2).csv')
# crispr_raw <- read.csv('/database/depmap/CRISPR_gene_effect_after_process.csv',header = T,row.names = 1)
# #从此处接着运行
# cell_line <- cell_line_crispr
# cell_line <- cell_line[,1:6]
# RNAi <- RNAi_raw
# crispr <- crispr_raw
# ##提取相关crispr数据##mitotic
# mitotic_crispr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%mitotic_cell_cycle[,2])]))
# mitotic_crispr <- cbind(rownames(mitotic_crispr),mitotic_crispr)
# colnames(mitotic_crispr)[1] <- 'gene'
# a <- as.data.frame(mitotic_cell_cycle[,2])
# colnames(a)[1] <- 'gene'
# mitotic_crispr <- merge(a,mitotic_crispr,by='gene',all=T)
# 
# rownames(mitotic_crispr) <- mitotic_crispr[,1]##筛选出肺癌细胞系
# mitotic_crispr <- mitotic_crispr[,-1]
# cancer_cell_line <- cell_line[which(cell_line[,5]=='NSCLC Adenocarcinoma'),]#修改这个位置即可
# cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
# cancer_mitotic_crispr <- mitotic_crispr[,which(colnames(mitotic_crispr)%in%cancer_cell_line[,1])]
# colnames(cancer_mitotic_crispr) == cancer_cell_line[,1]
# colnames(cancer_mitotic_crispr) <- cancer_cell_line[,2]
# 
# plot_cancer_mitotic_crispr <- cancer_mitotic_crispr
# plot_cancer_mitotic_crispr <- as.matrix(plot_cancer_mitotic_crispr)
# plot_cancer_mitotic_crispr[which(is.na(plot_cancer_mitotic_crispr))] <- 0
# plot_cancer_mitotic_crispr <- as.data.frame(plot_cancer_mitotic_crispr)
# 
# bk = unique(c(seq(-1.5,0.5, length=100)))
# a <- pheatmap::pheatmap(plot_cancer_mitotic_crispr,breaks = bk,show_rownames = T,
#                         color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
#                         clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
# ##immune
# immune_crispr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%immune_system[,2])]))
# immune_crispr <- cbind(rownames(immune_crispr),immune_crispr)
# colnames(immune_crispr)[1] <- 'gene'
# a <- as.data.frame(immune_system[,2])
# colnames(a)[1] <- 'gene'
# immune_crispr <- merge(a,immune_crispr,by='gene',all=T)
# immune_crispr <- immune_crispr[immune_crispr[,1]!='',]
# 
# rownames(immune_crispr) <- immune_crispr[,1]##筛选出肺癌细胞系
# immune_crispr <- immune_crispr[,-1]
# cancer_cell_line <- cell_line[which(cell_line[,5]=='NSCLC Adenocarcinoma'),]#修改这个位置即可
# cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
# cancer_immune_crispr <- immune_crispr[,which(colnames(immune_crispr)%in%cancer_cell_line[,1])]
# colnames(cancer_immune_crispr) == cancer_cell_line[,1]
# colnames(cancer_immune_crispr) <- cancer_cell_line[,2]
# 
# plot_cancer_immune_crispr <- cancer_immune_crispr
# plot_cancer_immune_crispr <- as.matrix(plot_cancer_immune_crispr)
# plot_cancer_immune_crispr[which(is.na(plot_cancer_immune_crispr))] <- 0
# plot_cancer_immune_crispr <- as.data.frame(plot_cancer_immune_crispr)
# 
# bk = unique(c(seq(-1.5,0.5, length=100)))
# a <- pheatmap::pheatmap(plot_cancer_immune_crispr,breaks = bk,show_rownames = T,
#                         color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
#                         clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
# ##test
# test_crispr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%test_data[[2]])]))
# test_crispr <- cbind(rownames(test_crispr),test_crispr)
# colnames(test_crispr)[1] <- 'gene'
# a <- as.data.frame(test_data[[2]])
# colnames(a)[1] <- 'gene'
# test_crispr <- merge(a,test_crispr,by='gene',all=T)
# test_crispr <- test_crispr[test_crispr[,1]!='',]
# 
# rownames(test_crispr) <- test_crispr[,1]##筛选出肺癌细胞系
# test_crispr <- test_crispr[,-1]
# cancer_cell_line <- cell_line[which(cell_line[,5]=='NSCLC Adenocarcinoma'),]#修改这个位置即可
# cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
# cancer_test_crispr <- test_crispr[,which(colnames(test_crispr)%in%cancer_cell_line[,1])]
# colnames(cancer_test_crispr) == cancer_cell_line[,1]
# colnames(cancer_test_crispr) <- cancer_cell_line[,2]
# 
# plot_cancer_test_crispr <- cancer_test_crispr
# plot_cancer_test_crispr <- as.matrix(plot_cancer_test_crispr)
# plot_cancer_test_crispr[which(is.na(plot_cancer_test_crispr))] <- 0
# plot_cancer_test_crispr <- as.data.frame(plot_cancer_test_crispr)
# 
# bk = unique(c(seq(-1.5,0.5, length=100)))
# a <- pheatmap::pheatmap(plot_cancer_test_crispr,breaks = bk,show_rownames = T,
#                         color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
#                         clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)




############################以下为独立运行的代码###################################
##cancer_data
#immune_gege_set and mitotic_gene_set
library(stringr)
mitotic_cell_cycle <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic_cell_cycle.txt',sep = '\t')##读取有丝分裂基因
immune_system <- read.table('/database/Gene Ontology/homo_sapiens/immune_system/immune_system.txt',sep = '\t')
cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- numeric()
  for (i in 1:10) {
    a[i] <- length(which(surv_data[[j]][[1]][,i]>=0.8))
  }
  h <- numeric()
  for (i in 1:10) {
    l1 <- ((a[i]-a[1])**2+(i-1)**2)**0.5
    l2 <- ((a[10]-a[i])**2+(10-i)**2)**0.5
    l3 <- ((a[10]-a[1])**2+(10-1)**2)**0.5
    p <- (l1+l2+l3)/2
    area <- (p*(p-l1)*(p-l2)*(p-l3))**0.5
    h[i] <- area/l3
  }
  plot(a)
  surv_data[[j]][[1]] <- surv_data[[j]][[1]][which(rank(1/(surv_data[[j]][[1]][,which(h==max(h))]+1)) <= 150),]
  surv_data[[j]][[2]] <- surv_data[[j]][[2]][which(surv_data[[j]][[2]][,which(h==max(h))] >= min(surv_data[[j]][[1]][,which(h==max(h))])),]
  surv_data[[j]][[3]] <- surv_data[[j]][[3]][which(surv_data[[j]][[3]][,which(h==max(h))] >= min(surv_data[[j]][[1]][,which(h==max(h))])),]
}##read data
surv_data_k1 <- list()
string_raw <- read.csv('/database/string/gene_gene_interaction_string.csv',row.names = 1)
for (j in 1:length(cancer_name)) {
  string <- string_raw[which(string_raw[,3]>=800),]
  surv_data_k1[[j]] <- list()
  for (x in 1:3) {
    surv_data_k1[[j]][[x]] <- list()
    for (i in 1:length(rownames(surv_data[[j]][[x]]))) {
      a <- string[,2][string[,1]%in%rownames(surv_data[[j]][[x]])[i]]
      a <- a[!duplicated(a)]
      surv_data_k1[[j]][[x]][[i]] <- a
    }
    names(surv_data_k1[[j]][[x]]) <- rownames(surv_data[[j]][[x]])
  }
  names(surv_data_k1)[j] <- cancer_name[j]
  names(surv_data_k1[[j]]) <- c('surv_t','surv_up','surv_down')
}##calculate k1
surv_data_pathway_geneset <- list()
for (j in 1:length(cancer_name)) {
  surv_data_pathway_geneset[[j]] <- list()
  surv_data_pathway_geneset[[j]][[1]] <- data.frame()
  surv_data_pathway_geneset[[j]][[2]] <- data.frame()
  names(surv_data_pathway_geneset[[j]]) <- c('surv_up','surv_down')
  for (x in 1:2) {
    for (i in 1:length(rownames(surv_data[[j]][[x+1]]))) {
      a <- c(rownames(surv_data[[j]][[x+1]])[i],surv_data_k1[[j]][[x+1]][[i]])
      b <- rownames(surv_data[[j]][[x+1]])[i]
      surv_data_pathway_geneset[[j]][[x]][i,1] <- length(which(a%in%mitotic_cell_cycle[,2]))
      surv_data_pathway_geneset[[j]][[x]][i,2] <- length(which(a%in%immune_system[,2]))
      surv_data_pathway_geneset[[j]][[x]][i,3] <- length(which(b%in%mitotic_cell_cycle[,2]))
      surv_data_pathway_geneset[[j]][[x]][i,4] <- length(which(b%in%immune_system[,2]))
    }
    rownames(surv_data_pathway_geneset[[j]][[x]]) <- rownames(surv_data[[j]][[x+1]])
    colnames(surv_data_pathway_geneset[[j]][[x]]) <- c('mitotic','immune','mitotic_no_k1','immune_no_k1')
  }
  names(surv_data_pathway_geneset)[j] <- cancer_name[j]
}##

##read database
cell_line_crispr <- read.csv('/database/depmap/CRISPR_(DepMap_21Q4_Public+Score,_Chronos).csv')
RNAi_raw <- read.csv('/database/depmap/RNAi_(Achilles+DRIVE+Marcotte,_DEMETER2).csv')
crispr_raw <- read.csv('/database/depmap/CRISPR_gene_effect_after_process.csv',header = T,row.names = 1)
#从此处接着运行
cell_line <- cell_line_crispr
cell_line <- cell_line[,1:6]
RNAi <- RNAi_raw
crispr <- crispr_raw
cancer_name_crispr_RNAi <- read.csv('cancer_name_crispr_rnai.csv',header = F)
##提取相关crispr数据##mitotic
cancer_mitotic_crispr <- list()
cancer_mitotic_crispr_plot <- list()
cancer_immune_crispr <- list()
cancer_immune_crispr_plot <- list()
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr',sep = ''))
  cancer_mitotic_crispr[[j]] <- list()
  cancer_mitotic_crispr_plot[[j]] <- list()
  for (x in 1:2) {
    tryCatch({
      a <- surv_data_pathway_geneset[[j]][[x]]
      a <- rownames(a[a[,1]>0,])
      mitotic_crispr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
      cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
      cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
      b <- mitotic_crispr[,which(colnames(mitotic_crispr)%in%cancer_cell_line[,1])]
      colnames(b) == cancer_cell_line[,1]
      colnames(b) <- cancer_cell_line[,2]
      bk = unique(c(seq(-1.5,0.5, length=100)))
      a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                              color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
                              clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
      cancer_mitotic_crispr_plot[[j]][[x]] <- a
      cancer_mitotic_crispr[[j]][[x]] <- b
      save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8), 
                        height = (50/268)*(nrow(b)+8), 
                        paste('result/',cancer_name[j],'/','crispr/',cancer_name[j],'_',c('up','down')[x],'_mitotic','.pdf',sep = ''))
    }, error = function(e) {print('error')})
  }
  cancer_immune_crispr[[j]] <- list()
  cancer_immune_crispr_plot[[j]] <- list()
  for (x in 1:2) {
    tryCatch({
      a <- surv_data_pathway_geneset[[j]][[x]]
      a <- rownames(a[a[,2]>0,])
      immune_crispr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
      cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
      cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
      b <- immune_crispr[,which(colnames(immune_crispr)%in%cancer_cell_line[,1])]
      colnames(b) == cancer_cell_line[,1]
      colnames(b) <- cancer_cell_line[,2]
      bk = unique(c(seq(-1.5,0.5, length=100)))
      a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                              color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
                              clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
      cancer_immune_crispr_plot[[j]][[x]] <- a
      cancer_immune_crispr[[j]][[x]] <- b
      save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8), 
                        height = (50/268)*(nrow(b)+8), 
                        paste('result/',cancer_name[j],'/','crispr/',cancer_name[j],'_',c('up','down')[x],'_immune','.pdf',sep = '')) 
    }, error = function(e) {print('error')})
  }
}##基因中包含k1邻居属于通路
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr',sep = ''))
  cancer_mitotic_crispr[[j]] <- list()
  cancer_mitotic_crispr_plot[[j]] <- list()
  for (x in 1:2) {
    tryCatch({
      a <- surv_data_pathway_geneset[[j]][[x]]
      a <- rownames(a[a[,3]>0,])
      mitotic_crispr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
      cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
      cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
      b <- mitotic_crispr[,which(colnames(mitotic_crispr)%in%cancer_cell_line[,1])]
      colnames(b) == cancer_cell_line[,1]
      colnames(b) <- cancer_cell_line[,2]
      bk = unique(c(seq(-1.5,0.5, length=100)))
      a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                              color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
                              clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
      cancer_mitotic_crispr_plot[[j]][[x]] <- a
      cancer_mitotic_crispr[[j]][[x]] <- b
      save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8), 
                        height = (50/268)*(nrow(b)+8), 
                        paste('result/',cancer_name[j],'/','crispr/',cancer_name[j],'_',c('up','down')[x],'_mitotic_no_k1','.pdf',sep = ''))
    }, error = function(e) {print('error')})
  }
  cancer_immune_crispr[[j]] <- list()
  cancer_immune_crispr_plot[[j]] <- list()
  for (x in 1:2) {
    tryCatch({
      a <- surv_data_pathway_geneset[[j]][[x]]
      a <- rownames(a[a[,4]>0,])
      immune_crispr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
      cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
      cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
      b <- immune_crispr[,which(colnames(immune_crispr)%in%cancer_cell_line[,1])]
      colnames(b) == cancer_cell_line[,1]
      colnames(b) <- cancer_cell_line[,2]
      bk = unique(c(seq(-1.5,0.5, length=100)))
      a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                              color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
                              clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
      cancer_immune_crispr_plot[[j]][[x]] <- a
      cancer_immune_crispr[[j]][[x]] <- b
      save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8), 
                        height = (50/268)*(nrow(b)+8), 
                        paste('result/',cancer_name[j],'/','crispr/',cancer_name[j],'_',c('up','down')[x],'_immune_no_k1','.pdf',sep = '')) 
    }, error = function(e) {print('error')})
  }
}##基因中不包含k1邻居属于通路
##药物转录组响应数据
library(dplyr)
library(clusterProfiler)
cancer_name_reaction <- read.csv('cancer_name_reaction.csv',header = F)
for (z in c(2,5:10,12:13,15)) {
  dir.create(paste('result/',cancer_name[z],'/drug_gene_res',sep = ''))
  cell_drug_res <- read.csv(paste('/database/cMAP/',cancer_name_reaction[z,3],sep = ''),header = T,row.names = 1)
  cell_line_info <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_cell_info.csv',header = T)
  cell_line <- as.data.frame(read.csv(paste('/database/cMAP/',cancer_name_reaction[z,2],sep = ''),header = T,row.names = 1)[,1])
  drug_list <- read.csv('/database/cMAP/cancer_cancer_drug_list.csv')
  geneset_id <- bitr(rownames(cell_drug_res),fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
                     toType = c('SYMBOL'), #totype指需要转换成的ID类型
                     OrgDb='org.Hs.eg.db',drop = F)
  geneset_id <- geneset_id[!duplicated(geneset_id[,2]),]
  geneset_id <- geneset_id[which(!is.na(geneset_id[,2])),]
  cell_drug_res <- cell_drug_res[rownames(cell_drug_res) %in% geneset_id[,1],]
  rownames(cell_drug_res) <- geneset_id[,2]
  col_name <- read.csv(paste('/database/cMAP/',cancer_name_reaction[z,3],sep = ''),header = F)[1,-1]
  col_name <- as.data.frame(t(col_name))
  col_name <-str_split(col_name[,1],'[:]',simplify = T)
  col_name <- cbind(col_name[,1],substring(col_name[,2],1,13),col_name[,3])
  col_name <-cbind(str_split(col_name[,1],'[_]',simplify = T),col_name[,2:3])
  col_name <- as.data.frame(col_name)
  for (i in 1:nrow(col_name)) {
    ifelse(col_name[i,4]%in%drug_list[,1],
           col_name[i,6] <- drug_list[which(drug_list[,1]==col_name[i,4]),2],
           col_name[i,6] <- col_name[i,4])
  }
  for (i in 1:nrow(col_name)) {
    col_name[i,7] <- paste(i,'.',col_name[i,1],col_name[i,2],col_name[i,3],col_name[i,6],col_name[i,5],sep = '_')
  }
  for (i in 1:nrow(col_name)) {
    col_name[i,8] <- paste(col_name[i,2],col_name[i,3],col_name[i,6],col_name[i,5],sep = '_')
  }
  cell_drug_res <- as.data.frame(t(cell_drug_res))
  cell_drug_res <- cbind(col_name[,8],cell_drug_res)
  rownames(cell_drug_res) <- col_name[,7]
  cell_drug_res <- aggregate(cell_drug_res[,2:ncol(cell_drug_res)],by=list(cell_drug_res[,1]),FUN=mean)
  rownames(cell_drug_res) <- cell_drug_res[,1]
  cell_drug_res <- cell_drug_res[,-1]
  ##对样本进行排序
  cell_drug_res <- as.data.frame(t(cell_drug_res))
  col_name <- as.data.frame(colnames(cell_drug_res))
  col_name <-cbind(str_split(col_name[,1],'[_]',simplify = T))
  col_name <- as.data.frame(col_name)
  for (i in 1:nrow(col_name)) {
    col_name[i,5] <- paste(col_name[i,1],col_name[i,2],col_name[i,3],col_name[i,4],sep = '_')
  }
  drug_list_2 <- drug_list[-which(duplicated(drug_list[,2])),]
  order_cell_drug_res <- data.frame(1:12319)
  rownames(order_cell_drug_res) <- rownames(cell_drug_res)
  for (y in cell_line[,1]) {
    a <- col_name[which(col_name[,1]==y),]
    for (x in c('DMSO',drug_list_2[,2])) {
      b <- a[which(a[,3]==x),]
      for (j in c('6H','24H')) {
        c <- b[which(b[,2]==j),]
        ifelse(nrow(c)!=0,{c <- c[order(c[,4],decreasing = F),]
        for (i in 1:nrow(c)) {
          order_cell_drug_res <- cbind(order_cell_drug_res,cell_drug_res[,which(colnames(cell_drug_res)==c[i,5])])
        }
        colnames(order_cell_drug_res)[(ncol(order_cell_drug_res)-nrow(c)+1):ncol(order_cell_drug_res)] <- c[,5]},print(0))
      }
    }
  }
  order_cell_drug_res <- order_cell_drug_res[,-1]
  
  cluster_cell_drug_res <- list()
  for (y in cell_line[,1]) {
    d <- data.frame(1:12319)
    rownames(d) <- rownames(cell_drug_res)
    a <- col_name[which(col_name[,1]==y),]
    for (x in c('DMSO',drug_list_2[,2])) {
      b <- a[which(a[,3]==x),]
      for (j in c('6H','24H')) {
        c <- b[which(b[,2]==j),]
        ifelse(nrow(c)!=0,{c <- c[order(c[,4],decreasing = F),]
        for (i in 1:nrow(c)) {
          d <- cbind(d,cell_drug_res[,which(colnames(cell_drug_res)==c[i,5])])
        }
        colnames(d)[(ncol(d)-nrow(c)+1):ncol(d)] <- c[,5]},print(0))
      }
    }
    d <- d[,-1]
    cluster_cell_drug_res[[y]] <- d
  }
  cluster_cell_drug_res <- cluster_cell_drug_res[-2]
  bk = unique(c(seq(-1.5,1.5, length=100)))
  for (x in 1:2) {
    dir.create(paste('result/',cancer_name[z],'/drug_gene_res/',c('surv_up','surv_down')[x],sep = ''))
    for (j in 1:2) {
      dir.create(paste('result/',cancer_name[z],'/drug_gene_res/',c('surv_up','surv_down')[x],'/',c('mitotic','immune')[j],sep = ''))
      cluster_cell_drug_res_up <- list()
      a <- surv_data_pathway_geneset[[z]][[x]]
      a <- rownames(a[a[,j]>0,])
      for (i in 1:length(cluster_cell_drug_res)) {
        cluster_cell_drug_res_up[[i]] <- cluster_cell_drug_res[[i]][which(rownames(cluster_cell_drug_res[[i]])%in%a),]
      }
      names(cluster_cell_drug_res_up) <- names(cluster_cell_drug_res)
      for (i in c(1:length(cluster_cell_drug_res))) {
        ifelse(ncol(cluster_cell_drug_res_up[[i]])==0,0,{
          a <- pheatmap::pheatmap(as.data.frame(t(cluster_cell_drug_res_up[[i]])),breaks = bk,show_rownames = T,
                                  color = colorRampPalette(c("navy", "white", "firebrick3"))(100),
                                  clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = F)
          save_pheatmap_pdf(a,width=(50/268)*(nrow(cluster_cell_drug_res_up[[i]])+80), height = (50/268)*(ncol(cluster_cell_drug_res_up[[i]])+8), paste('result/',cancer_name[z],'/drug_gene_res/',c('surv_up','surv_down')[x],'/',c('mitotic','immune')[j],'/',names(cluster_cell_drug_res)[i],'.pdf',sep = ''))})
        
      }
    }
  }
}##k1信息也纳入分析
for (z in c(2,5:10,12:13,15)) {
  dir.create(paste('result/',cancer_name[z],'/drug_gene_res',sep = ''))
  cell_drug_res <- read.csv(paste('/database/cMAP/',cancer_name_reaction[z,3],sep = ''),header = T,row.names = 1)
  cell_line_info <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_cell_info.csv',header = T)
  cell_line <- as.data.frame(read.csv(paste('/database/cMAP/',cancer_name_reaction[z,2],sep = ''),header = T,row.names = 1)[,1])
  drug_list <- read.csv('/database/cMAP/cancer_cancer_drug_list.csv')
  geneset_id <- bitr(rownames(cell_drug_res),fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
                     toType = c('SYMBOL'), #totype指需要转换成的ID类型
                     OrgDb='org.Hs.eg.db',drop = F)
  geneset_id <- geneset_id[!duplicated(geneset_id[,2]),]
  geneset_id <- geneset_id[which(!is.na(geneset_id[,2])),]
  cell_drug_res <- cell_drug_res[rownames(cell_drug_res) %in% geneset_id[,1],]
  rownames(cell_drug_res) <- geneset_id[,2]
  col_name <- read.csv(paste('/database/cMAP/',cancer_name_reaction[z,3],sep = ''),header = F)[1,-1]
  col_name <- as.data.frame(t(col_name))
  col_name <-str_split(col_name[,1],'[:]',simplify = T)
  col_name <- cbind(col_name[,1],substring(col_name[,2],1,13),col_name[,3])
  col_name <-cbind(str_split(col_name[,1],'[_]',simplify = T),col_name[,2:3])
  col_name <- as.data.frame(col_name)
  for (i in 1:nrow(col_name)) {
    ifelse(col_name[i,4]%in%drug_list[,1],
           col_name[i,6] <- drug_list[which(drug_list[,1]==col_name[i,4]),2],
           col_name[i,6] <- col_name[i,4])
  }
  for (i in 1:nrow(col_name)) {
    col_name[i,7] <- paste(i,'.',col_name[i,1],col_name[i,2],col_name[i,3],col_name[i,6],col_name[i,5],sep = '_')
  }
  for (i in 1:nrow(col_name)) {
    col_name[i,8] <- paste(col_name[i,2],col_name[i,3],col_name[i,6],col_name[i,5],sep = '_')
  }
  cell_drug_res <- as.data.frame(t(cell_drug_res))
  cell_drug_res <- cbind(col_name[,8],cell_drug_res)
  rownames(cell_drug_res) <- col_name[,7]
  cell_drug_res <- aggregate(cell_drug_res[,2:ncol(cell_drug_res)],by=list(cell_drug_res[,1]),FUN=mean)
  rownames(cell_drug_res) <- cell_drug_res[,1]
  cell_drug_res <- cell_drug_res[,-1]
  ##对样本进行排序
  cell_drug_res <- as.data.frame(t(cell_drug_res))
  col_name <- as.data.frame(colnames(cell_drug_res))
  col_name <-cbind(str_split(col_name[,1],'[_]',simplify = T))
  col_name <- as.data.frame(col_name)
  for (i in 1:nrow(col_name)) {
    col_name[i,5] <- paste(col_name[i,1],col_name[i,2],col_name[i,3],col_name[i,4],sep = '_')
  }
  drug_list_2 <- drug_list[-which(duplicated(drug_list[,2])),]
  order_cell_drug_res <- data.frame(1:12319)
  rownames(order_cell_drug_res) <- rownames(cell_drug_res)
  for (y in cell_line[,1]) {
    a <- col_name[which(col_name[,1]==y),]
    for (x in c('DMSO',drug_list_2[,2])) {
      b <- a[which(a[,3]==x),]
      for (j in c('6H','24H')) {
        c <- b[which(b[,2]==j),]
        ifelse(nrow(c)!=0,{c <- c[order(c[,4],decreasing = F),]
        for (i in 1:nrow(c)) {
          order_cell_drug_res <- cbind(order_cell_drug_res,cell_drug_res[,which(colnames(cell_drug_res)==c[i,5])])
        }
        colnames(order_cell_drug_res)[(ncol(order_cell_drug_res)-nrow(c)+1):ncol(order_cell_drug_res)] <- c[,5]},print(0))
      }
    }
  }
  order_cell_drug_res <- order_cell_drug_res[,-1]
  
  cluster_cell_drug_res <- list()
  for (y in cell_line[,1]) {
    d <- data.frame(1:12319)
    rownames(d) <- rownames(cell_drug_res)
    a <- col_name[which(col_name[,1]==y),]
    for (x in c('DMSO',drug_list_2[,2])) {
      b <- a[which(a[,3]==x),]
      for (j in c('6H','24H')) {
        c <- b[which(b[,2]==j),]
        ifelse(nrow(c)!=0,{c <- c[order(c[,4],decreasing = F),]
        for (i in 1:nrow(c)) {
          d <- cbind(d,cell_drug_res[,which(colnames(cell_drug_res)==c[i,5])])
        }
        colnames(d)[(ncol(d)-nrow(c)+1):ncol(d)] <- c[,5]},print(0))
      }
    }
    d <- d[,-1]
    cluster_cell_drug_res[[y]] <- d
  }
  cluster_cell_drug_res <- cluster_cell_drug_res[-2]
  bk = unique(c(seq(-1.5,1.5, length=100)))
  for (x in 1:2) {
    dir.create(paste('result/',cancer_name[z],'/drug_gene_res/',c('surv_up','surv_down')[x],sep = ''))
    for (j in 1:2) {
      dir.create(paste('result/',cancer_name[z],'/drug_gene_res/',c('surv_up','surv_down')[x],'/',c('mitotic','immune')[j],sep = ''))
      cluster_cell_drug_res_up <- list()
      a <- surv_data_pathway_geneset[[z]][[x]]
      a <- rownames(a[a[,j+2]>0,])
      for (i in 1:length(cluster_cell_drug_res)) {
        cluster_cell_drug_res_up[[i]] <- cluster_cell_drug_res[[i]][which(rownames(cluster_cell_drug_res[[i]])%in%a),]
      }
      names(cluster_cell_drug_res_up) <- names(cluster_cell_drug_res)
      for (i in c(1:length(cluster_cell_drug_res))) {
        tryCatch({
          ifelse(ncol(cluster_cell_drug_res_up[[i]])==0,0,{
            a <- pheatmap::pheatmap(as.data.frame(t(cluster_cell_drug_res_up[[i]])),breaks = bk,show_rownames = T,
                                    color = colorRampPalette(c("navy", "white", "firebrick3"))(100),
                                    clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = F)
            save_pheatmap_pdf(a,width=(50/268)*(nrow(cluster_cell_drug_res_up[[i]])+80), height = (50/268)*(ncol(cluster_cell_drug_res_up[[i]])+8), paste('result/',cancer_name[z],'/drug_gene_res/',c('surv_up','surv_down')[x],'/',c('mitotic','immune')[j],'/',names(cluster_cell_drug_res)[i],'_no_k1.pdf',sep = ''))})
        }, error = function(e) {print('error')})
      }
    }
  }
}##k1信息不纳入分析


##显著基因集的构建与分析
##上接超几何分布检测2
##有丝分裂
string <- string_raw
string <- string[string[,3]>=800,]
a <- character()
for (i in rownames(surv_enrich[[1]])[surv_enrich[[1]][,3]<0.05]) {
  a <- c(a,rownames(surv_data_sig[[which(names(surv_data_sig)==i)]][[3]]))
}
a <- a[a%in%mitotic_cell_cycle[,2]]
b <- string[string[,1]%in%a,2]
a <- c(a,b[!duplicated(b)])
a <- a[!duplicated(a)]
sig_geneset <- list()
sig_geneset[[1]] <- a
a <- character()
for (i in rownames(surv_enrich[[2]])[surv_enrich[[2]][,1]<0.05]) {
  a <- c(a,rownames(surv_data_sig[[which(names(surv_data_sig)==i)]][[2]]))
}
a <- a[a%in%immune_system[,2]]
b <- string[string[,1]%in%a,2]
a <- c(a,b[!duplicated(b)])
a <- a[!duplicated(a)]
sig_geneset[[2]] <- a
names(sig_geneset) <- names(surv_enrich) ##得到显著癌症的相关通路基因集
surv_enrich_sig_geneset <- list()
sig_gene_k1 <- list()
for (x in 1:2) {
  sig_gene_k1[[x]] <- list()
  surv_enrich_sig_geneset[[x]] <- data.frame()
  for (i in 1:length(cancer_name)) {
    a <- sig_geneset[[x]][sig_geneset[[x]]%in%rownames(surv_data[[i]][[1]])]
    b <- rownames(surv_data_sig[[i]][[4-x]])
    b <- b[!duplicated(b)]
    sig_gene_k1[[x]][[i]] <- b
    names(sig_gene_k1[[x]])[i] <- cancer_name[i]
    surv_enrich_sig_geneset[[x]][i,1] <- phyper(length(which(b%in%a))-1,
                                                length(a), length(rownames(surv_data[[x]][[1]]))-length(a),
                                                length(b), lower.tail = F)
    surv_enrich_sig_geneset[[x]][i,2] <- length(which(b%in%a))
    surv_enrich_sig_geneset[[x]][i,3] <- length(b)
    colnames(surv_enrich_sig_geneset[[x]]) <- c(names(surv_data_sig[[i]][4-x]),'map_gene','sig_gene')
  }
  rownames(surv_enrich_sig_geneset[[x]]) <- cancer_name
}##富集显著基因集，不包括k1邻居
names(sig_gene_k1) <- names(surv_enrich)
names(surv_enrich_sig_geneset) <- names(surv_enrich)
write.csv(surv_enrich_sig_geneset,'pan_cancer_surv_enrich_no_k1.csv')

surv_enrich_sig_geneset <- list()
sig_gene_k1 <- list()
for (x in 1:2) {
  sig_gene_k1[[x]] <- list()
  surv_enrich_sig_geneset[[x]] <- data.frame()
  for (i in 1:length(cancer_name)) {
    a <- sig_geneset[[x]][sig_geneset[[x]]%in%rownames(surv_data[[i]][[1]])]
    b <- string[string[,1]%in%rownames(surv_data_sig[[i]][[4-x]]),2]
    b <- c(b[!duplicated(b)],rownames(surv_data_sig[[i]][[4-x]]))
    b <- b[!duplicated(b)]
    sig_gene_k1[[x]][[i]] <- b
    names(sig_gene_k1[[x]])[i] <- cancer_name[i]
    surv_enrich_sig_geneset[[x]][i,1] <- phyper(length(which(b%in%a))-1,
                                                length(a), length(rownames(surv_data[[x]][[1]]))-length(a),
                                                length(b), lower.tail = F)
    surv_enrich_sig_geneset[[x]][i,2] <- length(which(b%in%a))
    surv_enrich_sig_geneset[[x]][i,3] <- length(b)
    colnames(surv_enrich_sig_geneset[[x]]) <- c(names(surv_data_sig[[i]][4-x]),'map_gene','sig_gene')
  }
  rownames(surv_enrich_sig_geneset[[x]]) <- cancer_name
}##富集显著基因集，包括k1邻居
names(sig_gene_k1) <- names(surv_enrich)
names(surv_enrich_sig_geneset) <- names(surv_enrich)
write.csv(surv_enrich_sig_geneset,'pan_cancer_surv_enrich_have_k1.csv')


all_gene_k1 <- list()
gene_all_k1_list <- list()
for (x in 1:2) {
  all_gene_k1[[x]] <- character()
  gene_all_k1_list[[x]] <- data.frame()
  for (i in 1:length(cancer_name)) {
    all_gene_k1[[x]] <- c(all_gene_k1[[x]],sig_gene_k1[[x]][[i]])
  }
  a <- all_gene_k1[[x]][!duplicated(all_gene_k1[[x]])]
  gene_all_k1_list[[x]] <- data.frame(a)
  for (i in 1:nrow(gene_all_k1_list[[x]])) {
    gene_all_k1_list[[x]][i,2] <- length(which(all_gene_k1[[x]]%in%gene_all_k1_list[[x]][i,1]))
  }
}
names(all_gene_k1) <- names(surv_enrich)
names(gene_all_k1_list) <- names(surv_enrich)

sig_gene_k1_all <- list()
for (x in 1:2) {
  sig_gene_k1_all[[x]] <- list()
  for (i in 1:length(cancer_name)) {
    a <- sig_geneset[[x]][sig_geneset[[x]]%in%rownames(surv_data[[i]][[1]])]
    b <- string[string[,1]%in%rownames(surv_data_sig[[i]][[4-x]]),2]
    b <- c(b,rownames(surv_data_sig[[i]][[4-x]]))
    sig_gene_k1_all[[x]][[i]] <- b
  }
  names(sig_gene_k1_all[[x]]) <- cancer_name
}
names(sig_gene_k1) <- names(surv_enrich)

for (x in 1:2) {
  for (i in 1:length(cancer_name)) {
    for (j in 1:nrow(gene_all_k1_list[[x]])) {
      gene_all_k1_list[[x]][j,i+2] <- length(which(sig_gene_k1_all[[x]][[i]]%in%gene_all_k1_list[[x]][j,1]))
    }
  }
  colnames(gene_all_k1_list[[x]])[3:17] <- cancer_name
}












string <- string_raw
string <- string[string[,3]>=800,]
a <- character()
for (i in rownames(surv_enrich[[1]])[surv_enrich[[1]][,3]<0.05]) {
  a <- c(a,rownames(surv_data_sig[[which(names(surv_data_sig)==i)]][[3]]))
}
a <- a[a%in%mitotic_cell_cycle[,2]]
b <- string[string[,1]%in%a,2]
a <- c(a,b[!duplicated(b)])
sig_geneset <- a
surv_enrich_sig_geneset <- data.frame()
sig_gene_k1 <- list()
sig_gene_k1[[1]] <- list()
sig_gene_k1[[2]] <- list()
for (i in 1:length(cancer_name)) {
  a <- sig_geneset[sig_geneset%in%rownames(surv_data[[i]][[1]])]
  b <- string[string[,1]%in%rownames(surv_data_sig[[i]][[2]]),2]
  b <- c(b[!duplicated(b)],rownames(surv_data_sig[[i]][[2]]))
  sig_gene_k1[[1]][[i]] <- b
  names(sig_gene_k1[[1]])[i] <- cancer_name[i]
  surv_enrich_sig_geneset[i,1] <- phyper(length(which(b%in%a))-1,
                                         length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                         length(b), lower.tail = F)
  surv_enrich_sig_geneset[i,2] <- c(paste(length(which(b%in%a)),'/',length(b),sep = ''))
  b <- string[string[,1]%in%rownames(surv_data_sig[[i]][[3]]),2]
  b <- c(b[!duplicated(b)],rownames(surv_data_sig[[i]][[3]]))
  sig_gene_k1[[2]][[i]] <- b
  names(sig_gene_k1[[2]])[i] <- cancer_name[i]
  surv_enrich_sig_geneset[i,3] <- phyper(length(which(b%in%a))-1,
                                         length(a), length(rownames(surv_data[[j]][[1]]))-length(a),
                                         length(b), lower.tail = F)
  surv_enrich_sig_geneset[i,4] <- c(paste(length(which(b%in%a)),'/',length(b),sep = ''))
}
names(sig_gene_k1) <- c('surv_up','surv_down')
rownames(surv_enrich_sig_geneset) <- cancer_name
colnames(surv_enrich_sig_geneset) <- c('surv_up','up_ratio','surv_down','down_ratio')

gene_all_k1 <- character()
for (i in 1:length(cancer_name)) {
  gene_all_k1 <- c(gene_all_k1,sig_gene_k1[[2]][[i]])
}
gene_all_k1_list <- gene_all_k1[!duplicated(gene_all_k1)]
gene_all_k1_list<- as.data.frame(gene_all_k1_list)
for (i in 1:nrow(gene_all_k1_list)) {
  gene_all_k1_list[i,2] <- length(which(gene_all_k1==gene_all_k1_list[i,1]))
}
gene_all_k1_list[,1][1:10]

##查看的是另外一个基因集
gene_all_k1 <- character()
for (i in 1:length(cancer_name)) {
  gene_all_k1 <- c(gene_all_k1,sig_gene_k1[[1]][[i]])
}
gene_all_k1_list <- gene_all_k1[!duplicated(gene_all_k1)]
gene_all_k1_list<- as.data.frame(gene_all_k1_list)
for (i in 1:nrow(gene_all_k1_list)) {
  gene_all_k1_list[i,2] <- length(which(gene_all_k1==gene_all_k1_list[i,1]))
}

##免疫
string <- string_raw
string <- string[string[,3]>=800,]
a <- character()
for (i in rownames(surv_enrich[[2]])[surv_enrich[[2]][,1]<0.05]) {
  a <- c(a,rownames(surv_data_sig[[which(names(surv_data_sig)==i)]][[2]]))
}
a <- a[a%in%immune_system[,2]]
b <- string[string[,1]%in%a,2]
a <- c(a,b[!duplicated(b)])
a <- a[!duplicated(a)]
sig_geneset <- a
surv_enrich_sig_geneset <- data.frame()
sig_gene_k1 <- list()
sig_gene_k1[[1]] <- list()
sig_gene_k1[[2]] <- list()
for (i in 1:length(cancer_name)) {
  a <- sig_geneset[sig_geneset%in%rownames(surv_data[[i]][[1]])]
  b <- string[string[,1]%in%rownames(surv_data_sig[[i]][[2]]),2]
  b <- c(b[!duplicated(b)],rownames(surv_data_sig[[i]][[2]]))
  sig_gene_k1[[1]][[i]] <- b
  names(sig_gene_k1[[1]])[i] <- cancer_name[i]
  surv_enrich_sig_geneset[i,1] <- phyper(length(which(b%in%a))-1,
                                         length(a), length(rownames(surv_data[[i]][[1]]))-length(a),
                                         length(b), lower.tail = F)
  surv_enrich_sig_geneset[i,2] <- c(paste(length(which(b%in%a)),'/',length(b),sep = ''))
  b <- string[string[,1]%in%rownames(surv_data_sig[[i]][[3]]),2]
  b <- c(b[!duplicated(b)],rownames(surv_data_sig[[i]][[3]]))
  sig_gene_k1[[2]][[i]] <- b
  names(sig_gene_k1[[2]])[i] <- cancer_name[i]
  surv_enrich_sig_geneset[i,3] <- phyper(length(which(b%in%a))-1,
                                         length(a), length(rownames(surv_data[[i]][[1]]))-length(a),
                                         length(b), lower.tail = F)
  surv_enrich_sig_geneset[i,4] <- c(paste(length(which(b%in%a)),'/',length(b),sep = ''))
}
names(sig_gene_k1) <- c('surv_up','surv_down')
rownames(surv_enrich_sig_geneset) <- cancer_name
colnames(surv_enrich_sig_geneset) <- c('surv_up','up_ratio','surv_down','down_ratio')

gene_all_k1 <- character()
for (i in 1:length(cancer_name)) {
  gene_all_k1 <- c(gene_all_k1,sig_gene_k1[[1]][[i]])
}
gene_all_k1_list <- gene_all_k1[!duplicated(gene_all_k1)]
gene_all_k1_list<- as.data.frame(gene_all_k1_list)
for (i in 1:nrow(gene_all_k1_list)) {
  gene_all_k1_list[i,2] <- length(which(gene_all_k1==gene_all_k1_list[i,1]))
}
gene_all_k1_list[,1][1:10]
length(which(gene_all_k1_list[gene_all_k1_list[,2]>=10,1]%in%test_gene[test_gene[,2]>=10,1]))


# # 
# ##test
# string <- string_raw
# string <- string[string[,3]>=800,]
# a <- character()
# for (i in rownames(surv_enrich[[2]])[surv_enrich[[2]][,1]<0.05]) {
#   a <- c(a,rownames(surv_data_sig[[which(names(surv_data_sig)==i)]][[2]]))
# }
# a <- a[a%in%immune_system[,2]]
# b <- string[string[,1]%in%a,2]
# a <- c(a,b[!duplicated(b)])
# a <- a[!duplicated(a)]
# sig_geneset <- a
# surv_enrich_sig_geneset <- data.frame()
# sig_gene_k1 <- list()
# sig_gene_k1[[1]] <- list()
# sig_gene_k1[[2]] <- list()
# for (i in 1:length(cancer_name)) {
#   a <- sig_geneset
#   b <- string[string[,1]%in%rownames(test_data_sig[[i]][[2]]),2]
#   b <- c(b[!duplicated(b)],rownames(test_data_sig[[i]][[2]]))
#   sig_gene_k1[[1]][[i]] <- b
#   names(sig_gene_k1[[1]])[i] <- cancer_name[i]
#   surv_enrich_sig_geneset[i,1] <- phyper(length(which(b%in%a))-1,
#                                          length(a), length(rownames(surv_data[[1]][[1]]))-length(a),
#                                          length(b), lower.tail = F)
#   surv_enrich_sig_geneset[i,2] <- c(paste(length(which(b%in%a)),'/',length(b),sep = ''))
#   b <- string[string[,1]%in%rownames(test_data_sig[[i]][[3]]),2]
#   b <- c(b[!duplicated(b)],rownames(test_data_sig[[i]][[3]]))
#   sig_gene_k1[[2]][[i]] <- b
#   names(sig_gene_k1[[2]])[i] <- cancer_name[i]
#   surv_enrich_sig_geneset[i,3] <- phyper(length(which(b%in%a))-1,
#                                          length(a), length(rownames(surv_data[[1]][[1]]))-length(a),
#                                          length(b), lower.tail = F)
#   surv_enrich_sig_geneset[i,4] <- c(paste(length(which(b%in%a)),'/',length(b),sep = ''))
# }
# names(sig_gene_k1) <- c('surv_up','surv_down')
# rownames(surv_enrich_sig_geneset) <- cancer_name
# colnames(surv_enrich_sig_geneset) <- c('surv_up','up_ratio','surv_down','down_ratio')
# 
# gene_all_k1 <- character()
# for (i in 1:length(cancer_name)) {
#   gene_all_k1 <- c(gene_all_k1,sig_gene_k1[[1]][[i]])
# }
# gene_all_k1_list <- gene_all_k1[!duplicated(gene_all_k1)]
# gene_all_k1_list<- as.data.frame(gene_all_k1_list)
# for (i in 1:nrow(gene_all_k1_list)) {
#   gene_all_k1_list[i,2] <- length(which(gene_all_k1==gene_all_k1_list[i,1]))
# }
# test_gene <- gene_all_k1_list

####层次聚类生存分析

library(survival)
library(survminer)
expression <- list()
lifetime <- list()
for (i in 1:length(cancer_name)) {
  expression[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/tumor_TCGA_',cancer_name[i],'_immune.csv',sep = ''),row.names = 1) 
  expression[[i]]<- expression[[i]][apply(expression[[i]], 1, mean)>1,]
  lifetime[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/',cancer_name[i],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[[i]][,6] <- gsub('-','.',lifetime[[i]][,6])
  expression[[i]] <- expression[[i]][,which(colnames(expression[[i]]) %in% lifetime[[i]][,6])]
  lifetime[[i]] <- lifetime[[i]][which(lifetime[[i]][,6] %in% colnames(expression[[i]])),]
  lifetime[[i]] <- lifetime[[i]][which(!duplicated(lifetime[[i]][,6])),]
  lifetime[[i]]$Sample.ID <- factor(lifetime[[i]]$Sample.ID, levels = colnames(expression[[i]]))
  lifetime[[i]] <- lifetime[[i]][order(lifetime[[i]]$Sample.ID),]
  lifetime[[i]][which(lifetime[[i]][,2]=='Alive'),2] <- 0
  lifetime[[i]][which(lifetime[[i]][,2]=='Dead'),2] <- 1
}

names(expression) <- cancer_name
names(lifetime) <- cancer_name

geneset <- list()
geneset[[1]] <- gene_all_k1_list[[1]][which(gene_all_k1_list[[1]][,2]>10),1]##修改此处可选取不同显著的基因
geneset[[2]] <- gene_all_k1_list[[2]][which(gene_all_k1_list[[2]][,2]>10),1]##修改此处可选取不同显著的基因
names(geneset) <- names(gene_all_k1_list)
surv_results <- list()
surv_results[[1]] <- data.frame()
gene_set_all <- c(geneset[[1]],geneset[[2]])

write.csv(gene_all_k1_list[[1]],'gene_k1_mito_frequency.csv')
write.csv(gene_all_k1_list[[2]],'gene_k1_immune_frequency.csv')
##单个基因
p_value <- list()
p_value[[1]] <- data.frame(gene_set_all)
cluster_num <- list()
cluster_num[[1]] <- data.frame(gene_set_all)
for (j in 1:length(cancer_name)) {
  for (i in 1:length(gene_set_all)) {
    tryCatch({
      data <- as.matrix(t(expression[[j]][which(rownames(expression[[j]])%in%gene_set_all[i]),]))
      dist.e <- dist(data,method='euclidean')
      model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
      result <- cutree(model1,k=2)#分类
      result <- as.data.frame(result)
      cluster_num[[1]][i,j+1] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
      b <- lifetime[[j]]
      b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
      b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
      c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
      p_value[[1]][i,j+1] <- 1-pchisq(c$chisq,1)
    },warning = function(w) {0}, error = function(e) {0})
  }
}
colnames(p_value[[1]])[2:16] <- cancer_name
colnames(cluster_num[[1]])[2:16] <- cancer_name
a <- character()
for (i in 1:nrow(p_value[[1]])) {
  a <- c(a,length(which(p_value[[1]][i,]<0.05)))
}
p_value[[1]] <- cbind(p_value[[1]][,1],a,p_value[[1]][,2:ncol(p_value[[1]])])
a <- character()
for (i in 1:nrow(p_value[[1]])) {
  a <- c(a,length(which(p_value[[1]][i,]<0.05)))
}
cluster_num[[1]] <- cbind(cluster_num[[1]][,1],a,cluster_num[[1]][,2:ncol(cluster_num[[1]])])

##两个基因
gene_set_all
p_value[[2]] <- list()
cluster_num[[2]] <- list()
for (j in 1:length(cancer_name)) {
  p_value[[2]][[j]] <- data.frame()
  cluster_num[[2]][[j]] <- data.frame()
  for (i in 1:length(gene_set_all)) {
    for (x in 1:(length(gene_set_all)-i)) {
      tryCatch({
        a <- c(gene_set_all[i],gene_set_all[x+i])
        cluster_num[[2]][[j]][nrow(cluster_num[[2]][[j]])+1,1:2] <- a
        p_value[[2]][[j]][nrow(p_value[[2]][[j]])+1,1:2] <- a
        data <- as.matrix(t(expression[[j]][which(rownames(expression[[j]])%in%a),]))
        dist.e <- dist(data,method='euclidean')
        model1 <- hclust(dist.e,method='ward.D2')
        result <- cutree(model1,k=2)#分类
        result <- as.data.frame(result)
        cluster_num[[2]][[j]][nrow(cluster_num[[2]][[j]]),3] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
        b <- lifetime[[j]]
        b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
        b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
        c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
        p_value[[2]][[j]][nrow(p_value[[2]][[j]]),3] <- 1-pchisq(c$chisq,1)
      },warning = function(w) {0}, error = function(e) {0}) 
    }
  }
}
a <- p_value[[2]][[1]][,1:2]
b <- cluster_num[[2]][[1]][,1:2]
for (i in 1:15) {
  a <- cbind(a,p_value[[2]][[i]][,3])
  b <- cbind(b,cluster_num[[2]][[i]][,3])
}
p_value[[2]] <- a
cluster_num[[2]] <- b
colnames(p_value[[2]])[3:17] <- cancer_name
colnames(cluster_num[[2]])[3:17] <- cancer_name
a <- character()
for (i in 1:nrow(p_value[[2]])) {
  a <- c(a,length(which(p_value[[2]][i,]<0.05)))
}
p_value[[2]] <- cbind(p_value[[2]][,1:2],a,p_value[[2]][,3:ncol(p_value[[2]])])
a <- character()
for (i in 1:nrow(p_value[[2]])) {
  a <- c(a,length(which(p_value[[2]][i,]<0.05)))
}
cluster_num[[2]] <- cbind(cluster_num[[2]][,1:2],a,cluster_num[[2]][,3:ncol(cluster_num[[2]])])

##三个基因
gene_set_all
p_value[[3]] <- list()
cluster_num[[3]] <- list()
for (j in 1:length(cancer_name)) {
  p_value[[3]][[j]] <- data.frame()
  cluster_num[[3]][[j]] <- data.frame()
  for (i in 1:length(gene_set_all)) {
    for (x in 1:(length(gene_set_all)-i)) {
      for (k in 1:(length(gene_set_all)-i-x)) {
        tryCatch({
          a <- c(gene_set_all[i],gene_set_all[x+i],gene_set_all[x+i+k])
          cluster_num[[3]][[j]][nrow(cluster_num[[3]][[j]])+1,1:3] <- a
          p_value[[3]][[j]][nrow(p_value[[3]][[j]])+1,1:3] <- a
          data <- as.matrix(t(expression[[j]][which(rownames(expression[[j]])%in%a),]))
          dist.e <- dist(data,method='euclidean')
          model1 <- hclust(dist.e,method='ward.D2')
          result <- cutree(model1,k=2)#分类
          result <- as.data.frame(result)
          cluster_num[[3]][[j]][nrow(cluster_num[[3]][[j]]),4] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
          b <- lifetime[[j]]
          b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
          b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
          c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
          p_value[[3]][[j]][nrow(p_value[[3]][[j]]),4] <- 1-pchisq(c$chisq,1)
        },warning = function(w) {0}, error = function(e) {0})  
      }
    }
  }
}
a <- p_value[[3]][[1]][,1:3]
b <- cluster_num[[3]][[1]][,1:3]
for (i in 1:15) {
  a <- cbind(a,p_value[[3]][[i]][,4])
  b <- cbind(b,cluster_num[[3]][[i]][,4])
}
p_value[[3]] <- a
cluster_num[[3]] <- b
colnames(p_value[[3]])[4:18] <- cancer_name
colnames(cluster_num[[3]])[4:18] <- cancer_name
a <- character()
for (i in 1:nrow(p_value[[3]])) {
  a <- c(a,length(which(p_value[[3]][i,]<0.05)))
}
p_value[[3]] <- cbind(p_value[[3]][,1:3],a,p_value[[3]][,4:ncol(p_value[[3]])])
a <- character()
for (i in 1:nrow(p_value[[3]])) {
  a <- c(a,length(which(p_value[[3]][i,]<0.05)))
}
cluster_num[[3]] <- cbind(cluster_num[[3]][,1:3],a,cluster_num[[3]][,4:ncol(cluster_num[[3]])])
for (i in 1:2) {
  write.csv(p_value[[i]],paste('10_p_value_geneset_',i,'.csv',sep = ''))
  write.csv(cluster_num[[i]],paste('10_cluster_num_geneset_',i,'.csv',sep = ''))
}

####log化biao表达值再进行聚类看看效果
geneset <- list()
geneset[[1]] <- gene_all_k1_list[[1]][which(gene_all_k1_list[[1]][,2]>=10),1]##修改此处可选取不同显著的基因
geneset[[2]] <- gene_all_k1_list[[2]][which(gene_all_k1_list[[2]][,2]>=10),1]##修改此处可选取不同显著的基因
names(geneset) <- names(gene_all_k1_list)
surv_results <- list()
surv_results[[1]] <- data.frame()
gene_set_all <- c(geneset[[1]],geneset[[2]])
##单个基因
p_value <- list()
p_value[[1]] <- data.frame(gene_set_all)
cluster_num <- list()
cluster_num[[1]] <- data.frame(gene_set_all)
for (j in 1:length(cancer_name)) {
  for (i in 1:length(gene_set_all)) {
    tryCatch({
      data <- as.matrix(t(expression[[j]][which(rownames(expression[[j]])%in%gene_set_all[i]),]))
      data <- log2(data+1)
      dist.e <- dist(data,method='euclidean')
      model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
      result <- cutree(model1,k=2)#分类
      result <- as.data.frame(result)
      cluster_num[[1]][i,j+1] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
      b <- lifetime[[j]]
      b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
      b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
      c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
      p_value[[1]][i,j+1] <- 1-pchisq(c$chisq,1)
    },warning = function(w) {0}, error = function(e) {0})
  }
}
colnames(p_value[[1]])[2:16] <- cancer_name
colnames(cluster_num[[1]])[2:16] <- cancer_name
a <- character()
for (i in 1:nrow(p_value[[1]])) {
  a <- c(a,length(which(p_value[[1]][i,]<0.05)))
}
p_value[[1]] <- cbind(p_value[[1]][,1],a,p_value[[1]][,2:ncol(p_value[[1]])])
a <- character()
for (i in 1:nrow(p_value[[1]])) {
  a <- c(a,length(which(p_value[[1]][i,]<0.05)))
}
cluster_num[[1]] <- cbind(cluster_num[[1]][,1],a,cluster_num[[1]][,2:ncol(cluster_num[[1]])])

##两个基因
gene_set_all
p_value[[2]] <- list()
cluster_num[[2]] <- list()
for (j in 1:length(cancer_name)) {
  p_value[[2]][[j]] <- data.frame()
  cluster_num[[2]][[j]] <- data.frame()
  for (i in 1:length(gene_set_all)) {
    for (x in 1:(length(gene_set_all)-i)) {
      tryCatch({
        a <- c(gene_set_all[i],gene_set_all[x+i])
        cluster_num[[2]][[j]][nrow(cluster_num[[2]][[j]])+1,1:2] <- a
        p_value[[2]][[j]][nrow(p_value[[2]][[j]])+1,1:2] <- a
        data <- as.matrix(t(expression[[j]][which(rownames(expression[[j]])%in%a),]))
        data <- log2(data+1)
        dist.e <- dist(data,method='euclidean')
        model1 <- hclust(dist.e,method='ward.D2')
        result <- cutree(model1,k=2)#分类
        result <- as.data.frame(result)
        cluster_num[[2]][[j]][nrow(cluster_num[[2]][[j]]),3] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
        b <- lifetime[[j]]
        b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
        b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
        c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
        p_value[[2]][[j]][nrow(p_value[[2]][[j]]),3] <- 1-pchisq(c$chisq,1)
      },warning = function(w) {0}, error = function(e) {0}) 
    }
  }
}
a <- p_value[[2]][[1]][,1:2]
b <- cluster_num[[2]][[1]][,1:2]
for (i in 1:15) {
  a <- cbind(a,p_value[[2]][[i]][,3])
  b <- cbind(b,cluster_num[[2]][[i]][,3])
}
p_value[[2]] <- a
cluster_num[[2]] <- b
colnames(p_value[[2]])[3:17] <- cancer_name
colnames(cluster_num[[2]])[3:17] <- cancer_name
a <- character()
for (i in 1:nrow(p_value[[2]])) {
  a <- c(a,length(which(p_value[[2]][i,]<0.05)))
}
p_value[[2]] <- cbind(p_value[[2]][,1:2],a,p_value[[2]][,3:ncol(p_value[[2]])])
a <- character()
for (i in 1:nrow(p_value[[2]])) {
  a <- c(a,length(which(p_value[[2]][i,]<0.05)))
}
cluster_num[[2]] <- cbind(cluster_num[[2]][,1:2],a,cluster_num[[2]][,3:ncol(cluster_num[[2]])])


###两个基因画散点图
a <- c('MAPK14','ITGAV')
data <- as.matrix(t(expression[[j]][which(rownames(expression[[j]])%in%a),]))
data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')
result <- cutree(model1,k=2)#分类
result <- as.data.frame(result)
result <- cbind(result,data)
str(result)
ggplot(result, aes(x =MAPK14, y = ITGAV, colour = result)) +
  geom_point()



##三个基因
p_value[[3]] <- list()
cluster_num[[3]] <- list()
for (j in 1:length(cancer_name)) {
  p_value[[3]][[j]] <- data.frame()
  cluster_num[[3]][[j]] <- data.frame()
  for (i in 1:length(gene_set_all)) {
    for (x in 1:(length(gene_set_all)-i)) {
      for (k in 1:(length(gene_set_all)-i-x)) {
        tryCatch({
          a <- c(gene_set_all[i],gene_set_all[x+i],gene_set_all[x+i+k])
          cluster_num[[3]][[j]][nrow(cluster_num[[3]][[j]])+1,1:3] <- a
          p_value[[3]][[j]][nrow(p_value[[3]][[j]])+1,1:3] <- a
          data <- as.matrix(t(expression[[j]][which(rownames(expression[[j]])%in%a),]))
          data <- log2(data+1)
          dist.e <- dist(data,method='euclidean')
          model1 <- hclust(dist.e,method='ward.D2')
          result <- cutree(model1,k=2)#分类
          result <- as.data.frame(result)
          cluster_num[[3]][[j]][nrow(cluster_num[[3]][[j]]),4] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
          b <- lifetime[[j]]
          b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
          b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
          c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
          p_value[[3]][[j]][nrow(p_value[[3]][[j]]),4] <- 1-pchisq(c$chisq,1)
        },warning = function(w) {0}, error = function(e) {0})  
      }
    }
  }
}
a <- p_value[[3]][[1]][,1:3]
b <- cluster_num[[3]][[1]][,1:3]
for (i in 1:15) {
  a <- cbind(a,p_value[[3]][[i]][,4])
  b <- cbind(b,cluster_num[[3]][[i]][,4])
}
p_value[[3]] <- a
cluster_num[[3]] <- b
colnames(p_value[[3]])[4:18] <- cancer_name
colnames(cluster_num[[3]])[4:18] <- cancer_name
a <- character()
for (i in 1:nrow(p_value[[3]])) {
  a <- c(a,length(which(p_value[[3]][i,]<0.05)))
}
p_value[[3]] <- cbind(p_value[[3]][,1:3],a,p_value[[3]][,4:ncol(p_value[[3]])])
a <- character()
for (i in 1:nrow(p_value[[3]])) {
  a <- c(a,length(which(p_value[[3]][i,]<0.05)))
}
cluster_num[[3]] <- cbind(cluster_num[[3]][,1:3],a,cluster_num[[3]][,4:ncol(cluster_num[[3]])])
for (i in 1:3) {
  write.csv(p_value[[i]],paste('log_10_p_value_geneset_',i,'.csv',sep = ''))
  write.csv(cluster_num[[i]],paste('log_10_cluster_num_geneset_',i,'.csv',sep = ''))
}



####################################新的开始##########################################
####通过最开始的分析方式对癌症进行分类
library(stringr)
library(clusterProfiler)
library(survival)
library(survminer)
expression <- list()
lifetime <- list()
for (i in 1:length(cancer_name)) {
  expression[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/tumor_TCGA_',cancer_name[i],'_immune.csv',sep = ''),row.names = 1) 
  expression[[i]]<- expression[[i]][apply(expression[[i]], 1, mean)>1,]
  lifetime[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/',cancer_name[i],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[[i]][,6] <- gsub('-','.',lifetime[[i]][,6])
  expression[[i]] <- expression[[i]][,which(colnames(expression[[i]]) %in% lifetime[[i]][,6])]
  lifetime[[i]] <- lifetime[[i]][which(lifetime[[i]][,6] %in% colnames(expression[[i]])),]
  lifetime[[i]] <- lifetime[[i]][which(!duplicated(lifetime[[i]][,6])),]
  lifetime[[i]]$Sample.ID <- factor(lifetime[[i]]$Sample.ID, levels = colnames(expression[[i]]))
  lifetime[[i]] <- lifetime[[i]][order(lifetime[[i]]$Sample.ID),]
  lifetime[[i]][which(lifetime[[i]][,2]=='Alive'),2] <- 0
  lifetime[[i]][which(lifetime[[i]][,2]=='Dead'),2] <- 1
}
names(expression) <- cancer_name
names(lifetime) <- cancer_name
cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- numeric()
  for (i in 1:10) {
    a[i] <- length(which(surv_data[[j]][[1]][,i]>=0.8))
  }
  h <- numeric()
  for (i in 1:10) {
    l1 <- ((a[i]-a[1])**2+(i-1)**2)**0.5
    l2 <- ((a[10]-a[i])**2+(10-i)**2)**0.5
    l3 <- ((a[10]-a[1])**2+(10-1)**2)**0.5
    p <- (l1+l2+l3)/2
    area <- (p*(p-l1)*(p-l2)*(p-l3))**0.5
    h[i] <- area/l3
  }
  plot(a)
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which(h==max(h))] >= 0.8),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which(h==max(h))] >= min(surv_data_sig[[j]][[1]][,which(h==max(h))])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which(h==max(h))] >= min(surv_data_sig[[j]][[1]][,which(h==max(h))])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name
surv_pathway <- list()
for (j in 1:length(cancer_name)) {
  surv_pathway[[j]] <- list()
  names(surv_pathway)[j] <- cancer_name[j]
  a <- bitr(rownames(surv_data[[j]][[1]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[1]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  a <- bitr(rownames(surv_data[[j]][[2]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[2]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  a <- bitr(rownames(surv_data[[j]][[3]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[3]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  names(surv_pathway[[j]]) <- names(surv_data[[j]])
  surv_pathway[[j]][[1]] <- as.data.frame(surv_pathway[[j]][[1]])
  surv_pathway[[j]][[2]] <- as.data.frame(surv_pathway[[j]][[2]])
  surv_pathway[[j]][[3]] <- as.data.frame(surv_pathway[[j]][[3]])
}
####画表达热图
# expr <- list()
# for (i in 1:length(cancer_name)) {
#   expr[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/tumor_TCGA_',cancer_name[i],'_immune.csv',sep = ''),row.names = 1,header = T)
# }
# names(expr) <- cancer_name
expr_sig <- list()
for (i in 1:length(cancer_name)) {
  expr_sig[[i]] <- log2(rbind(expression[[i]][rownames(expression[[i]])%in%rownames(surv_data_sig[[i]][[2]]),],
                              expression[[i]][rownames(expression[[i]])%in%rownames(surv_data_sig[[i]][[3]]),])+1)
}
names(expr_sig) <- cancer_name
# dist.e <- dist(expr_sig[[1]],method='euclidean')
# model1 <- hclust(dist.e,method='ward.D2')
# result <- cutree(model1,k=2)#分类
# result <- as.data.frame(result)
p_value <- list()
p_value <- data.frame()
# cluster_num <- list()
# cluster_num[[1]] <- data.frame()
for (i in 1:length(cancer_name)) {
  tryCatch({
    data <- as.data.frame(t(expr_sig[[i]]))
    dist.e <- dist(data,method='euclidean')
    model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
    result <- cutree(model1,k=2)#分类
    result <- as.data.frame(result)
    p_value[i,1] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
    b <- lifetime[[i]]
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
    c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
    p_value[i,2] <- 1-pchisq(c$chisq,1)
  },warning = function(w) {0}, error = function(e) {0})
}
rownames(p_value) <- cancer_name

############PCA
library(factoextra)
pca_raw_data <- list()
pca_result <- list()
pca_fig <- list()
pca_var <- list()
for (i in 1:length(cancer_name)) {
  data <- as.data.frame(t(expr_sig[[i]]))
  data.pca<-PCA(data,graph = F)
  eig.val <- get_eigenvalue(data.pca)
  pca_fig[[i]] <- fviz_eig(data.pca, addlabels = TRUE, ylim = c(0, 50))
  var <- get_pca_var(data.pca)
  for (j in 1:4) {
    var[[j]] <- as.data.frame(var[[j]])
  }
  pca_var[[i]] <- var
  pca_result[[i]] <- eig.val
  pca_raw_data[[i]] <- data.pca
}
names(pca_var) <- cancer_name
names(pca_result) <- cancer_name
names(pca_raw_data) <- cancer_name
names(pca_fig) <- cancer_name
####计算每种癌症的PCA的1维基因预测生存的效果
pca_p_value <- list()
for (i in 1:length(cancer_name)) {
  data1 <- pca_var[[i]][[3]]
  data2 <- order(data1[,1],decreasing = T)
  data2 <- data1[data2,]
  pca_p_value[[i]] <- data.frame()
  for (j in 1:length(rownames(data2))) {
    tryCatch({
      data <- as.data.frame(t(expr_sig[[i]][rownames(expr_sig[[i]])%in%rownames(data2)[1:j],]))
      dist.e <- dist(data,method='euclidean')
      model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
      result <- cutree(model1,k=2)#分类
      result <- as.data.frame(result)
      pca_p_value[[i]][j,1] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
      pca_p_value[[i]][j,2] <- length(which(result[,1]==1))/length(which(result[,1]==2))
      b <- lifetime[[i]]
      b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
      b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
      c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
      pca_p_value[[i]][j,3] <- 1-pchisq(c$chisq,1)
      pca_p_value[[i]][j,4:(j+3)] <- rownames(data2)[1:j]
    },warning = function(w) {0}, error = function(e) {0})
  }
}###全部值
names(pca_p_value) <- cancer_name
#大于0.64
pca_p_value_0.64 <- list()
for (i in 1:length(cancer_name)) {
  data1 <- pca_var[[i]][[3]]
  data2 <- order(data1[,1],decreasing = T)
  data2 <- data1[data2,]
  data2 <- data2[data2[,1]>=0.64,]
  pca_p_value_0.64[[i]] <- data.frame()
  for (j in 1:length(rownames(data2))) {
    tryCatch({
      data <- as.data.frame(t(expr_sig[[i]][rownames(expr_sig[[i]])%in%rownames(data2)[1:j],]))
      dist.e <- dist(data,method='euclidean')
      model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
      result <- cutree(model1,k=2)#分类
      result <- as.data.frame(result)
      pca_p_value_0.64[[i]][j,1] <- paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),sep = '')
      pca_p_value_0.64[[i]][j,2] <- length(which(result[,1]==1))/length(which(result[,1]==2))
      b <- lifetime[[i]]
      b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
      b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
      c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
      pca_p_value_0.64[[i]][j,3] <- 1-pchisq(c$chisq,1)
      pca_p_value_0.64[[i]][j,4:(j+3)] <- rownames(data2)[1:j]
    },warning = function(w) {0}, error = function(e) {0})
  }
}###全部值
names(pca_p_value_0.64) <- cancer_name

# data <- as.data.frame(t(expr_sig[[i]]))
# data.pca<-PCA(data,graph = F) #相关矩阵分解
# eig.val <- get_eigenvalue(data.pca)
# fviz_pca_var(data.pca, col.var = "black")
# fviz_eig(data.pca, addlabels = TRUE, ylim = c(0, 50))
# var <- get_pca_var(data.pca)
# for (i in 1:4) {
#   var[[i]] <- as.data.frame(var[[i]])
# }
# 
# fviz_pca_var(data.pca, col.var = "black")

####富集通路
surv_pathway <- list()
for (j in 1:length(cancer_name)) {
  tryCatch({
    data1 <- pca_var[[j]][[3]]
    data2 <- order(data1[,1],decreasing = T)
    data2 <- data1[data2,]
    data2 <- data2[data2[,1]>=0.64,]
    a <- bitr(rownames(data2),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
              toType = c('ENTREZID'), #totype指需要转换成的ID类型
              OrgDb='org.Hs.eg.db')
    surv_pathway[[j]] <- enrichGO(a[,2], #数据源
                                  pvalueCutoff = 0.05, #P值阈值
                                  qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                  OrgDb = org.Hs.eg.db, #人类参考基因组
                                  ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                  readable = TRUE) #是否将基因ID转换为基因名
    surv_pathway[[j]] <- as.data.frame(surv_pathway[[j]])
    names(surv_pathway)[j] <- cancer_name[j]
  },warning = function(w) {0}, error = function(e) {0})
}

surv_pathway <- list()
for (j in 1:length(cancer_name)) {
  tryCatch({
    data1 <- pca_var[[j]][[3]]
    data2 <- order(data1[,1],decreasing = T)
    data2 <- data1[data2,]
    data2 <- data2[1:10,]
    a <- bitr(rownames(data2),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
              toType = c('ENTREZID'), #totype指需要转换成的ID类型
              OrgDb='org.Hs.eg.db')
    surv_pathway[[j]] <- enrichGO(a[,2], #数据源
                                  pvalueCutoff = 0.05, #P值阈值
                                  qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                  OrgDb = org.Hs.eg.db, #人类参考基因组
                                  ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                  readable = TRUE) #是否将基因ID转换为基因名
    surv_pathway[[j]] <- as.data.frame(surv_pathway[[j]])
    names(surv_pathway)[j] <- cancer_name[j]
  },warning = function(w) {0}, error = function(e) {0})
}
??get_eigenvalue
#############
a <- pca_p_value[[2]][min(which(abs(pca_p_value[[2]][,2]-1)%in%min(abs(pca_p_value[[2]][,2]-1)))),]
a <- as.character(a[,4:length(which(!is.na(a[1,])))])
b <- expr_sig[[2]][rownames(expr_sig[[2]])%in%a,]

mid_value <- data.frame()
for (i in 1:nrow(b)) {
  c <- as.numeric(b[i,])
  b[i,c>=median(c)] <- 'high'
  b[i,c<median(c)] <- 'low'
}
lable <- data.frame()
for (i in 1:ncol(b)) {
  lable[i,1] <- colnames(b)[i]
  lable[i,2] <- length(which(b[,i]=='high'))
}

a <- lable[,2]
b <- lifetime[[2]]
b[b[,6]%in%lable[lable[,2]>=median(a),1],7] <- 'X'
b[b[,6]%in%lable[lable[,2]<median(a),1],7] <- 'Y' 
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
1-pchisq(c$chisq,1) 







names(expr_sig) <- cancer_name
bk = unique(c(seq(0,6, length=100)))


library(pheatmap)
pheatmap(expr_sig[[9]],breaks = bk,show_rownames = T,
         color = c(colorRampPalette(c("navy", "white"))(50),colorRampPalette(c("white","firebrick3"))(50)),
         clustering_method = "ward.D2", show_colnames = T,cluster_rows = F,cluster_cols = T)

##########################计算基因间的生存分析相似性#################################
surv_raw_data <- read.csv('result/LUAD/raw_data/50_surv_p.csv',row.names = 1,header = T)
surv_raw_data <- as.matrix(surv_raw_data)
surv_raw_data[surv_raw_data>=0.05] <- 0
surv_raw_data[surv_raw_data!=0] <- 1
a <- surv_raw_data[rownames(surv_raw_data)%in%rownames(surv_data_sig[[8]][[1]]),]
result <- data.frame()
for (i in 1:nrow(a)) {
  for (j in 1:nrow(surv_raw_data)) {
    result[j,i] <- length(which(which(surv_raw_data[j,]==1)%in%which(a[i,]==1)))/((length(which(a[i,]==1))+length(which(surv_raw_data[j,]==1)))-2*length(which(which(a[i,]==1)%in%which(surv_raw_data[j,]==1)))+1)
  }
}
rownames(result) <- rownames(surv_raw_data)
colnames(result) <- rownames(a)
result <- as.matrix(result)
result_matrix <- as.matrix(result)
x <- order(result_matrix,decreasing = T)
length(which(result_matrix>=0.5))#####确定阈值为0.05

surv_sig_inter <- data.frame()
for (i in 1:ncol(result)) {
  a <- which(result[,i]>=0.5)
  n <- nrow(surv_sig_inter)
  surv_sig_inter[(n+1):(n+length(a)),1] <- rep(colnames(result)[i],length(a))
  surv_sig_inter[(n+1):(n+length(a)),2] <- result[a,i]
  surv_sig_inter[(n+1):(n+length(a)),3] <- rownames(result)[a]
}
##计算显著基因的度
#验证结果有无问题
a <- surv_sig_inter[,3][!duplicated(surv_sig_inter[,3])]
min(surv_data[[8]][[1]][which(rownames(surv_data[[8]][[1]])%in%a),])##看一下是不是有不显著的基因被联系到
for (i in 1:nrow(surv_sig_inter)) {
  ifelse(surv_sig_inter[i,1]==surv_sig_inter[i,3],surv_sig_inter[i,2] <- 0,0)
}
surv_sig_inter <- surv_sig_inter[surv_sig_inter[,2]!=0,]
#计算度
a <- surv_sig_inter[,1][!duplicated(surv_sig_inter[,1])]
surv_sig_dgree <- data.frame()
for (i in 1:length(a)) {
  surv_sig_dgree[i,1] <- a[i]
  surv_sig_dgree[i,2] <- length(which(surv_sig_inter[,1]==a[i]))
}
write.csv(surv_sig_inter,'result/LUAD/inter_probality/surv_sig_inter.csv',quote = F,row.names = F)
write.csv(surv_sig_dgree,'result/LUAD/inter_probality/surv_sig_dgree.csv',quote = F,row.names = F)


###批量计算
surv_raw_data <- list()
result <- list()
surv_sig_inter <- list()
surv_sig_dgree <- list()
for (i in 1:length(cancer_name)) {
  file_name <- dir(paste('result/',cancer_name[i],'/raw_data',sep = ''))
  surv_raw_data[[i]] <- read.csv(paste('result/',cancer_name[i],'/raw_data/',file_name,sep = ''),row.names = 1,header = T)
  surv_raw_data[[i]] <- as.matrix(surv_raw_data[[i]])
  surv_raw_data[[i]][surv_raw_data[[i]]>=0.05] <- 0
  surv_raw_data[[i]][surv_raw_data[[i]]!=0] <- 1
  a <- surv_raw_data[[i]][rownames(surv_raw_data[[i]])%in%rownames(surv_data_sig[[i]][[1]]),]
  result[[i]] <- data.frame()
  for (x in 1:nrow(a)) {
    for (j in 1:nrow(surv_raw_data[[i]])) {
      result[[i]][j,x] <- length(which(which(surv_raw_data[[i]][j,]==1)%in%which(a[x,]==1)))/((length(which(a[x,]==1))+length(which(surv_raw_data[[i]][j,]==1)))-2*length(which(which(a[x,]==1)%in%which(surv_raw_data[[i]][j,]==1)))+1)
    }
  }
  rownames(result[[i]]) <- rownames(surv_raw_data[[i]])
  colnames(result[[i]]) <- rownames(a)
  result_matrix <- as.matrix(result[[i]])
  a <- seq(0.01,1,0.01)
  b <- data.frame()
  for (x in 1:100) {
    b[x,1] <- a[x]
    b[x,2] <- length(which(result_matrix>a[x]))-ncol(result_matrix)
  }
  plot(b)
  surv_sig_inter[[i]] <- data.frame()
  for (x in 1:ncol(result[[i]])) {
    a <- which(result[[i]][,x]>=max(b[which(b[,2]>=1000),1]))##此处还需更改，应当需要一个合适的数字
    n <- nrow(surv_sig_inter[[i]])
    surv_sig_inter[[i]][(n+1):(n+length(a)),1] <- rep(colnames(result[[i]])[x],length(a))
    surv_sig_inter[[i]][(n+1):(n+length(a)),2] <- result[[i]][a,x]
    surv_sig_inter[[i]][(n+1):(n+length(a)),3] <- rownames(result[[i]])[a]
  }
  for (x in 1:nrow(surv_sig_inter[[i]])) {
    ifelse(surv_sig_inter[[i]][x,1]==surv_sig_inter[[i]][x,3],surv_sig_inter[[i]][x,2] <- 0,0)
  }
  surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]!=0,]
  a <- surv_sig_inter[[i]][,1][!duplicated(surv_sig_inter[[i]][,1])]
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- length(which(surv_sig_inter[[i]][,1]==a[x]))
  }
  dir.create(paste('result/',cancer_name[i],'/inter_probality',sep = ''))
  write.csv(surv_sig_inter[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_inter.csv',sep = ''),quote = F,row.names = F)
  write.csv(surv_sig_dgree[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_dgree.csv',sep = ''),quote = F,row.names = F)
  write.csv(result[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_result.csv',sep = ''),quote = F)
}
names(surv_sig_inter) <- cancer_name
names(surv_sig_dgree) <- cancer_name
names(result) <- cancer_name

##extract top1000
for (i in 1:15) {
  a <- surv_sig_inter[[i]][order(surv_sig_inter[[i]][,2],decreasing = T)[1000],2]
  surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]>=a,]
}
# surv_sig_inter[[3]] <- read.csv('result/CESC/inter_probality/surv_sig_inter_new.csv')
for (i in 1:15) {
  a <- surv_sig_inter[[i]][,1][!duplicated(surv_sig_inter[[i]][,1])]
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- length(which(surv_sig_inter[[i]][,1]==a[x]))
  }
}

####富集基因
library(clusterProfiler)
for (i in 1:length(cancer_name)) {
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
}
#此处富集度最大的前十个基因
surv_pathway <- list()
for (j in 1:length(cancer_name)) {
  b <- surv_sig_dgree[[j]][1:10,1]
  a <- bitr(b,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]] <- enrichGO(a[,2], #数据源
                                pvalueCutoff = 0.05, #P值阈值
                                qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                OrgDb = org.Hs.eg.db, #人类参考基因组
                                ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                readable = TRUE) #是否将基因ID转换为基因名
}
names(surv_pathway) <- cancer_name
#此处富集度最大基因的高相关性基因群
surv_pathway_top1 <- list()
for (j in 1:length(cancer_name)) {
  b <- surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]
  a <- bitr(b,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway_top1[[j]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
}
names(surv_pathway_top1) <- cancer_name

##export data
for (i in 1:length(cancer_name)) {
  tryCatch({
    a <- as.data.frame(surv_pathway[[i]])
    write.csv(a,paste('pathway_result/',cancer_name[i],'.csv',sep = ''),quote = F)
  }, error = function(e) {print('error')})
}
##export data
for (i in 1:length(cancer_name)) {
  tryCatch({
    a <- as.data.frame(surv_pathway_top1[[i]])
    write.csv(a,paste('pathway_result/',cancer_name[i],'_top1.csv',sep = ''),quote = F)
  }, error = function(e) {print('error')})
}
##整理结果
cancer_name
total <- data.frame()
total[1:15,1] <- cancer_name
for (i in 1:length(cancer_name)) {
  total[i,2] <- nrow(surv_sig_inter[[i]])
  total[i,3] <- nrow(surv_sig_dgree[[i]])
  tryCatch({
    total[i,4] <- nrow(surv_pathway[[i]]@result)
  }, error = function(e) {print('error')})
  tryCatch({
    total[i,5] <- nrow(surv_pathway_top1[[i]]@result)
  }, error = function(e) {print('error')})
}
colnames(total) <- c('cancer name','inter_number','degree','sig_gene_path_num','top1_path_num')
write.csv(total,'pathway_result/total.csv',row.names = F)
top10 <- data.frame()
for (i in 1:length(cancer_name)) {
  top10[i,1:10] <- surv_sig_dgree[[i]][1:10,1]
}
rownames(top10) <- cancer_name
write.csv(top10,'pathway_result/top10_gene.csv',col.names = F)
#####################################对这些基因进行Depmap分析
##read database
cell_line_crispr <- read.csv('/database/depmap/CRISPR_(DepMap_21Q4_Public+Score,_Chronos).csv')
RNAi_raw <- read.csv('/database/depmap/RNAi_(Achilles+DRIVE+Marcotte,_DEMETER2).csv')
crispr_raw <- read.csv('/database/depmap/CRISPR_gene_effect_after_process.csv',header = T,row.names = 1)
#从此处接着运行
cell_line <- cell_line_crispr
cell_line <- cell_line[,1:6]
RNAi <- RNAi_raw
rownames(RNAi) <- RNAi[,1]
RNAi <- RNAi[,-1:-6]
crispr <- crispr_raw
cancer_name_crispr_RNAi <- read.csv('cancer_name_crispr_rnai.csv',header = F)
##提取相关crispr数据
sig_gene_expr_plot <- list()
sig_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr/high_dgree',sep = ''))
  tryCatch({
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0.5, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    sig_gene_expr_plot[[j]] <- a
    sig_gene_expr_crispr[[j]] <- b
    save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8), 
                      height = (50/268)*(nrow(b)+8), 
                      paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_crispr.pdf',sep = ''))
  }, error = function(e) {print('error')})
}
##提取相关RNAi数据
sig_gene_expr_RNAi_plot <- list()
sig_gene_expr_RNAi <- list()
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr/high_dgree',sep = ''))
  tryCatch({
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(RNAi[,which(colnames(RNAi)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    b <- b[,order(colnames(b))]
    cancer_cell_line <- cancer_cell_line[cancer_cell_line[,1]%in%colnames(b),]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0.5, length=100)))
    b <- as.matrix(b)
    b[is.na(b)] <- 0
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(75),colorRampPalette(c("white","firebrick3"))(25)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    sig_gene_expr_RNAi_plot[[j]] <- a
    sig_gene_expr_RNAi[[j]] <- b
    save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8), 
                      height = (50/268)*(nrow(b)+8), 
                      paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_RNAi.pdf',sep = ''))
  }, error = function(e) {print('error')})
}
save_pheatmap_pdf(sig_gene_expr_RNAi_plot[[15]],width=(50/268)*(ncol(b)+8)*1.8, 
                  height = (50/268)*(nrow(b)+8)*0.5, 
                  paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_RNAi.pdf',sep = ''))
save_pheatmap_pdf(sig_gene_expr_plot[[15]],width=(50/268)*(ncol(b)+8)*2.1, 
                  height = (50/268)*(nrow(b)+8)*0.5, 
                  paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_crispr.pdf',sep = ''))

##################################GDSC
library(readxl)
gdsc_1 <- read_excel('/database/GDSC/drug_IC50/GDSC1_fitted_dose_response_25Feb20.xlsx',sheet = 1,col_names = T)
gdsc_2 <- read_excel('/database/GDSC/drug_IC50/GDSC2_fitted_dose_response_25Feb20.xlsx',sheet = 1,col_names = T)
gdsc <- rbind(gdsc_1,gdsc_2)
gdsc <- as.data.frame(gdsc)
cell_annoation <- read_excel('/database/GDSC/drug_IC50/Cell_Lines_Details.xlsx',sheet = 1,col_names = T)
cell_annoation <- as.data.frame(cell_annoation)
cancer_cell_drug <- list()
cancer_cell_list <- list()
cancer_cell_drug_2 <- list()
for (i in 1:length(cancer_name)) {
  cancer_cell_drug_2[[i]] <- list()
  a <- cell_annoation[which(cell_annoation[,10]==cancer_name[i]),]
  b <- gdsc[gdsc[,5]%in%a[,1],]
  b <- b[b[,ncol(b)] <= -1,]####药效阈值
  cancer_cell_drug[[i]] <- b$DRUG_NAME[!duplicated(b$DRUG_NAME)]
  cancer_cell_list[[i]] <- b$CELL_LINE_NAME[!duplicated(b$CELL_LINE_NAME)]
  for (j in 1:length(b[,5][!duplicated(b[,5])])) {
    tryCatch({
      cancer_cell_drug_2[[i]][[j]] <- b$DRUG_NAME[!duplicated(b$DRUG_NAME)&b[,5]==b[,5][!duplicated(b[,5])][j]]
    }, error = function(e) {print('error')})
  }
  names(cancer_cell_drug_2[[i]]) <- b[,5][!duplicated(b[,5])]
}
names(cancer_cell_drug) <- cancer_name
names(cancer_cell_drug_2) <- cancer_name
names(cancer_cell_list) <- cancer_name
##导出有效药物名称
a <- character()
for (i in 1:15) {
  a <- c(a,cancer_cell_drug[[i]])  
}
a <- a[!duplicated(a)]
a <- tolower(a)
write.csv(a,'result/effection_drug_list.csv')
##导出细胞名称
a <- character()
for (i in 1:15) {
  a <- c(a,cancer_cell_list[[i]])  
}
a <- a[!duplicated(a)]
a <- gsub('-','',a)
a
write.csv(a,'result/effect_cell_list.csv')
a

##药物转录组响应数据
library(dplyr)
library(clusterProfiler)
library(stringr)
cancer_name_reaction <- read.csv('cancer_name_reaction.csv',header = F)
cmap_effect_data <- read.csv('/database/cMAP/effection_data/effect_res_data.csv',header = T,row.names = 1)
geneset_id <- bitr(rownames(cmap_effect_data),fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
                   toType = c('SYMBOL'), #totype指需要转换成的ID类型
                   OrgDb='org.Hs.eg.db',drop = F)
geneset_id <- geneset_id[!duplicated(geneset_id[,2]),]
geneset_id <- geneset_id[which(!is.na(geneset_id[,2])),]
cmap_effect_data <- cmap_effect_data[rownames(cmap_effect_data) %in% geneset_id[,1],]
which(rownames(cmap_effect_data)!=geneset_id[,1])
rownames(cmap_effect_data) <- geneset_id[,2]
col_name <- read.csv('/database/cMAP/effection_data/effect_res_data.csv',header = F)[1,]
col_name <- col_name[,-1]
col_name <- as.data.frame(t(col_name))
col_name <-str_split(col_name[,1],'[:]',simplify = T)
col_name <- cbind(col_name[,1],substring(col_name[,2],1,13),col_name[,3])
col_name <-cbind(str_split(col_name[,1],'[_]',simplify = T),col_name[,2:3])
col_name <- as.data.frame(col_name)
drug_id <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_pert_info_trt_cp.csv')
drug_id[,2] <- tolower(drug_id[,2])
drug_id <- drug_id[drug_id[,1]%in%col_name[,4],]

for (i in 1:length(cancer_cell_drug)) {
  cancer_cell_drug[[i]] <- tolower(cancer_cell_drug[[i]])
  cancer_cell_drug[[i]] <- cancer_cell_drug[[i]][cancer_cell_drug[[i]]%in%drug_id[,2]]
  for (j in 1:length(cancer_cell_drug_2[[i]])) {
    cancer_cell_drug_2[[i]][[j]] <- tolower(cancer_cell_drug_2[[i]][[j]])
    cancer_cell_drug_2[[i]][[j]] <- cancer_cell_drug_2[[i]][[j]][cancer_cell_drug_2[[i]][[j]]%in%drug_id[,2]]
  }
}

for (i in 1:length(cancer_name)) {
  cancer_cell_list[[i]] <- gsub('-','',cancer_cell_list[[i]])
  cancer_cell_list[[i]] <- cancer_cell_list[[i]][cancer_cell_list[[i]]%in%col_name[,2]]
  names(cancer_cell_drug_2[[i]]) <- gsub('-','',names(cancer_cell_drug_2[[i]]))
  cancer_cell_drug_2[[i]] <- cancer_cell_drug_2[[i]][which(names(cancer_cell_drug_2[[i]])%in%col_name[,2])]
}

length(which(!duplicated(col_name[,2])))
names(cancer_cell_drug) <- cancer_name
names(cancer_cell_list) <- cancer_name
drug_id <- rbind(c('','','','','','','',''),drug_id)
drug_id[1,1:2] <- c('DMSO','dmso')
for (i in 1:nrow(drug_id)) {
  col_name[col_name[,4]%in%drug_id[i,1],6] <- drug_id[i,2]
}
for (i in 1:nrow(col_name)) {
  col_name[i,7] <- paste(col_name[i,2],col_name[i,6],col_name[i,3],col_name[i,5],col_name[i,1],sep = '_')
}
colnames(cmap_effect_data) <- col_name[,7]

drug_res_expr <- list()
for (i in 1:length(cancer_name)) {
  tryCatch({
    a <- cmap_effect_data[,col_name[,2]%in%cancer_cell_list[[i]]&col_name[,6]%in%c(cancer_cell_drug[[i]],'dmso')]
    a <- a[rownames(a)%in%surv_sig_dgree[[i]][1:10,1],]
    drug_res_expr[[i]] <- a
  }, error = function(e) {print('error')})
}
names(drug_res_expr) <- cancer_name

cell_expr_all <- list()
for (i in 1:length(cancer_name)) {
  cell_expr_all[[i]] <- list()
  if (length(cancer_cell_drug_2[[i]])>0) {
    for (j in 1:length(cancer_cell_drug_2[[i]])) {
      a <- col_name[col_name[,2]==names(cancer_cell_drug_2[[i]])[j],]
      b <- a
      gene_expr <- data.frame(1:nrow(drug_res_expr[[i]]))
      rownames(gene_expr) <- rownames(drug_res_expr[[i]])
      for (z in 1:length(c('dmso',cancer_cell_drug_2[[i]][[j]]))) {
        tryCatch({
          c <- b[b[,6]==c('dmso',cancer_cell_drug_2[[i]][[j]])[z],]
          c <- c[!duplicated(c[,7]),]
          for (x in c('6H','24H')) {
            d <- c[c[,3]==x,]
            d <- d[order(d[,5],decreasing = F),]
            for (k in 1:nrow(d)) {
              gene_expr <- cbind(gene_expr,drug_res_expr[[i]][,grep(d[k,7],colnames(drug_res_expr[[i]]))])#which(colnames(drug_res_expr[[i]])%in%d[k,7])
              ifelse(nrow(d)>0,colnames(gene_expr)[ncol(gene_expr)] <- d[k,7],0)
            }
          }
        }, error = function(e) {print('error')})
      }
      cell_expr_all[[i]][[j]] <- gene_expr
    }
  }
  else{print(0)}
}
##ifelse和cat/tryCatch等不能嵌套，使用tryCatch嵌套时要使用if(){} else{},和for循环似乎也不能嵌套
names(cell_expr_all) <- cancer_name
for (i in 1:length(cancer_name)) {
  names(cell_expr_all[[i]]) <- names(cancer_cell_drug_2[[i]])
  if (length(cell_expr_all[[i]])>0) {
    for (j in 1:length(cell_expr_all[[i]])) {
      a <- as.data.frame(cell_expr_all[[i]][[j]][,-1])
      colnames(a)[ncol(a)] <- colnames(cell_expr_all[[i]][[j]])[ncol(a)+1]
      rownames(a) <- rownames(cell_expr_all[[i]][[j]])
      cell_expr_all[[i]][[j]] <- a
    }
  }
  else{print(0)}
}

for (i in 1:15) {
  for (j in 1:length(cell_expr_all[[i]])) {
    tryCatch({
      a <- as.data.frame(t(cell_expr_all[[i]][[j]]))
      b <- str_split(rownames(a),'[_]',simplify = T)
      b[,5] <- paste(b[,1],b[,2],b[,3],b[,4],sep = '_')
      a <- aggregate(a,by=list(b[,5]),mean)
      rownames(a) <- a[,1]
      a <- a[,-1]
      cell_expr_all[[i]][[j]] <- a
    }, error = function(e) {print('error')})
  }
}

bk = unique(c(seq(-1.5,1.5, length=100)))
for (i in 1:15) {
  for (j in 1:length(cell_expr_all[[i]])) {
    tryCatch({
      a <- pheatmap::pheatmap(cell_expr_all[[i]][[j]],breaks = bk,show_rownames = T,
                              color = colorRampPalette(c("navy", "white", "firebrick3"))(100),
                              clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = F)
      save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8)*2.5, 
                        height = (50/268)*(nrow(b)+8)*2, 
                        paste('result/drug/',cancer_name[i],'_',names(cell_expr_all[[i]][j]),'.pdf',sep = ''))
    }, error = function(e) {print('error')})
  }
}





###############################风险预测模型的建立###############################
library('DESeq2')
library('survival')
library('survminer')
library('dplyr')
library('glmnet')
library('ggplot2')
library('GGally')
library('rms')
library('survivalROC')
library('plotROC')

expr_data_raw <- read.csv(paste('/database/TCGA/',cancer_name[[i]],'/tumor_TCGA_',cancer_name[[i]],'_immune.csv',sep = ''),row.names = 1)
expr_data <- expr_data_raw[rownames(expr_data_raw)%in%surv_sig_dgree[[8]][5:10,1],]
# expr_data <- log2(expr_data+1)
lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[i]],'/',cancer_name[[i]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
lifetime[,6] <- gsub('-','.',lifetime[,6])
lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
lifetime[which(lifetime[,2]=='Alive'),2] <- 0
lifetime[which(lifetime[,2]=='Dead'),2] <- 1
life_data <- lifetime[,c(1,6,5,2)]
colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
for (i in 1:nrow(life_data)) {
  life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
}
survival_cancer <- life_data
colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')


###
#使用合格的基因进行多变量cox回归。
sig_gene_multi_cox <- rownames(expr_data)
survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
#检查PH假设是否支持方差。
ph_hypo_multi <- cox.zph(multi_variate_cox)
#表的最后一行记录了GLOBAL模型上的测试结果。删除它。
ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
#去除ph值假设不支持的方差，进行第二次回归。
formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))##共线性检验
multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)

#check the co-linearity between samples.
correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'spearman')##共线性
library('GGally')
ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], ##共线性
        axisLabels = 'show')+
  theme_bw()+
  theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
        panel.grid = element_blank())
library('rms')
vif <- rms::vif(multi_variate_cox_2)
#Some people said if the square root of VIF >2, they might be co-linear.
sqrt(vif) < 2
###
ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
C_index <- multi_variate_cox_2$concordance['concordance']
if(C_index >= 0.9){
  print('High accuracy')
}else{ 
  if(C_index < 0.9 & C_index >= 0.7){
    print('Medium accuracy')
  }else{
    print('Low accuracy')
  }
}
#calculate the risk score of each sample.
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in colnames(risk_score_table)){
    risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])##共线性
risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                         candidate_genes_for_cox=candidate_genes_for_cox2, 
                                         cox_report=multi_variate_cox_2)

###ROC曲线
multi_ROC <- function(time_vector, risk_score_table){
  library('survivalROC')
  single_ROC <- function(single_time){
    for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                           status = risk_score_table$censoring_status,
                           marker = risk_score_table$total_risk_score,
                           predict.time = single_time, method = 'KM')
    data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
               'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
               'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
  }
  multi_ROC_list <- lapply(time_vector, single_ROC)
  do.call(rbind, multi_ROC_list)
}
#We evaluate 11 AUCs between 3-5 years.
for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
AUC_max <- max(for_multi_ROC$AUC)
AUC_max_time <- max(for_multi_ROC$Time_point)
#visualization of the ROC curves of multiple time points.
pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
  geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
  geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
  theme_bw()+
  theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
        panel.grid = element_blank())+
  annotate("text",x = 0.75, y = 0.15,
           label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
pROC


AUC_max <- max(for_multi_ROC$AUC)##此处应该根据ROC曲线的情况来判断
#maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
AUC_max_time <- AUC_max_time[length(AUC_max_time)]
for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
#find the optimal cutoff value within the ROC curve of the optimal time point.
optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]
high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)
high_low[high_low == TRUE] <- 'high'
high_low[high_low == FALSE] <- 'low'
risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)

#KM_plot generation.
library('survminer')
#first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
# risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
# risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
           legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                         paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))

ggsurvplot(fit_km, conf.int = F,pval = T,legend.title="total risk score",
           legend.labs=c(paste0('>',as.character(round(cut.off,2))), paste0('<=',as.character(round(cut.off,2)))), risk.table = T, 
           palette = c('red','blue'), surv.median.line = 'hv')










######第二次尝试
expr_data_raw <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/tumor_TCGA_',cancer_name[[j]],'_immune.csv',sep = ''),row.names = 1)
# expr_data <- expr_data_raw[rownames(expr_data_raw)%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
# expr_data <- expr_data_raw[rownames(expr_data_raw)%in%surv_sig_dgree[[j]][1:10,1],]
expr_data <- expr_data_raw[rownames(expr_data_raw)%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
expr_data <- log2(expr_data+1)
lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
lifetime[,6] <- gsub('-','.',lifetime[,6])
lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
lifetime[which(lifetime[,2]=='Alive'),2] <- 0
lifetime[which(lifetime[,2]=='Dead'),2] <- 1
life_data <- lifetime[,c(1,6,5,2)]
colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
# DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
# life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
for (i in 1:nrow(life_data)) {
  life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
}
survival_cancer <- life_data
colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')


str(survival_cancer)
survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
gene_list <- colnames(DESeq_norm_vst_for_survival)
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}

uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
##lasso筛选
#about glmnet: x should be in format of matrix, and time&status in y should be in double format.
x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
y <- survival_cancer[,c('overall_survival', 'censoring_status')]
names(y) <- c('time', 'status')
y$time <- as.double(y$time)
y$status <- as.double(y$status)
y <- as.matrix(survival::Surv(y$time, y$status))
x <- x[y[,1]>0,]
y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
Active.Index <- which(as.numeric(coefficient) != 0)
active.coefficients <- as.numeric(coefficient)[Active.Index]
sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
###
#使用合格的基因进行多变量cox回归。
formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
#检查PH假设是否支持方差。
ph_hypo_multi <- cox.zph(multi_variate_cox)
#表的最后一行记录了GLOBAL模型上的测试结果。删除它。
ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
#去除ph值假设不支持的方差，进行第二次回归。
formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)

#check the co-linearity between samples.
correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], method = 'pearson')
library('GGally')
ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], 
        axisLabels = 'show')+
  theme_bw()+
  theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
        panel.grid = element_blank())
library('rms')
vif <- rms::vif(multi_variate_cox_2)
#Some people said if the square root of VIF >2, they might be co-linear.
sqrt(vif) < 2

###
ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
C_index <- multi_variate_cox_2$concordance['concordance']
if(C_index >= 0.9){
  print('High accuracy')
}else{ 
  if(C_index < 0.9 & C_index >= 0.7){
    print('Medium accuracy')
  }else{
    print('Low accuracy')
  }
}
#calculate the risk score of each sample.
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in colnames(risk_score_table)){
    risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                         candidate_genes_for_cox=candidate_genes_for_cox2, 
                                         cox_report=multi_variate_cox_2)

###ROC曲线
multi_ROC <- function(time_vector, risk_score_table){
  library('survivalROC')
  single_ROC <- function(single_time){
    for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                           status = risk_score_table$censoring_status,
                           marker = risk_score_table$total_risk_score,
                           predict.time = single_time, method = 'KM')
    data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
               'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
               'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
  }
  multi_ROC_list <- lapply(time_vector, single_ROC)
  do.call(rbind, multi_ROC_list)
}
#We evaluate 11 AUCs between 3-5 years.
for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
AUC_max <- max(for_multi_ROC$AUC)
AUC_max_time <- max(for_multi_ROC$Time_point)
#visualization of the ROC curves of multiple time points.
pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
  geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
  geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
  theme_bw()+
  theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
        panel.grid = element_blank())+
  annotate("text",x = 0.75, y = 0.15,
           label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
pROC

AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
ifelse(AUC_max>0.5,{
  #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
  AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
  AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
  AUC_max_time <- AUC_max_time[length(AUC_max_time)]
  for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
  #find the optimal cutoff value within the ROC curve of the optimal time point.
  optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
  cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
  high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
  high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
  high_low[high_low == FALSE] <- 'low'
  risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
  #KM_plot generation.
  library('survminer')
  #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
  # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
  # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
  fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
  ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
             legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                           paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
  {
    AUC_max <- min(for_multi_ROC$AUC)##另一个情况
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'high'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
               legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                             paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})


####################################一键循环
predict_effect <- list()
expr_data_raw <- list()
for (j in 1:15) {
  predict_effect[[j]] <- list()
  expr_data_raw[[j]] <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/tumor_TCGA_',cancer_name[[j]],'_immune.csv',sep = ''),row.names = 1)
  # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
  # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][1:10,1],]
  expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
  expr_data <- log2(expr_data+1)
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  life_data <- lifetime[,c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
  # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  
  str(survival_cancer)
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- colnames(DESeq_norm_vst_for_survival)
  uni_cox_in_bulk <- function(gene_list, survival_info_df){
    library('survival')
    gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
    uni_cox <- function(single_gene){
      formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
      surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
      ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
      if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
        single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                        'beta'=surv_uni_cox$coefficients[,1],
                                        'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                        'z_pvalue'=surv_uni_cox$coefficients[,5],
                                        'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                        'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
        single_cox_report
      }
    }
    uni_cox_list <- lapply(gene_list, uni_cox)
    do.call(rbind, uni_cox_list)
  }
  
  uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
  ##lasso筛选
  #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
  x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
  y <- survival_cancer[,c('overall_survival', 'censoring_status')]
  names(y) <- c('time', 'status')
  y$time <- as.double(y$time)
  y$status <- as.double(y$status)
  y <- as.matrix(survival::Surv(y$time, y$status))
  x <- x[y[,1]>0,]
  y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
  lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
  coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
  Active.Index <- which(as.numeric(coefficient) != 0)
  active.coefficients <- as.numeric(coefficient)[Active.Index]
  sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
  ###
  #使用合格的基因进行多变量cox回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
  multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
  #检查PH假设是否支持方差。
  ph_hypo_multi <- cox.zph(multi_variate_cox)
  #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
  ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
  #去除ph值假设不支持的方差，进行第二次回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
  multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
  
  #check the co-linearity between samples.
  correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], method = 'pearson')
  library('GGally')
  ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], 
          axisLabels = 'show')+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())
  library('rms')
  vif <- rms::vif(multi_variate_cox_2)
  #Some people said if the square root of VIF >2, they might be co-linear.
  sqrt(vif) < 2
  
  ###
  ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
  C_index <- multi_variate_cox_2$concordance['concordance']
  if(C_index >= 0.9){
    print('High accuracy')
  }else{ 
    if(C_index < 0.9 & C_index >= 0.7){
      print('Medium accuracy')
    }else{
      print('Low accuracy')
    }
  }
  #calculate the risk score of each sample.
  riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
    library('dplyr')
    risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
    for(each_sig_gene in colnames(risk_score_table)){
      risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
    }
    risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
      cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
    risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
    risk_score_table
  }
  candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
  risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                           candidate_genes_for_cox=candidate_genes_for_cox2, 
                                           cox_report=multi_variate_cox_2)
  ###ROC曲线
  multi_ROC <- function(time_vector, risk_score_table){
    library('survivalROC')
    single_ROC <- function(single_time){
      for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                             status = risk_score_table$censoring_status,
                             marker = risk_score_table$total_risk_score,
                             predict.time = single_time, method = 'KM')
      data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                 'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                 'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
    }
    multi_ROC_list <- lapply(time_vector, single_ROC)
    do.call(rbind, multi_ROC_list)
  }
  #We evaluate 11 AUCs between 3-5 years.
  for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
  AUC_max <- max(for_multi_ROC$AUC)
  AUC_max_time <- max(for_multi_ROC$Time_point)
  #visualization of the ROC curves of multiple time points.
  pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
    geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
    geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())+
    annotate("text",x = 0.75, y = 0.15,
             label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
  pROC
  predict_effect[[j]][[1]] <- pROC
  
  AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
  ifelse(AUC_max>0.5,{
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                           legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                         paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
    {
      AUC_max <- min(for_multi_ROC$AUC)##另一个情况
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'high'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      #KM_plot generation.
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                             legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                           paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
}
predict_effect[[10]][[2]]

j=1
predict_effect_2 <- list()
for (j in 1:15) {
  predict_effect_2[[j]] <- list()
  expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c('HSPB7','ALDH1L2','LRP1'),]
  # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>70,1],]
  # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][1:5,1],]
  # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
  expr_data <- log2(expr_data+1)
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  life_data <- lifetime[,c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
  # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  
  str(survival_cancer)
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- colnames(DESeq_norm_vst_for_survival)
  uni_cox_in_bulk <- function(gene_list, survival_info_df){
    library('survival')
    gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
    uni_cox <- function(single_gene){
      formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
      surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
      ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
      if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
        single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                        'beta'=surv_uni_cox$coefficients[,1],
                                        'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                        'z_pvalue'=surv_uni_cox$coefficients[,5],
                                        'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                        'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
        single_cox_report
      }
    }
    uni_cox_list <- lapply(gene_list, uni_cox)
    do.call(rbind, uni_cox_list)
  }
  
  uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
  ##lasso筛选
  #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
  x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
  y <- survival_cancer[,c('overall_survival', 'censoring_status')]
  names(y) <- c('time', 'status')
  y$time <- as.double(y$time)
  y$status <- as.double(y$status)
  y <- as.matrix(survival::Surv(y$time, y$status))
  x <- x[y[,1]>0,]
  y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
  lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
  coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
  Active.Index <- which(as.numeric(coefficient) != 0)
  active.coefficients <- as.numeric(coefficient)[Active.Index]
  sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
  ###
  #使用合格的基因进行多变量cox回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
  multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
  #检查PH假设是否支持方差。
  ph_hypo_multi <- cox.zph(multi_variate_cox)
  #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
  ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
  #去除ph值假设不支持的方差，进行第二次回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
  multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
  
  #check the co-linearity between samples.
  correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
  library('GGally')
  ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
          axisLabels = 'show')+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())
  library('rms')
  vif <- rms::vif(multi_variate_cox_2)
  #Some people said if the square root of VIF >2, they might be co-linear.
  sqrt(vif) < 2
  
  ###
  ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
  C_index <- multi_variate_cox_2$concordance['concordance']
  if(C_index >= 0.9){
    print('High accuracy')
  }else{ 
    if(C_index < 0.9 & C_index >= 0.7){
      print('Medium accuracy')
    }else{
      print('Low accuracy')
    }
  }
  #calculate the risk score of each sample.
  riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
    library('dplyr')
    risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
    for(each_sig_gene in colnames(risk_score_table)){
      risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
    }
    risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
      cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
    risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
    risk_score_table
  }
  candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05])
  risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                           candidate_genes_for_cox=candidate_genes_for_cox2, 
                                           cox_report=multi_variate_cox_2)
  ###ROC曲线
  multi_ROC <- function(time_vector, risk_score_table){
    library('survivalROC')
    single_ROC <- function(single_time){
      for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                             status = risk_score_table$censoring_status,
                             marker = risk_score_table$total_risk_score,
                             predict.time = single_time, method = 'KM')
      data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                 'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                 'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
    }
    multi_ROC_list <- lapply(time_vector, single_ROC)
    do.call(rbind, multi_ROC_list)
  }
  #We evaluate 11 AUCs between 3-5 years.
  for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
  AUC_max <- max(for_multi_ROC$AUC)
  AUC_max_time <- max(for_multi_ROC$Time_point)
  #visualization of the ROC curves of multiple time points.
  pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
    geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
    geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())+
    annotate("text",x = 0.75, y = 0.15,
             label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
  pROC
  predict_effect_2[[j]][[1]] <- pROC
  
  AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
  ifelse(AUC_max>0.5,{
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect_2[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                             legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                           paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
    {
      AUC_max <- min(for_multi_ROC$AUC)##另一个情况
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'high'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      #KM_plot generation.
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect_2[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                               legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                             paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
}
predict_effect_2[[10]][[1]]

####穷举
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in colnames(risk_score_table)){
    risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
multi_ROC <- function(time_vector, risk_score_table){
  library('survivalROC')
  single_ROC <- function(single_time){
    for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                           status = risk_score_table$censoring_status,
                           marker = risk_score_table$total_risk_score,
                           predict.time = single_time, method = 'KM')
    data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
               'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
               'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
  }
  multi_ROC_list <- lapply(time_vector, single_ROC)
  do.call(rbind, multi_ROC_list)
}
###############3个基因的预后分析
predict_effect_3 <- list()
for (j in 1:15) {
  predict_effect_3[[j]] <- data.frame('','','')
  expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][1:20,1],]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][,c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- surv_sig_dgree[[j]][1:20,1]
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  for (k in 1:18) {
    for (x in (k+1):19) {
      for (v in (x+1):20) {
        gene_set <- c(gene_list[k],gene_list[x],gene_list[v])
        predict_effect_3[[j]] <- rbind(predict_effect_3[[j]],gene_set)
        formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
        multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
        candidate_genes_for_cox2 <- gene_set
        risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                 candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                 cox_report=multi_variate_cox_2)
        cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
        high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'low'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
        predict_effect_3[[j]][nrow(predict_effect_3[[j]]),4] <- 1-pchisq(fit_km$chisq,1)
      }
    }
  }
}
names(predict_effect_3) <- cancer_name
###############4个基因的预后分析
predict_effect_4 <- list()
for (j in 1:15) {
  predict_effect_4[[j]] <- data.frame('','','','')
  expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][1:20,1],]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][,c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- surv_sig_dgree[[j]][1:20,1]
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  for (k in 1:17) {
    for (x in (k+1):18) {
      for (v in (x+1):19) {
        for (e in (v+1):20) {
          gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e])
          predict_effect_4[[j]] <- rbind(predict_effect_4[[j]],gene_set)
          formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
          multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
          candidate_genes_for_cox2 <- gene_set
          risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                   candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                   cox_report=multi_variate_cox_2)
          cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
          high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
          high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
          high_low[high_low == FALSE] <- 'low'
          risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
          fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
          predict_effect_4[[j]][nrow(predict_effect_4[[j]]),5] <- 1-pchisq(fit_km$chisq,1)
        }
      }
    }
  }
}
names(predict_effect_4) <- cancer_name
###############5个基因的预后分析
predict_effect_5 <- list()
for (j in 1:15) {
  predict_effect_5[[j]] <- data.frame('','','','','')
  expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][1:20,1],]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][,c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- surv_sig_dgree[[j]][1:20,1]
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  for (k in 1:16) {
    for (x in (k+1):17) {
      for (v in (x+1):18) {
        for (e in (v+1):19) {
          for (s in (e+1):20) {
            gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e],gene_list[s])
            predict_effect_5[[j]] <- rbind(predict_effect_5[[j]],gene_set)
            formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
            multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
            candidate_genes_for_cox2 <- gene_set
            risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                     candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                     cox_report=multi_variate_cox_2)
            cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
            high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
            high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
            high_low[high_low == FALSE] <- 'low'
            risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
            fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
            predict_effect_5[[j]][nrow(predict_effect_4[[j]]),6] <- 1-pchisq(fit_km$chisq,1)
          }
        }
      }
    }
  }
}
names(predict_effect_5) <- cancer_name
###############6个基因的预后分析
predict_effect_6 <- list()
for (j in 1:15) {
  predict_effect_6[[j]] <- data.frame('','','','','','')
  expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][1:20,1],]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][,c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- surv_sig_dgree[[j]][1:20,1]
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  for (k in 1:15) {
    for (x in (k+1):16) {
      for (v in (x+1):17) {
        for (e in (v+1):18) {
          for (s in (e+1):19) {
            for (w in (s+1):20) {
              gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e],gene_list[s],gene_list[w])
              predict_effect_6[[j]] <- rbind(predict_effect_6[[j]],gene_set)
              formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
              multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
              candidate_genes_for_cox2 <- gene_set
              risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                       candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                       cox_report=multi_variate_cox_2)
              cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
              high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
              high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
              high_low[high_low == FALSE] <- 'low'
              risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
              fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
              predict_effect_6[[j]][nrow(predict_effect_4[[j]]),6] <- 1-pchisq(fit_km$chisq,1)
            }
          }
        }
      }
    }
  }
}
names(predict_effect_6) <- cancer_name

expr_data <- as.data.frame(t(expr_data))

for (j in 1:15) {
  predict_effect_2[[j]][,4] <- as.numeric(predict_effect_2[[j]][,4])
}
j=4
########################画图
for (j in 2) {
  # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>70,1],]
  expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%as.character(predict_effect_2[[j]][which.min(predict_effect_2[[j]][,4]),1:3]),]
  # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%as.character(predict_effect_2[[j]][order(predict_effect_2[[j]][,4],decreasing = F)[1],1:3]),]
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][,c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
  # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  
  str(survival_cancer)
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- colnames(DESeq_norm_vst_for_survival)
  
  ###
  gene_list
  #使用合格的基因进行多变量cox回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_list, sep = '', collapse = '+')))
  multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
  #检查PH假设是否支持方差。
  ph_hypo_multi <- cox.zph(multi_variate_cox)
  #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
  ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
  #去除ph值假设不支持的方差，进行第二次回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
  multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
  
  #check the co-linearity between samples.
  correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], method = 'pearson')
  library('GGally')
  ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], 
          axisLabels = 'show')+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())
  library('rms')
  vif <- rms::vif(multi_variate_cox_2)
  #Some people said if the square root of VIF >2, they might be co-linear.
  sqrt(vif) < 2
  
  ###
  ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
  C_index <- multi_variate_cox_2$concordance['concordance']
  if(C_index >= 0.9){
    print('High accuracy')
  }else{ 
    if(C_index < 0.9 & C_index >= 0.7){
      print('Medium accuracy')
    }else{
      print('Low accuracy')
    }
  }
  #calculate the risk score of each sample.
  candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
  risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                           candidate_genes_for_cox=candidate_genes_for_cox2, 
                                           cox_report=multi_variate_cox_2)
  ###ROC曲线
  #We evaluate 11 AUCs between 3-5 years.
  for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
  AUC_max <- max(for_multi_ROC$AUC)
  AUC_max_time <- max(for_multi_ROC$Time_point)
  #visualization of the ROC curves of multiple time points.
  pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
    geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
    geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())+
    annotate("text",x = 0.75, y = 0.15,
             label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
  pROC
  
  AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
  if (AUC_max>0.5) {
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
               legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                             paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))
  }else{
    AUC_max <- min(for_multi_ROC$AUC)##另一个情况
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'high'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    surv_plot <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                            legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                          paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))
  }
}

pROC
surv_plot
pl <- ggsurvplot(fit_km,            # 创建的拟合对象
                 conf.int = T,    # 显示置信区间
                 pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                 add.all = F,     # 添加总患者生存曲线
                 palette = "hue",    # 自定义调色板
                 surv.median.line = "hv",     # 添加中位生存时间线
                 risk.table = TRUE,             # 添加风险表
                 xlab = "Follow up time(m)", # 指定x轴标签
                 legend = c(0.8,0.75),         # 指定图例位置
                 legend.title = "",                 # 设置图例标题
                 legend.labs = c('high','low'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致
                 break.x.by = 300)              # 设置x轴刻度间距
pl



gene_set_num1 <- data.frame()
for (i in 1:15) {
  predict_effect_2[[i]] <- predict_effect_2[[i]][!is.na(predict_effect_2[[i]][,4]),]
  gene_set_num1[i,1:4] <- predict_effect_2[[i]][which.min(predict_effect_2[[i]][,4]),]
}
gene_set_num1 <- data.frame()
for (i in 1:15) {
  predict_effect_4[[i]] <- predict_effect_4[[i]][!is.na(predict_effect_4[[i]][,5]),]
  gene_set_num1[i,1:5] <- predict_effect_4[[i]][which.min(predict_effect_4[[i]][,5]),]
}
rownames(gene_set_num1) <- cancer_name
colnames(gene_set_num1) <- c('gene1','gene2','gene3','p_value')
write.csv(gene_set_num1,'result/predict_geneset/gene_set_3.csv')





##########################################新的开始####################################
####整理数据，计算显著基因集，并进行通路富集
library(clusterProfiler)
library(stringr)
cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- numeric()
  for (i in 1:10) {
    a[i] <- length(which(surv_data[[j]][[1]][,i]>=0.8))
  }
  h <- numeric()
  for (i in 1:10) {
    l1 <- ((a[i]-a[1])**2+(i-1)**2)**0.5
    l2 <- ((a[10]-a[i])**2+(10-i)**2)**0.5
    l3 <- ((a[10]-a[1])**2+(10-1)**2)**0.5
    p <- (l1+l2+l3)/2
    area <- (p*(p-l1)*(p-l2)*(p-l3))**0.5
    h[i] <- area/l3
  }
  plot(a)
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which(h==max(h))] >= 0.8),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which(h==max(h))] >= min(surv_data_sig[[j]][[1]][,which(h==max(h))])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which(h==max(h))] >= min(surv_data_sig[[j]][[1]][,which(h==max(h))])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name
surv_pathway <- list()
for (j in 1:length(cancer_name)) {
  surv_pathway[[j]] <- list()
  names(surv_pathway)[j] <- cancer_name[j]
  a <- bitr(rownames(surv_data[[j]][[1]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[1]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  a <- bitr(rownames(surv_data[[j]][[2]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[2]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  a <- bitr(rownames(surv_data[[j]][[3]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[3]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  names(surv_pathway[[j]]) <- names(surv_data[[j]])
  surv_pathway[[j]][[1]] <- as.data.frame(surv_pathway[[j]][[1]])
  surv_pathway[[j]][[2]] <- as.data.frame(surv_pathway[[j]][[2]])
  surv_pathway[[j]][[3]] <- as.data.frame(surv_pathway[[j]][[3]])
}

###批量计算样本生存分析网络
surv_raw_data <- list()
result <- list()
surv_sig_inter <- list()
surv_sig_dgree <- list()
for (i in 1:length(cancer_name)) {
  file_name <- dir(paste('result/',cancer_name[i],'/raw_data',sep = ''))
  surv_raw_data[[i]] <- read.csv(paste('result/',cancer_name[i],'/raw_data/',file_name,sep = ''),row.names = 1,header = T)
  surv_raw_data[[i]] <- as.matrix(surv_raw_data[[i]])
  surv_raw_data[[i]][surv_raw_data[[i]]>=0.05] <- 0
  surv_raw_data[[i]][surv_raw_data[[i]]!=0] <- 1
  a <- surv_raw_data[[i]][rownames(surv_raw_data[[i]])%in%rownames(surv_data_sig[[i]][[1]]),]
  result[[i]] <- data.frame()
  for (x in 1:nrow(a)) {
    for (j in 1:nrow(surv_raw_data[[i]])) {
      result[[i]][j,x] <- 1-(length(which(which(surv_raw_data[[i]][j,]==1)%in%which(a[x,]==1)))/(1000-length(which(which(surv_raw_data[[i]][j,]==0)%in%which(a[x,]==0)))))##杰卡德距离(Jaccard distance)
    }
  }
  rownames(result[[i]]) <- rownames(surv_raw_data[[i]])
  colnames(result[[i]]) <- rownames(a)
  result_matrix <- as.matrix(result[[i]])
  for (x in 1:ncol(result_matrix)) {
    result_matrix[which(rownames(result_matrix)==colnames(result_matrix)[x]),x] <- 1
  }
  cut_off <- result_matrix[order(result_matrix,decreasing = F)[1000]]
  surv_sig_inter[[i]] <- data.frame()
  for (x in 1:ncol(result[[i]])) {
    a <- which(result_matrix[,x]<=cut_off)##此处还需更改，应当需要一个合适的数字
    if (length(a)>0) {
      n <- nrow(surv_sig_inter[[i]])
      surv_sig_inter[[i]][(n+1):(n+length(a)),1] <- rep(colnames(result[[i]])[x],length(a))
      surv_sig_inter[[i]][(n+1):(n+length(a)),2] <- result[[i]][a,x]
      surv_sig_inter[[i]][(n+1):(n+length(a)),3] <- rownames(result[[i]])[a]
    }else{0}
  }
  a <- surv_sig_inter[[i]][,1][!duplicated(surv_sig_inter[[i]][,1])]
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- length(which(surv_sig_inter[[i]][,1]==a[x]))
  }
  write.csv(surv_sig_inter[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_inter.csv',sep = ''),quote = F,row.names = F)
  write.csv(surv_sig_dgree[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_dgree.csv',sep = ''),quote = F,row.names = F)
  write.csv(result[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_result.csv',sep = ''),quote = F,row.names = F)
  print(cancer_name[[i]])
}
names(surv_sig_inter) <- cancer_name
names(surv_sig_dgree) <- cancer_name
names(result) <- cancer_name

####富集分析
for (i in 1:length(cancer_name)) {
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
}
#取surv_sig_degree的top10基因进行富集分析
surv_pathway <- list()
for (j in 1:length(cancer_name)) {
  b <- surv_sig_dgree[[j]][1:10,1]
  a <- bitr(b,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]] <- enrichGO(a[,2], #数据源
                                pvalueCutoff = 0.05, #P值阈值
                                qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                OrgDb = org.Hs.eg.db, #人类参考基因组
                                ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                readable = TRUE) #是否将基因ID转换为基因名
}
names(surv_pathway) <- cancer_name
#此处富集度最大基因的高相关性基因群
surv_pathway_top1 <- list()
for (j in 1:length(cancer_name)) {
  b <- surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]
  a <- bitr(b,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway_top1[[j]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
}
names(surv_pathway_top1) <- cancer_name

####Depmap分析
##read database
cell_line_crispr <- read.csv('/database/depmap/CRISPR_(DepMap_21Q4_Public+Score,_Chronos).csv')
RNAi_raw <- read.csv('/database/depmap/RNAi_(Achilles+DRIVE+Marcotte,_DEMETER2).csv')
crispr_raw <- read.csv('/database/depmap/CRISPR_gene_effect_after_process.csv',header = T,row.names = 1)
#从此处接着运行
cell_line <- cell_line_crispr
cell_line <- cell_line[,1:6]
RNAi <- RNAi_raw
rownames(RNAi) <- RNAi[,1]
RNAi <- RNAi[,-1:-6]
crispr <- crispr_raw
cancer_name_crispr_RNAi <- read.csv('cancer_name_crispr_rnai.csv',header = F)
##提取相关crispr数据
sig_gene_expr_plot <- list()
sig_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr/high_dgree',sep = ''))
  tryCatch({
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    sig_gene_expr_plot[[j]] <- a
    sig_gene_expr_crispr[[j]] <- b
    save_pheatmap_pdf(a,width=((50/268)*(ncol(b)+8))*1.8, 
                      height =((50/268)*(nrow(b)+8))*1.8, 
                      paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_crispr.pdf',sep = ''))
  }, error = function(e) {print('error')})
}
##提取相关RNAi数据
sig_gene_expr_RNAi_plot <- list()
sig_gene_expr_RNAi <- list()
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr/high_dgree',sep = ''))
  tryCatch({
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(RNAi[,which(colnames(RNAi)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    b <- b[,order(colnames(b))]
    cancer_cell_line <- cancer_cell_line[cancer_cell_line[,1]%in%colnames(b),]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0, length=100)))
    b <- as.matrix(b)
    b[is.na(b)] <- 0
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    sig_gene_expr_RNAi_plot[[j]] <- a
    sig_gene_expr_RNAi[[j]] <- b
    save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8)*1.8, 
                      height = (50/268)*(nrow(b)+8)*1.8, 
                      paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_RNAi.pdf',sep = ''))
  }, error = function(e) {print('error')})
}
names(sig_gene_expr_plot) <- cancer_name
names(sig_gene_expr_crispr) <- cancer_name
names(sig_gene_expr_RNAi_plot) <- cancer_name
names(sig_gene_expr_RNAi) <- cancer_name

#Depmap分析有丝分裂通路中的基因对细胞生存的影响
ref_path_mitotic <- read.table('reference/cell_cycle_mitotic.txt')
ref_path_mitotic <- as.matrix(ref_path_mitotic)
ref_path_mitotic <- as.vector(ref_path_mitotic)
surv_sig_dgree <- list()
for (i in 1:15) {
  surv_sig_dgree[[i]] <- read.csv(paste('result/',cancer_name[i],'/inter_probality/surv_sig_dgree.csv',sep = ''))
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
}
names(surv_sig_dgree) <- cancer_name

mitotic_gene_expr_plot <- list()
mitotic_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr/high_dgree/mitotic',sep = ''))
  tryCatch({
    a <- surv_sig_dgree[[j]][1:10,1][surv_sig_dgree[[j]][1:10,1]%in%ref_path_mitotic]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    mitotic_gene_expr_plot[[j]] <- a
    mitotic_gene_expr_crispr[[j]] <- b
    save_pheatmap_pdf(a,width=((50/268)*(ncol(b)+8))*1.8, 
                      height =((50/268)*(nrow(b)+8))*1.8, 
                      paste('result/',cancer_name[j],'/crispr/high_dgree/mitotic/',cancer_name[j],'_crispr.pdf',sep = ''))
  }, error = function(e) {print(cancer_name[[j]])})
}








####基因的药物响应分析
##处理GDSC数据
library(readxl)
gdsc_1 <- read_excel('/database/GDSC/drug_IC50/GDSC1_fitted_dose_response_25Feb20.xlsx',sheet = 1,col_names = T)
gdsc_2 <- read_excel('/database/GDSC/drug_IC50/GDSC2_fitted_dose_response_25Feb20.xlsx',sheet = 1,col_names = T)
gdsc <- rbind(gdsc_1,gdsc_2)
gdsc <- as.data.frame(gdsc)
cell_annoation <- read_excel('/database/GDSC/drug_IC50/Cell_Lines_Details.xlsx',sheet = 1,col_names = T)
cell_annoation <- as.data.frame(cell_annoation)
cancer_cell_drug <- list()
cancer_cell_list <- list()
cancer_cell_drug_2 <- list()
for (i in 1:length(cancer_name)) {
  cancer_cell_drug_2[[i]] <- list()
  a <- cell_annoation[which(cell_annoation[,10]==cancer_name[i]),]
  b <- gdsc[gdsc[,5]%in%a[,1],]
  b <- b[b[,ncol(b)] <= -1,]####药效阈值
  cancer_cell_drug[[i]] <- b$DRUG_NAME[!duplicated(b$DRUG_NAME)]
  cancer_cell_list[[i]] <- b$CELL_LINE_NAME[!duplicated(b$CELL_LINE_NAME)]
  for (j in 1:length(b[,5][!duplicated(b[,5])])) {
    tryCatch({
      cancer_cell_drug_2[[i]][[j]] <- b$DRUG_NAME[!duplicated(b$DRUG_NAME)&b[,5]==b[,5][!duplicated(b[,5])][j]]
    }, error = function(e) {print('error')})
  }
  names(cancer_cell_drug_2[[i]]) <- b[,5][!duplicated(b[,5])]
}
names(cancer_cell_drug) <- cancer_name
names(cancer_cell_drug_2) <- cancer_name
names(cancer_cell_list) <- cancer_name
##导出有效药物名称
a <- character()
for (i in 1:15) {
  a <- c(a,cancer_cell_drug[[i]])  
}
a <- a[!duplicated(a)]
a <- tolower(a)
write.csv(a,'result/effection_drug_list.csv')
##导出细胞名称
a <- character()
for (i in 1:15) {
  a <- c(a,cancer_cell_list[[i]])  
}
a <- a[!duplicated(a)]
a <- gsub('-','',a)
a
write.csv(a,'result/effect_cell_list.csv')

##cMap数据库的整合
library(dplyr)
library(clusterProfiler)
library(stringr)
cancer_name_reaction <- read.csv('cancer_name_reaction.csv',header = F)##读取
cmap_effect_data <- read.csv('/database/cMAP/effection_data/effect_res_data.csv',header = T,row.names = 1)
geneset_id <- bitr(rownames(cmap_effect_data),fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
                   toType = c('SYMBOL'), #totype指需要转换成的ID类型
                   OrgDb='org.Hs.eg.db',drop = F)
geneset_id <- geneset_id[!duplicated(geneset_id[,2]),]
geneset_id <- geneset_id[which(!is.na(geneset_id[,2])),]
cmap_effect_data <- cmap_effect_data[rownames(cmap_effect_data) %in% geneset_id[,1],]
which(rownames(cmap_effect_data)!=geneset_id[,1])
rownames(cmap_effect_data) <- geneset_id[,2]
col_name <- read.csv('/database/cMAP/effection_data/effect_res_data.csv',header = F)[1,]
col_name <- col_name[,-1]
col_name <- as.data.frame(t(col_name))
col_name <-str_split(col_name[,1],'[:]',simplify = T)
col_name <- cbind(col_name[,1],substring(col_name[,2],1,13),col_name[,3])
col_name <-cbind(str_split(col_name[,1],'[_]',simplify = T),col_name[,2:3])
col_name <- as.data.frame(col_name)
drug_id <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_pert_info_trt_cp.csv')
drug_id[,2] <- tolower(drug_id[,2])
drug_id <- drug_id[drug_id[,1]%in%col_name[,4],]

for (i in 1:length(cancer_cell_drug)) {
  cancer_cell_drug[[i]] <- tolower(cancer_cell_drug[[i]])
  cancer_cell_drug[[i]] <- cancer_cell_drug[[i]][cancer_cell_drug[[i]]%in%drug_id[,2]]
  for (j in 1:length(cancer_cell_drug_2[[i]])) {
    cancer_cell_drug_2[[i]][[j]] <- tolower(cancer_cell_drug_2[[i]][[j]])
    cancer_cell_drug_2[[i]][[j]] <- cancer_cell_drug_2[[i]][[j]][cancer_cell_drug_2[[i]][[j]]%in%drug_id[,2]]
  }
}

for (i in 1:length(cancer_name)) {
  cancer_cell_list[[i]] <- gsub('-','',cancer_cell_list[[i]])
  cancer_cell_list[[i]] <- cancer_cell_list[[i]][cancer_cell_list[[i]]%in%col_name[,2]]
  names(cancer_cell_drug_2[[i]]) <- gsub('-','',names(cancer_cell_drug_2[[i]]))
  cancer_cell_drug_2[[i]] <- cancer_cell_drug_2[[i]][which(names(cancer_cell_drug_2[[i]])%in%col_name[,2])]
}

length(which(!duplicated(col_name[,2])))
names(cancer_cell_drug) <- cancer_name
names(cancer_cell_list) <- cancer_name
drug_id <- rbind(c('','','','','','','',''),drug_id)
drug_id[1,1:2] <- c('DMSO','dmso')
for (i in 1:nrow(drug_id)) {
  col_name[col_name[,4]%in%drug_id[i,1],6] <- drug_id[i,2]
}
for (i in 1:nrow(col_name)) {
  col_name[i,7] <- paste(col_name[i,2],col_name[i,6],col_name[i,3],col_name[i,5],col_name[i,1],sep = '_')
}
colnames(cmap_effect_data) <- col_name[,7]

drug_res_expr <- list()
for (i in 1:length(cancer_name)) {
  tryCatch({
    a <- cmap_effect_data[,col_name[,2]%in%cancer_cell_list[[i]]&col_name[,6]%in%c(cancer_cell_drug[[i]],'dmso')]
    a <- a[rownames(a)%in%surv_sig_dgree[[i]][1:10,1],]
    drug_res_expr[[i]] <- a
  }, error = function(e) {print('error')})
}
names(drug_res_expr) <- cancer_name

cell_expr_all <- list()
for (i in 1:length(cancer_name)) {
  cell_expr_all[[i]] <- list()
  if (length(cancer_cell_drug_2[[i]])>0) {
    for (j in 1:length(cancer_cell_drug_2[[i]])) {
      a <- col_name[col_name[,2]==names(cancer_cell_drug_2[[i]])[j],]
      b <- a
      gene_expr <- data.frame(1:nrow(drug_res_expr[[i]]))
      rownames(gene_expr) <- rownames(drug_res_expr[[i]])
      for (z in 1:length(c('dmso',cancer_cell_drug_2[[i]][[j]]))) {
        tryCatch({
          c <- b[b[,6]==c('dmso',cancer_cell_drug_2[[i]][[j]])[z],]
          c <- c[!duplicated(c[,7]),]
          for (x in c('6H','24H')) {
            d <- c[c[,3]==x,]
            d <- d[order(d[,5],decreasing = F),]
            for (k in 1:nrow(d)) {
              gene_expr <- cbind(gene_expr,drug_res_expr[[i]][,grep(d[k,7],colnames(drug_res_expr[[i]]))])#which(colnames(drug_res_expr[[i]])%in%d[k,7])
              ifelse(nrow(d)>0,colnames(gene_expr)[ncol(gene_expr)] <- d[k,7],0)
            }
          }
        }, error = function(e) {print('error')})
      }
      cell_expr_all[[i]][[j]] <- gene_expr
    }
  }
  else{print(0)}
}##拆分不同癌症的不同细胞系的数据
##ifelse和cat/tryCatch等不能嵌套，使用tryCatch嵌套时要使用if(){} else{},和for循环似乎也不能嵌套
names(cell_expr_all) <- cancer_name
for (i in 1:length(cancer_name)) {
  names(cell_expr_all[[i]]) <- names(cancer_cell_drug_2[[i]])
  if (length(cell_expr_all[[i]])>0) {
    for (j in 1:length(cell_expr_all[[i]])) {
      a <- as.data.frame(cell_expr_all[[i]][[j]][,-1])
      colnames(a)[ncol(a)] <- colnames(cell_expr_all[[i]][[j]])[ncol(a)+1]
      rownames(a) <- rownames(cell_expr_all[[i]][[j]])
      cell_expr_all[[i]][[j]] <- a
    }
  }
  else{print(0)}
}
for (i in 1:15) {
  for (j in 1:length(cell_expr_all[[i]])) {
    tryCatch({
      a <- as.data.frame(t(cell_expr_all[[i]][[j]]))
      b <- str_split(rownames(a),'[_]',simplify = T)
      b[,5] <- paste(b[,1],b[,2],b[,3],b[,4],sep = '_')
      a <- aggregate(a,by=list(b[,5]),mean)
      rownames(a) <- a[,1]
      a <- a[,-1]
      cell_expr_all[[i]][[j]] <- a
    }, error = function(e) {print('error')})
  }
}##合并相同处理的数据
bk = unique(c(seq(-1.5,1.5, length=100)))
for (i in 1:15) {
  for (j in 1:length(cell_expr_all[[i]])) {
    tryCatch({
      a <- pheatmap::pheatmap(cell_expr_all[[i]][[j]],breaks = bk,show_rownames = T,
                              color = colorRampPalette(c("navy", "white", "firebrick3"))(100),
                              clustering_method = "mcquitty", show_colnames = T,cluster_rows = F,cluster_cols = T)
      save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8)*2.5, 
                        height = (50/268)*(nrow(b)+8)*2, 
                        paste('result/drug/',cancer_name[i],'_',names(cell_expr_all[[i]][j]),'_0424.pdf',sep = ''))
    }, error = function(e) {print('error')})
  }
}##画热图

####cox回归分析预测基因组合
##training数据集和verification数据集的准备
expr_data_raw <- list()
for (j in 1:15) {
  expr_data_raw[[j]] <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/tumor_TCGA_',cancer_name[[j]],'_immune.csv',sep = ''),row.names = 1)
}

names(expr_data_raw) <- cancer_name
names(lifetime_all) <- cancer_name
tra_expr_data <- expr_data_raw
ver_expr_data <- expr_data_raw
for (i in 1:15) {
  tra_expr_data[[i]] <- tra_expr_data[[i]][,sample(1:ncol(tra_expr_data[[i]]),floor(ncol(tra_expr_data[[i]])*0.7))]
  ver_expr_data[[i]] <- ver_expr_data[[i]][,which(!colnames(ver_expr_data[[i]])%in%colnames(tra_expr_data[[i]]))]
}
###############3个基因的预后分析
predict_effect_3 <- list()
for (j in 1:15) {
  predict_effect_3[[j]] <- as.data.frame(t(data.frame(rep('',3))))
  gene_list <- surv_sig_dgree[[j]][1:20,1]
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_list,]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][lifetime_all[[j]][,6]%in%colnames(tra_expr_data[[j]]),c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  for (k in 1:(length(gene_list)-2)) {
    for (x in (k+1):(length(gene_list)-1)) {
      for (v in (x+1):length(gene_list)) {
        tryCatch({
          gene_set <- c(gene_list[k],gene_list[x],gene_list[v])
          predict_effect_3[[j]] <- rbind(predict_effect_3[[j]],gene_set)
          formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
          multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
          candidate_genes_for_cox2 <- gene_set
          risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                   candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                   cox_report=multi_variate_cox_2)
          cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
          high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
          high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
          high_low[high_low == FALSE] <- 'low'
          risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
          fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
          predict_effect_3[[j]][nrow(predict_effect_3[[j]]),4] <- 1-pchisq(fit_km$chisq,1)},
          error = function(e) {0})
      }
    }
  }
}
names(predict_effect_3) <- cancer_name
###############4个基因的预后分析
predict_effect_4 <- list()
for (j in 1:15) {
  predict_effect_4[[j]] <- as.data.frame(t(data.frame(rep('',4))))
  gene_list <- surv_sig_dgree[[j]][1:20,1]
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_list,]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][lifetime_all[[j]][,6]%in%colnames(tra_expr_data[[j]]),c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  for (k in 1:(length(gene_list)-3)) {
    for (x in (k+1):(length(gene_list)-2)) {
      for (v in (x+1):(length(gene_list)-1)) {
        for (e in (v+1):length(gene_list)) {
          tryCatch({
            gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e])
            predict_effect_4[[j]] <- rbind(predict_effect_4[[j]],gene_set)
            formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
            multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
            candidate_genes_for_cox2 <- gene_set
            risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                     candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                     cox_report=multi_variate_cox_2)
            cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
            high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
            high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
            high_low[high_low == FALSE] <- 'low'
            risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
            fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
            predict_effect_4[[j]][nrow(predict_effect_4[[j]]),5] <- 1-pchisq(fit_km$chisq,1)},
            error = function(e) {0})
        }
      }
    }
  }
}
names(predict_effect_4) <- cancer_name
###############5个基因的预后分析
predict_effect_5 <- list()
for (j in 1:15) {
  predict_effect_5[[j]] <- as.data.frame(t(data.frame(rep('',5))))
  gene_list <- surv_sig_dgree[[j]][1:20,1]
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_list,]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][lifetime_all[[j]][,6]%in%colnames(tra_expr_data[[j]]),c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  for (k in 1:(length(gene_list)-4)) {
    for (x in (k+1):(length(gene_list)-3)) {
      for (v in (x+1):(length(gene_list)-2)) {
        for (e in (v+1):(length(gene_list)-1)) {
          for (s in (e+1):length(gene_list)) {
            tryCatch({
              gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e],gene_list[s])
              predict_effect_5[[j]] <- rbind(predict_effect_5[[j]],gene_set)
              formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
              multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
              candidate_genes_for_cox2 <- gene_set
              risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                       candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                       cox_report=multi_variate_cox_2)
              cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
              high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
              high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
              high_low[high_low == FALSE] <- 'low'
              risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
              fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
              predict_effect_5[[j]][nrow(predict_effect_5[[j]]),6] <- 1-pchisq(fit_km$chisq,1)},
              error = function(e) {0})
          }
        }
      }
    }
  }
}
names(predict_effect_5) <- cancer_name
###############6个基因的预后分析
predict_effect_6 <- list()
for (j in 1:15) {
  predict_effect_6[[j]] <- as.data.frame(t(data.frame(rep('',6))))
  gene_list <- surv_sig_dgree[[j]][1:20,1]
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_list,]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][lifetime_all[[j]][,6]%in%colnames(tra_expr_data[[j]]),c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  for (k in 1:(length(gene_list)-5)) {
    for (x in (k+1):(length(gene_list)-4)) {
      for (v in (x+1):(length(gene_list)-3)) {
        for (e in (v+1):(length(gene_list)-2)) {
          for (s in (e+1):(length(gene_list)-1)) {
            for (w in (s+1):length(gene_list)) {
              tryCatch({
                gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e],gene_list[s],gene_list[w])
                predict_effect_6[[j]] <- rbind(predict_effect_6[[j]],gene_set)
                formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
                multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
                candidate_genes_for_cox2 <- gene_set
                risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                         candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                         cox_report=multi_variate_cox_2)
                cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
                high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
                high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
                high_low[high_low == FALSE] <- 'low'
                risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
                fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
                predict_effect_6[[j]][nrow(predict_effect_6[[j]]),7] <- 1-pchisq(fit_km$chisq,1)},
                error = function(e) {0})
            }
          }
        }
      }
    }
  }
}
names(predict_effect_6) <- cancer_name

for (i in 1:15) {
  predict_effect_4[[i]][,ncol(predict_effect_4[[i]])] <- as.numeric(predict_effect_4[[i]][,ncol(predict_effect_4[[i]])])
  predict_effect_4[[i]] <- predict_effect_4[[i]][!is.na(predict_effect_4[[i]][,ncol(predict_effect_4[[i]])]),]
  
  predict_effect_5[[i]][,ncol(predict_effect_5[[i]])] <- as.numeric(predict_effect_5[[i]][,ncol(predict_effect_5[[i]])])
  predict_effect_5[[i]] <- predict_effect_5[[i]][!is.na(predict_effect_5[[i]][,ncol(predict_effect_5[[i]])]),]
  
  predict_effect_6[[i]][,ncol(predict_effect_6[[i]])] <- as.numeric(predict_effect_6[[i]][,ncol(predict_effect_6[[i]])])
  predict_effect_6[[i]] <- predict_effect_6[[i]][!is.na(predict_effect_6[[i]][,ncol(predict_effect_6[[i]])]),]
  
  predict_effect_3[[i]][,ncol(predict_effect_3[[i]])] <- as.numeric(predict_effect_3[[i]][,ncol(predict_effect_3[[i]])])
  predict_effect_3[[i]] <- predict_effect_3[[i]][!is.na(predict_effect_3[[i]][,ncol(predict_effect_3[[i]])]),]
}



x=2
##训练集和验证集画图
gene_set_predict <- c('HSPB7','ALDH1L2','LRP1')
gene_set_predict <- predict_effect_5[[x]][which.min(predict_effect_5[[x]][,6]),1:5]
for (j in x) {
  rownames(tra_expr_data[[j]]) <- gsub(rownames(tra_expr_data[[j]]), pattern = '-', replacement = '_')
  expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_set_predict,]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][lifetime_all[[j]][,6]%in%colnames(tra_expr_data[[j]]),c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- gene_set_predict
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  
  #使用合格的基因进行多变量cox回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_list, sep = '', collapse = '+')))
  multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
  #检查PH假设是否支持方差。
  ph_hypo_multi <- cox.zph(multi_variate_cox)
  #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
  ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
  #去除ph值假设不支持的方差，进行第二次回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
  multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
  
  #check the co-linearity between samples.
  correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], method = 'pearson')
  library('GGally')
  ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], 
          axisLabels = 'show')+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())
  library('rms')
  vif <- rms::vif(multi_variate_cox_2)
  #Some people said if the square root of VIF >2, they might be co-linear.
  sqrt(vif) < 2
  
  ###
  ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
  C_index <- multi_variate_cox_2$concordance['concordance']
  if(C_index >= 0.9){
    print('High accuracy')
  }else{ 
    if(C_index < 0.9 & C_index >= 0.7){
      print('Medium accuracy')
    }else{
      print('Low accuracy')
    }
  }
  #calculate the risk score of each sample.
  candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
  risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                           candidate_genes_for_cox=candidate_genes_for_cox2, 
                                           cox_report=multi_variate_cox_2)
  ###ROC曲线
  #We evaluate 11 AUCs between 3-5 years.
  for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
  AUC_max <- max(for_multi_ROC$AUC)
  AUC_max_time <- max(for_multi_ROC$Time_point)
  #visualization of the ROC curves of multiple time points.
  pROC_tra <- ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
    geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
    geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())+
    annotate("text",x = 0.75, y = 0.15,
             label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
  
  AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
  if (AUC_max>0.5) {
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    surv_plot_tra <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                              paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))
  }else{
    AUC_max <- min(for_multi_ROC$AUC)##另一个情况
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'high'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    surv_plot_tra <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                              paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))
  }
}
pROC_tra
surv_plot_tra

for (j in x) {
  rownames(ver_expr_data[[j]]) <- gsub(rownames(ver_expr_data[[j]]), pattern = '-', replacement = '_')
  expr_data <- ver_expr_data[[j]][rownames(ver_expr_data[[j]])%in%gene_set_predict,]##改这里
  expr_data <- log2(expr_data+1)
  life_data <- lifetime_all[[j]][lifetime_all[[j]][,6]%in%colnames(ver_expr_data[[j]]),c(1,6,5,2)]
  colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
  DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
  for (i in 1:nrow(life_data)) {
    life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
  }
  survival_cancer <- life_data
  colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
  survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
  gene_list <- gene_set_predict
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  
  #使用合格的基因进行多变量cox回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_list, sep = '', collapse = '+')))
  multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
  #检查PH假设是否支持方差。
  ph_hypo_multi <- cox.zph(multi_variate_cox)
  #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
  ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
  #去除ph值假设不支持的方差，进行第二次回归。
  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
  multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
  
  #check the co-linearity between samples.
  correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], method = 'pearson')
  library('GGally')
  ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], 
          axisLabels = 'show')+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())
  library('rms')
  vif <- rms::vif(multi_variate_cox_2)
  #Some people said if the square root of VIF >2, they might be co-linear.
  sqrt(vif) < 2
  
  ###
  ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
  C_index <- multi_variate_cox_2$concordance['concordance']
  if(C_index >= 0.9){
    print('High accuracy')
  }else{ 
    if(C_index < 0.9 & C_index >= 0.7){
      print('Medium accuracy')
    }else{
      print('Low accuracy')
    }
  }
  #calculate the risk score of each sample.
  candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
  risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                           candidate_genes_for_cox=candidate_genes_for_cox2, 
                                           cox_report=multi_variate_cox_2)
  ###ROC曲线
  #We evaluate 11 AUCs between 3-5 years.
  for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
  AUC_max <- max(for_multi_ROC$AUC)
  AUC_max_time <- max(for_multi_ROC$Time_point)
  #visualization of the ROC curves of multiple time points.
  pROC_ver <- ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
    geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
    geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
    theme_bw()+
    theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
          panel.grid = element_blank())+
    annotate("text",x = 0.75, y = 0.15,
             label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
  
  AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
  if (AUC_max>0.5) {
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    surv_plot_ver <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                              paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))
  }else{
    AUC_max <- min(for_multi_ROC$AUC)##另一个情况
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'high'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    #KM_plot generation.
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    surv_plot_ver <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                              paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))
  }
}
pROC_ver
surv_plot_ver


####鉴定不同基因表达不同的细胞系
cell_lines_backgroud <- read.table('/database/GDSC/backgroud_expression/Cell_line_RMA_proc_basalExp.txt',header = T,sep = '\t',fill=T)
cell_lines_backgroud <- cell_lines_backgroud[cell_lines_backgroud[,1]!='',]
rownames(cell_lines_backgroud) <- cell_lines_backgroud[,1]
cell_lines_backgroud <- cell_lines_backgroud[,-1:-2]
cell_line_name <- read.table('/database/GDSC/backgroud_expression/E-MTAB-3610.sdrf.txt',sep = '\t',header = T)
a <- colnames(cell_lines_backgroud)
a <- str_split(a,'[.]',simplify = T)
for (i in 1:nrow(a)) {
  a[grep(pattern=a[i,2],cell_line_name[,1]),3] <- cell_line_name[i,3]
}
colnames(cell_lines_backgroud) <- a[,3]

a <- cell_line_name[,1]
a <- str_split(a,'[_]',simplify = T)
for (i in 1:nrow(a)) {
  a[grep(pattern=a[i,2],cell_line_name[,1]),3] <- cell_line_name[i,3]
}
colnames(cell_lines_backgroud) <- a[,3]
a <- a[,-1:-3]
for (i in 1:nrow(a)) {
  b <- a[i,]
  b <- b[b!='']
  b <- b[-length(b)]
  b <- paste(b,collapse = '_')
  a[i,1] <- b
}
cell_line_name[,2] <- a[,1]

write.table(cell_line_name[,2][!duplicated(cell_line_name[,2])],'gdsc_classification.txt',sep = '\t',row.names = F,quote = F)
gdsc_classification <- data.frame(1:length(cancer_name))
rownames(gdsc_classification) <- cancer_name
gdsc_classification[1,1:2] <- c('Bladder','urinary_tract')
gdsc_classification[2,1:2] <- c('Breast','breast')
gdsc_classification[3,1:2] <- c('Cervix','cervix')
gdsc_classification[4,1:2] <- c('large_intestine','Intestine')
gdsc_classification[5,1:2] <- c('kidney','Kidney')
gdsc_classification[6,1:2] <- c('Brain','central_nervous_system')
gdsc_classification[7,1] <- c('Liver')
gdsc_classification[8,1:4] <- c('lung','Lung','Lung:NSCLC','[JPC-3]_Lung')
gdsc_classification[9,1:4] <- c('lung','Lung','Lung:NSCLC','[JPC-3]_Lung')
gdsc_classification[10,1:2] <- c('Ovary','ovary')
gdsc_classification[11,1:2] <- c('Pancreas','pancreas')
gdsc_classification[12,1:2] <- c('Prostate','prostate')
gdsc_classification[13,1:2] <- c('Stomach','gastrointestinal_tract_(site_indeterminate)')
gdsc_classification[14,1:2] <- c('Thyroid','thyroid')
gdsc_classification[15,1] <- c('endometrium')
base_expr_cell <- list()
for (i in 1:length(cancer_name)) {
  a <- cell_line_name[cell_line_name[,2]%in%gdsc_classification[i,],3]
  base_expr_cell[[i]] <- cell_lines_backgroud[rownames(cell_lines_backgroud)%in%surv_sig_dgree[[i]][1:10,1],colnames(cell_lines_backgroud)%in%a]
}
names(base_expr_cell) <- cancer_name

a <- character()
for (i in 1:15) {
  a <- c(a,surv_sig_dgree[[i]][1:10,1])
}
a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
write.table(a,'sig_gene.csv',row.names = F,quote = F,sep = '\t')
a <- character()
for (i in 1:15) {
  a <- c(a,colnames(base_expr_cell[[i]]))
}
a <- gsub('-','',a)
write.csv(a,'cell_line_name.csv')
##读取显著基因的细胞系背景表达谱
cell_line_expr <- read.csv('sig_gene_data_1.csv',header = F,row.names = 1)

cell_line_expr_cp <- as.data.frame(cell_line_expr)
cell_line_expr_cp[1,] <- as.character(cell_line_expr_cp[1,]) 
colnames(cell_line_expr_cp) <- cell_line_expr_cp[1,]
cell_line_expr_cp <- cell_line_expr_cp[-1,]
sig_gene_cmap <- read.csv('sig_gene.csv',sep = '\t')
a <- colnames(cell_line_expr_cp)
a <- a[a%in%sig_gene_cmap[,2]]
for (i in 1:length(a)) {
  a[i] <- sig_gene_cmap[sig_gene_cmap[,2]%in%a[i],1]
}
colnames(cell_line_expr_cp) <- a
for (i in 1:ncol(cell_line_expr_cp)) {
  cell_line_expr_cp[,i] <- as.numeric(cell_line_expr_cp[,i])
}
##拆分细胞系与药物
library(stringr)
b <- rownames(cell_line_expr_cp)
b <- str_split(b,'[_]',simplify = T)
# a <- str_split(b[,1],'[_]',simplify = T)
# b <- cbind(a,b[,2:9])
cell_line_expr_drug <- list()
for (i in 1:15) {
  a <- colnames(base_expr_cell[[i]])
  a <- gsub('-','',a)
  cell_line_expr_drug[[i]] <- list()
  for (j in 1:length(a)) {
    cell_line_expr_drug[[i]][[j]] <- cell_line_expr_cp[b[,2]%in%a[j],colnames(cell_line_expr_cp)%in%rownames(base_expr_cell[[i]])]
    cell_line_expr_drug[[i]][[j]] <- as.data.frame(cell_line_expr_drug[[i]][[j]])
    rownames(cell_line_expr_drug[[i]][[j]]) <- rownames(cell_line_expr_cp[b[,2]%in%a[j],])
    colnames(cell_line_expr_drug[[i]][[j]]) <- colnames(cell_line_expr_cp)[colnames(cell_line_expr_cp)%in%rownames(base_expr_cell[[i]])]
  }
  names(cell_line_expr_drug[[i]]) <- a
}
names(cell_line_expr_drug) <- cancer_name
for (i in 1:15) {
  for (j in 1:length(cell_line_expr_drug[[i]])) {
    ifelse(length(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
    ifelse(nrow(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
  }
}
for (i in 1:15) {
  cell_line_expr_drug[[i]] <- cell_line_expr_drug[[i]][names(cell_line_expr_drug[[i]])!='no']
}
##提取上下0.25的细胞系
cell_line_0.25_0.75 <- list()
for (i in 1:15) {
  cell_line_0.25_0.75[[i]] <- list()
  a <- colnames(base_expr_cell[[i]])
  a <- gsub('-','',a)
  for (j in 1:nrow(base_expr_cell[[i]])) {
    tryCatch({
      cell_line_0.25_0.75[[i]][[j]] <- list()
      cell_line_0.25_0.75[[i]][[j]][[1]] <- character()
      cell_line_0.25_0.75[[i]][[j]][[2]] <- character()
      b <- quantile(base_expr_cell[[i]][j,])
      cell_line_0.25_0.75[[i]][[j]][[1]] <- a[base_expr_cell[[i]][j,]<b[,3]]
      cell_line_0.25_0.75[[i]][[j]][[2]] <- a[base_expr_cell[[i]][j,]>=b[,3]]
      names(cell_line_0.25_0.75[[i]][[j]]) <- c('0.25','0.75')
    }, error = function(e) {print('error')})
  }
  names(cell_line_0.25_0.75[[i]]) <- rownames(base_expr_cell[[i]])
}
names(cell_line_0.25_0.75) <- cancer_name

####整理数据
cell_line_0.25_0.75_cmap <- cell_line_0.25_0.75
for (i in 1:15) {
  for (j in 1:length(cell_line_0.25_0.75[[i]])) {
    for (x in 1:2) {
      cell_line_0.25_0.75_cmap[[i]][[j]][[x]] <- cell_line_expr_drug[[i]][names(cell_line_expr_drug[[i]])%in%cell_line_0.25_0.75[[i]][[j]][[x]]]
    }
  }
}

cmap_drug_name <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_pert_info.txt.gz',sep = '\t')
gdsc_drug_name <- read.csv('/database/GDSC/drug_IC50/screened_compunds_rel_8.2.csv',row.names = 1)
cmap_drug_name[,2] <- tolower(cmap_drug_name[,2])
gdsc_drug_name[,2] <- tolower(gdsc_drug_name[,2])
map_cmap_gdsc <- cmap_drug_name[,2][cmap_drug_name[,2]%in%gdsc_drug_name[,2]]
# cmap_drug_name <- cmap_drug_name[cmap_drug_name[,2]%in%map_cmap_gdsc,]

# b <- rownames(cell_line_expr_cp)
# b <- str_split(b,'[_]',simplify = T)
# b <- b[!duplicated(b[,2]),2]
# for (i in 1:length(cancer_name)) {
#   for (j in 1:length(cell_line_0.25_0.75_cmap[[i]])) {
#     for (x in 1:2) {
#       cell_line_0.25_0.75_cmap[[i]][[j]][[x]] <- cell_line_0.25_0.75_cmap[[i]][[j]][[x]][cell_line_0.25_0.75_cmap[[i]][[j]][[x]]%in%b]
#     }
#   }
# }


for (i in 1:length(cancer_name)) {
  for (j in 1:length(cell_line_0.25_0.75_cmap[[i]])) {
    for (x in 1:2) {
      tryCatch({
        for (e in 1:length(cell_line_0.25_0.75_cmap[[i]][[j]][[x]])) {
          a <- rownames(cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]])
          a <- str_split(a,'[_]',simplify = T)
          a <- as.data.frame(a)
          a[,3:5] <- as.data.frame(str_split(a[,3],'[:]',simplify = T))
          b <- str_split(a[,4],'[-]',simplify = T)
          a <- cbind(a[,1:3],b,5)
          a[,10] <- apply(a[,4:5],1,function(ve){paste(ve,collapse = '-')})
          for (s in 1:nrow(a)) {
            tryCatch({
              a[s,11] <- cmap_drug_name[cmap_drug_name[,1]%in%a[s,10],2]
            }, error = function(e) {0})
          }
          a[is.na(a[,11]),11] <- a[is.na(a[,11]),4]
          cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]] <- cbind(a[,11],cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]])
          cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]] <- aggregate(cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]][,names(cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]])%in%names(cell_line_0.25_0.75_cmap[[i]])[j]],
                                                                    by=list(cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]][,1]),
                                                                    FUN=function(data){data[which.max(abs(data))]})##取绝对值最大的值
        }
      }, error = function(e) {print('error')})
    }
  }
  print(cancer_name[i])
}

##反复运行下面两段代码3编
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_cmap[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75_cmap[[i]])) {
      if (length(cell_line_0.25_0.75_cmap[[i]][[j]])>0) {
        for (k in 1:length(cell_line_0.25_0.75_cmap[[i]][[j]])) {
          if (length(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])>0) {
            for (x in 1:length(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])) {
              if (length(cell_line_0.25_0.75_cmap[[i]][[j]][[k]][[x]])>0) {
                if (ncol(cell_line_0.25_0.75_cmap[[i]][[j]][[k]][[x]])==1) {
                  names(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])[x] <- 'no'
                }
              }else{names(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])[x] <- 'no'}
            }
          }else{names(cell_line_0.25_0.75_cmap[[i]][[j]])[k] <- 'no'}
        }
      }else{cell_line_0.25_0.75_cmap[[i]][[j]] <- list()
      names(cell_line_0.25_0.75_cmap[[i]])[j] <- 'no'}
    }
  }
}
for (i in 1:15) {
  tryCatch({
    if (length(cell_line_0.25_0.75_cmap[[i]])>0) {
      cell_line_0.25_0.75_cmap[[i]] <- cell_line_0.25_0.75_cmap[[i]][names(cell_line_0.25_0.75_cmap[[i]])!='no']
      for (j in 1:length(cell_line_0.25_0.75_cmap[[i]])) {
        if (length(cell_line_0.25_0.75_cmap[[i]][[j]])>0) {
          for (k in 1:length(cell_line_0.25_0.75_cmap[[i]][[j]])) {
            cell_line_0.25_0.75_cmap[[i]][[j]][[k]] <- cell_line_0.25_0.75_cmap[[i]][[j]][[k]][names(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])!='no']
          }
          cell_line_0.25_0.75_cmap[[i]][[j]] <- cell_line_0.25_0.75_cmap[[i]][[j]][names(cell_line_0.25_0.75_cmap[[i]][[j]])!='no']
        }
      }
    }
  }, error = function(e) {print('error')})
}

##获取DMSO和H2O处理的值
a <- rownames(cell_line_expr_cp)
a <- str_split(a,'[_]',simplify = T)
a <- as.data.frame(a)
a[,3:5] <- as.data.frame(str_split(a[,3],'[:]',simplify = T))
b <- str_split(a[,4],'[-]',simplify = T)
a <- cbind(a[,1:3],b,5)
cell_line_0.25_0.75_dmso <- cell_line_0.25_0.75_cor
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_dmso[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75_dmso[[i]])) {
      for (k in 1:length(cell_line_0.25_0.75_dmso[[i]][[j]])) {
        for (x in 1:length(cell_line_0.25_0.75_dmso[[i]][[j]][[k]])) {
          b <- cell_line_expr_cp[a[,4]%in%c('DMSO','H2O')&a[,2]%in%names(cell_line_0.25_0.75_dmso[[i]][[j]][[k]])[x],colnames(cell_line_expr_cp)%in%names(cell_line_0.25_0.75_dmso[[i]])[j]]
          b <- as.data.frame(b)
          if (nrow(b)>0) {
            b <- cbind(a[,4][a[,4]%in%c('DMSO','H2O')&a[,2]%in%names(cell_line_0.25_0.75_dmso[[i]][[j]][[k]])[x]],b)
            colnames(b) <- c('drug',names(cell_line_0.25_0.75_dmso[[i]])[j])
            b <- aggregate(b[,2],list(b[,1]),mean)
            cell_line_0.25_0.75_dmso[[i]][[j]][[k]][[x]] <- b
          }else{cell_line_0.25_0.75_dmso[[i]][[j]][[k]][[x]] <- b}
        }
      }
    }
  }
}

####计算细胞死亡与药物响应的相关性
cell_line_0.25_0.75_cor <- cell_line_0.25_0.75_cmap
gdsc_data <- gdsc[,c(5,9,19)]
gdsc_data[,1] <- gsub('-','',gdsc_data[,1])
gdsc_data[,2] <- tolower(gdsc_data[,2])
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_cor[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75_cor[[i]])) {
      for (x in 1:length(cell_line_0.25_0.75_cor[[i]][[j]])) {
        for (e in 1:length(cell_line_0.25_0.75_cor[[i]][[j]][[x]])) {
          a <- cell_line_0.25_0.75_cor[[i]][[j]][[x]][[e]]
          b <- gdsc_data[gdsc_data[,1]==names(cell_line_0.25_0.75_cor[[i]][[j]][[x]])[e]&gdsc_data[,2]%in%a[,1],]
          colnames(a)[1] <- colnames(b)[2]
          a <- merge(a,b[,2:3],by=colnames(a)[1],all=F)
          cell_line_0.25_0.75_cor[[i]][[j]][[x]][[e]] <- a
        }
      }
    } 
  }
}

cor_drug_cell_survive <- as.data.frame(t(data.frame(rep('',5))))
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_cor[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75_cor[[i]])) {
      for (k in 1:length(cell_line_0.25_0.75_cor[[i]][[j]])) {
        for (x in 1:length(cell_line_0.25_0.75_cor[[i]][[j]][[k]])) {
          if (nrow(cell_line_0.25_0.75_cor[[i]][[j]][[k]][[x]])>0) {
            tryCatch({
              b <- character()
              a <- cell_line_0.25_0.75_cor[[i]][[j]][[k]][[x]]
              ifelse(ncol(cell_line_0.25_0.75_dmso[[i]][[j]][[k]][[x]])==2,
                     a <- a[a[,2]<=mean(cell_line_0.25_0.75_dmso[[i]][[j]][[k]][[x]][,2])&a[,3]<=0,],
                     a <- a[a[,2]<=0&a[,3]<=0,])
              a <- aggregate(a[,2:3],list(a[,1]),FUN=function(data){data[which.max(abs(data))]})
              a[,3] <- as.numeric(a[,3])
              b[1] <- names(cell_line_0.25_0.75_cor)[i]
              b[2] <- names(cell_line_0.25_0.75_cor[[i]])[j]
              b[3] <- names(cell_line_0.25_0.75_cor[[i]][[j]])[k]
              b[4] <- names(cell_line_0.25_0.75_cor[[i]][[j]][[k]])[x]
              c <- cor.test(a[,2],a[,3],method = 'spearman')
              ifelse(c$p.value<0.05,b[5] <- c$estimate,b[5] <- 0)
              cor_drug_cell_survive <- rbind(cor_drug_cell_survive,b)
            }, error = function(e) {0})
          }
        }
      }
    }
  }
}
cor_drug_cell_survive <- cor_drug_cell_survive[-1,]
cor_drug_cell_survive[,5] <- as.numeric(cor_drug_cell_survive[,5])
cor_drug_cell_survive[,3][cor_drug_cell_survive[,3]==0.25] <- 'low'
cor_drug_cell_survive[,3][cor_drug_cell_survive[,3]==0.75] <- 'high'
colnames(cor_drug_cell_survive) <- c('cancer_name','gene_name','expr_level','cell_line','cor')
write.csv(cor_drug_cell_survive,'result/cor_drug_cell_survive.csv')

####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 1:15) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:11,],expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%c('GZMA','GZMB','PRF1','PRF2'),])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:10,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name


sig_gene_immune_analysis_plot <- list()
bk = unique(c(seq(-1,1, length=200)))
for (i in 1:15) {
  a <- sig_gene_immune_analysis[[i]][-11,]
  sig_gene_immune_analysis_plot[[i]] <- pheatmap::pheatmap(a,breaks = bk,show_rownames = T,
                                                           color = c(colorRampPalette(c("navy", "white"))(70),colorRampPalette(c("white"))(60),colorRampPalette(c("white","red"))(70)),
                                                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
}
names(sig_gene_immune_analysis_plot) <- cancer_name
##保存图片
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/immune',sep = ''))
  tryCatch({
    a <- sig_gene_immune_analysis_plot[[j]]
    save_pheatmap_pdf(a,width=((50/268)*(ncol(sig_gene_immune_analysis[[i]])+8))*2.3, 
                      height =((50/268)*(nrow(sig_gene_immune_analysis[[i]])+8))*1.8, 
                      paste('result/',cancer_name[j],'/immune/',cancer_name[j],'_immune.pdf',sep = ''))
  }, error = function(e) {print(cancer_name[[j]])})
}

for (i in 1:15) {
  sig_gene_immune_analysis_plot[[i]]
}

####预测预后的基因集
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}
for (i in 1:15) {
  a <- read.csv(paste('/database/TCGA/',cancer_name[[i]],'/','information/clinical.tsv',sep = ''),sep = '\t',header = T)
  a <- a[!duplicated(a[,2]),]
  a <- cbind(a$case_submitter_id,a$age_at_index,a$ajcc_pathologic_t,a$ajcc_pathologic_n,a$ajcc_pathologic_m,a$ajcc_pathologic_stage)
  ifelse(length(which(a[,2]!="'--"&a[,6]!="'--"))>0,a <- a[a[,2]!="'--"&a[,6]!="'--",],0)
  a <- as.data.frame(a)
  colnames(a) <- c(colnames(lifetime_all[[i]])[1],'age','T','N','M','Stage')
  a <- a[a$Stage!='Stage X',]
  a$age[which(a$age<=30)] <- 1
  a$age[which(a$age>30&a$age<=40)] <- 2
  a$age[which(a$age>40&a$age<=50)] <- 3
  a$age[which(a$age>50&a$age<=60)] <- 4
  a$age[which(a$age>60)] <- 5
  a$Stage[a$Stage=="'--"] <- 0
  a$Stage[a$Stage=="Stage I"] <- 1
  a$Stage[a$Stage=="Stage IA"] <- 1
  a$Stage[a$Stage=="Stage IB"] <- 1
  a$Stage[a$Stage=="Stage II"] <- 2
  a$Stage[a$Stage=="Stage IIA"] <- 2
  a$Stage[a$Stage=="Stage IIB"] <- 2
  a$Stage[a$Stage=="Stage III"] <- 3
  a$Stage[a$Stage=="Stage IIIA"] <- 3
  a$Stage[a$Stage=="Stage IIIB"] <- 3
  a$Stage[a$Stage=="Stage IIIC"] <- 3
  a$Stage[a$Stage=="Stage IV"] <- 4
  a$Stage[a$Stage=="Stage IVA"] <- 4
  a$Stage[a$Stage=="Stage IVB"] <- 4
  a$Stage[a$Stage=="Stage IVC"] <- 4
  lifetime_all[[i]] <- merge(lifetime_all[[i]],a,by=colnames(a)[1],all=F)
  lifetime_all[[i]] <-  lifetime_all[[i]][,c(1,6,5,2,8,12)]
}
names(lifetime_all) <- cancer_name

uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in colnames(risk_score_table)){
    risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
predict_effect <- list()
gene_score <- list()
single_genelist <- list()
# expr_data_raw <- list()
for (j in 1:15) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
    expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%surv_sig_dgree[[j]][,1],]
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
    expr_data <- log2(expr_data+1)
    life_data <- lifetime_all[[j]][,1:4]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    ###
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                             legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                           paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                               legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                             paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name

####结合临床分期
predict_effect_clinic <- list()
for (j in 1:15) {
  tryCatch({
    a <- c(min(predict_effect_3[[j]][,ncol(predict_effect_3[[j]])]),min(predict_effect_4[[j]][,ncol(predict_effect_4[[j]])]),min(predict_effect_5[[j]][,ncol(predict_effect_5[[j]])]))
    which.min(a)
    
    predict_effect_clinic[[j]] <- list()
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
    expr_data <- gene_score[[j]]
    expr_data[,2] <- as.numeric(expr_data[,2])
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
    expr_data[,2] <- log10(expr_data[,2]+1)
    life_data <- lifetime_all[[j]]
    expr_data <- merge(expr_data,life_data[,c(2,5:6)],by=colnames(expr_data)[1],all=F)
    rownames(expr_data) <- expr_data[,1]
    expr_data <- expr_data[,-1]
    colnames(expr_data)[1] <- 'Gene_scores'
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- expr_data
    life_data <- life_data[,-5:-6]
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    ifelse(mean(survival_cancer$Stage)!=0,gene_list <- colnames(DESeq_norm_vst_for_survival),gene_list <- colnames(DESeq_norm_vst_for_survival)[-3])
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    
    ###
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
      library('dplyr')
      risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
      for(each_sig_gene in colnames(risk_score_table)){
        risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
      }
      risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
        cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
      risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
      risk_score_table
    }
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_clinic[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect_clinic[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                    legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                  paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect_clinic[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                      legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                    paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
  }, error = function(e) {print('error')})
}
names(predict_effect_clinic) <- cancer_name
predict_effect[[15]][[1]]
predict_effect_clinic[[15]][[1]]

###############3个基因的预后分析
predict_effect_3 <- list()
for (j in 1:15) {
  tryCatch({
    predict_effect_3[[j]] <- as.data.frame(t(data.frame(rep('',3))))
    gene_list <- single_genelist[[j]]
    gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
    expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_list,]##改这里
    expr_data <- log2(expr_data+1)
    life_data <- lifetime_all[[j]][,1:4]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    for (k in 1:(length(gene_list)-2)) {
      for (x in (k+1):(length(gene_list)-1)) {
        for (v in (x+1):length(gene_list)) {
          tryCatch({
            gene_set <- c(gene_list[k],gene_list[x],gene_list[v])
            predict_effect_3[[j]] <- rbind(predict_effect_3[[j]],gene_set)
            formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
            multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
            candidate_genes_for_cox2 <- gene_set
            risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                     candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                     cox_report=multi_variate_cox_2)
            cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
            high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
            high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
            high_low[high_low == FALSE] <- 'low'
            risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
            fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
            predict_effect_3[[j]][nrow(predict_effect_3[[j]]),4] <- 1-pchisq(fit_km$chisq,1)},
            error = function(e) {0})
        }
      }
    }
    
  }, error = function(e) {print('error')})
}
names(predict_effect_3) <- cancer_name
###############4个基因的预后分析
predict_effect_4 <- list()
for (j in 1:15) {
  tryCatch({
    predict_effect_4[[j]] <- as.data.frame(t(data.frame(rep('',4))))
    gene_list <- single_genelist[[j]]
    gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
    expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_list,]##改这里
    expr_data <- log2(expr_data+1)
    life_data <- lifetime_all[[j]][,1:4]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    for (k in 1:(length(gene_list)-3)) {
      for (x in (k+1):(length(gene_list)-2)) {
        for (v in (x+1):(length(gene_list)-1)) {
          for (e in (v+1):length(gene_list)) {
            tryCatch({
              gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e])
              predict_effect_4[[j]] <- rbind(predict_effect_4[[j]],gene_set)
              formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
              multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
              candidate_genes_for_cox2 <- gene_set
              risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                       candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                       cox_report=multi_variate_cox_2)
              cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
              high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
              high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
              high_low[high_low == FALSE] <- 'low'
              risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
              fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
              predict_effect_4[[j]][nrow(predict_effect_4[[j]]),5] <- 1-pchisq(fit_km$chisq,1)},
              error = function(e) {0})
          }
        }
      }
    }
  }, error = function(e) {print('error')})
}
names(predict_effect_4) <- cancer_name
###############5个基因的预后分析
predict_effect_5 <- list()
for (j in 1:15) {
  tryCatch({
    predict_effect_5[[j]] <- as.data.frame(t(data.frame(rep('',5))))
    gene_list <- single_genelist[[j]]
    gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
    expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_list,]##改这里
    expr_data <- log2(expr_data+1)
    life_data <- lifetime_all[[j]][,1:4]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    for (k in 1:(length(gene_list)-4)) {
      for (x in (k+1):(length(gene_list)-3)) {
        for (v in (x+1):(length(gene_list)-2)) {
          for (e in (v+1):(length(gene_list)-1)) {
            for (s in (e+1):length(gene_list)) {
              tryCatch({
                gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e],gene_list[s])
                predict_effect_5[[j]] <- rbind(predict_effect_5[[j]],gene_set)
                formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
                multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
                candidate_genes_for_cox2 <- gene_set
                risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                         candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                         cox_report=multi_variate_cox_2)
                cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
                high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
                high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
                high_low[high_low == FALSE] <- 'low'
                risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
                fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
                predict_effect_5[[j]][nrow(predict_effect_5[[j]]),6] <- 1-pchisq(fit_km$chisq,1)},
                error = function(e) {0})
            }
          }
        }
      }
    }
  }, error = function(e) {print('error')})
}
names(predict_effect_5) <- cancer_name
###############6个基因的预后分析
predict_effect_6 <- list()
for (j in 1:15) {
  tryCatch({
    predict_effect_6[[j]] <- as.data.frame(t(data.frame(rep('',6))))
    gene_list <- single_genelist[[j]]
    gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
    expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%gene_list,]##改这里
    expr_data <- log2(expr_data+1)
    life_data <- lifetime_all[[j]][,1:4]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    for (k in 1:(length(gene_list)-5)) {
      for (x in (k+1):(length(gene_list)-4)) {
        for (v in (x+1):(length(gene_list)-3)) {
          for (e in (v+1):(length(gene_list)-2)) {
            for (s in (e+1):(length(gene_list)-1)) {
              for (w in (s+1):length(gene_list)) {
                tryCatch({
                  gene_set <- c(gene_list[k],gene_list[x],gene_list[v],gene_list[e],gene_list[s],gene_list[w])
                  predict_effect_6[[j]] <- rbind(predict_effect_6[[j]],gene_set)
                  formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_set, sep = '', collapse = '+')))##
                  multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
                  candidate_genes_for_cox2 <- gene_set
                  risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                                           candidate_genes_for_cox=candidate_genes_for_cox2, 
                                                           cox_report=multi_variate_cox_2)
                  cut.off <- median(risk_score_table_multi_cox2$total_risk_score)
                  high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
                  high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
                  high_low[high_low == FALSE] <- 'low'
                  risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
                  fit_km <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)
                  predict_effect_6[[j]][nrow(predict_effect_6[[j]]),7] <- 1-pchisq(fit_km$chisq,1)},
                  error = function(e) {0})
              }
            }
          }
        }
      }
    }
  }, error = function(e) {print('error')})
}
names(predict_effect_6) <- cancer_name

for (i in 1:15) {
  predict_effect_4[[i]][,ncol(predict_effect_4[[i]])] <- as.numeric(predict_effect_4[[i]][,ncol(predict_effect_4[[i]])])
  predict_effect_4[[i]] <- predict_effect_4[[i]][!is.na(predict_effect_4[[i]][,ncol(predict_effect_4[[i]])]),]
  
  predict_effect_5[[i]][,ncol(predict_effect_5[[i]])] <- as.numeric(predict_effect_5[[i]][,ncol(predict_effect_5[[i]])])
  predict_effect_5[[i]] <- predict_effect_5[[i]][!is.na(predict_effect_5[[i]][,ncol(predict_effect_5[[i]])]),]
  
  predict_effect_6[[i]][,ncol(predict_effect_6[[i]])] <- as.numeric(predict_effect_6[[i]][,ncol(predict_effect_6[[i]])])
  predict_effect_6[[i]] <- predict_effect_6[[i]][!is.na(predict_effect_6[[i]][,ncol(predict_effect_6[[i]])]),]
  
  predict_effect_3[[i]][,ncol(predict_effect_3[[i]])] <- as.numeric(predict_effect_3[[i]][,ncol(predict_effect_3[[i]])])
  predict_effect_3[[i]] <- predict_effect_3[[i]][!is.na(predict_effect_3[[i]][,ncol(predict_effect_3[[i]])]),]
}

####结合临床分期(training)
predict_effect_clinic <- list()
multi_variate_cox_clinic <- list()
multi_variate_cox_gene <- list()
for (j in 1:15) {
  tryCatch({
    a <- c(min(predict_effect_3[[j]][,ncol(predict_effect_3[[j]])]),min(predict_effect_4[[j]][,ncol(predict_effect_4[[j]])]),min(predict_effect_5[[j]][,ncol(predict_effect_5[[j]])]),min(predict_effect_6[[j]][,ncol(predict_effect_6[[j]])]))
    if (which.min(a)==1) {
      a <- as.character(predict_effect_3[[j]][which.min(min(predict_effect_3[[j]][,ncol(predict_effect_3[[j]])])),1:(ncol(predict_effect_3[[j]])-1)])
    }else{
      if (which.min(a)==2) {
        a <- as.character(predict_effect_4[[j]][which.min(min(predict_effect_4[[j]][,ncol(predict_effect_4[[j]])])),1:(ncol(predict_effect_4[[j]])-1)])
      }else{
        if (which.min(a)==3) {
          a <- as.character(predict_effect_5[[j]][which.min(min(predict_effect_5[[j]][,ncol(predict_effect_5[[j]])])),1:(ncol(predict_effect_5[[j]])-1)])
        }else{
          if (which.min(a)==4) {
            a <- as.character(predict_effect_6[[j]][which.min(min(predict_effect_6[[j]][,ncol(predict_effect_6[[j]])])),1:(ncol(predict_effect_6[[j]])-1)])
          }
        }
      }
    }
    ##计算基因模型风险评分
    tryCatch({
      predict_effect[[j]] <- list()
      # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
      expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%a,]
      # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
      expr_data <- log2(expr_data+1)
      life_data <- lifetime_all[[j]][,1:4]
      life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
      colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
      DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
      # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
      # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
      for (i in 1:nrow(life_data)) {
        life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
      }
      for (k in 3:ncol(life_data)) {
        life_data[,k] <- as.numeric(life_data[,k])
      }
      survival_cancer <- life_data
      colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
      str(survival_cancer)
      survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
      gene_list <- colnames(DESeq_norm_vst_for_survival)
      sig_gene_multi_cox <- gene_list
      ###
      #使用合格的基因进行多变量cox回归。
      formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
      multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
      
      #检查PH假设是否支持方差。
      ph_hypo_multi <- cox.zph(multi_variate_cox)
      #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
      ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
      #去除ph值假设不支持的方差，进行第二次回归。
      formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
      multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
      multi_variate_cox_gene[[j]] <- multi_variate_cox_2
      #calculate the risk score of each sample.
      candidate_genes_for_cox2 <- gene_list
      risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                               candidate_genes_for_cox=candidate_genes_for_cox2, 
                                               cox_report=multi_variate_cox_2)
      ###ROC曲线
      multi_ROC <- function(time_vector, risk_score_table){
        library('survivalROC')
        single_ROC <- function(single_time){
          for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                                 status = risk_score_table$censoring_status,
                                 marker = risk_score_table$total_risk_score,
                                 predict.time = single_time, method = 'KM')
          data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                     'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                     'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
        }
        multi_ROC_list <- lapply(time_vector, single_ROC)
        do.call(rbind, multi_ROC_list)
      }
      #We evaluate 11 AUCs between 3-5 years.
      for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
      AUC_max <- max(for_multi_ROC$AUC)
      AUC_max_time <- max(for_multi_ROC$Time_point)
      #visualization of the ROC curves of multiple time points.
      pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
        geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
        geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
        theme_bw()+
        theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
              panel.grid = element_blank())+
        annotate("text",x = 0.75, y = 0.15,
                 label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
      pROC
      predict_effect[[j]][[1]] <- pROC
      
      AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
      ifelse(AUC_max>0.5,{
        #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'low'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        library('survminer')
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                               legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                             paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
        {
          AUC_max <- min(for_multi_ROC$AUC)##另一个情况
          AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
          AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
          AUC_max_time <- AUC_max_time[length(AUC_max_time)]
          for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
          #find the optimal cutoff value within the ROC curve of the optimal time point.
          optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
          cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
          high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
          high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
          high_low[high_low == FALSE] <- 'high'
          risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
          gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
          #KM_plot generation.
          #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
          # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
          # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
          fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
          predict_effect[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                 legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                               paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
    }, error = function(e) {print('error')})
    
    
    
    
    
    
    
    predict_effect_clinic[[j]] <- list()
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
    expr_data <- gene_score[[j]]
    expr_data[,2] <- as.numeric(expr_data[,2])
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
    expr_data[,2] <- log10(expr_data[,2]+1)
    life_data <- lifetime_all[[j]]
    expr_data <- merge(expr_data,life_data[,c(2,5:6)],by=colnames(expr_data)[1],all=F)
    rownames(expr_data) <- expr_data[,1]
    expr_data <- expr_data[,-1]
    colnames(expr_data)[1] <- 'Gene_scores'
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- expr_data
    life_data <- life_data[,-5:-6]
    life_data <- life_data[life_data[,2]%in%rownames(DESeq_norm_vst_for_survival),]
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    ifelse(mean(survival_cancer$Stage)!=0,gene_list <- colnames(DESeq_norm_vst_for_survival),gene_list <- colnames(DESeq_norm_vst_for_survival)[-3])
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_list, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_clinic[[j]] <- multi_variate_cox_2
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    
    ###
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
      library('dplyr')
      risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
      for(each_sig_gene in colnames(risk_score_table)){
        risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
      }
      risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
        cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
      risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
      risk_score_table
    }
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_clinic[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect_clinic[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                    legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                  paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect_clinic[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                      legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                    paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
  }, error = function(e) {print('error')})
}
names(multi_variate_cox_clinic) <- cancer_name
names(multi_variate_cox_gene) <- cancer_name
names(predict_effect_clinic) <- cancer_name
predict_effect[[j]][[1]]
predict_effect_clinic[[j]][[1]]
predict_effect[[j]][[2]]
predict_effect_clinic[[j]][[2]]
####(veridication)
predict_effect_clinic_ver <- list()
predict_effect_ver <- list()
for (j in 1:15) {
  tryCatch({
    ##计算基因模型风险评分
    tryCatch({
      predict_effect_ver[[j]] <- list()
      gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
      expr_data <- ver_expr_data[[j]][rownames(ver_expr_data[[j]])%in%gene_list,]
      expr_data <- log2(expr_data+1)
      life_data <- lifetime_all[[j]][,1:4]
      life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
      colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
      DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
      # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
      # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
      for (i in 1:nrow(life_data)) {
        life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
      }
      for (k in 3:ncol(life_data)) {
        life_data[,k] <- as.numeric(life_data[,k])
      }
      survival_cancer <- life_data
      ###
      #使用合格的基因进行多变量cox回归。
      multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
      
      #calculate the risk score of each sample.
      candidate_genes_for_cox2 <- gene_list
      risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                               candidate_genes_for_cox=candidate_genes_for_cox2, 
                                               cox_report=multi_variate_cox_2)
      ###ROC曲线
      multi_ROC <- function(time_vector, risk_score_table){
        library('survivalROC')
        single_ROC <- function(single_time){
          for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                                 status = risk_score_table$censoring_status,
                                 marker = risk_score_table$total_risk_score,
                                 predict.time = single_time, method = 'KM')
          data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                     'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                     'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
        }
        multi_ROC_list <- lapply(time_vector, single_ROC)
        do.call(rbind, multi_ROC_list)
      }
      #We evaluate 11 AUCs between 3-5 years.
      for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
      AUC_max <- max(for_multi_ROC$AUC)
      AUC_max_time <- max(for_multi_ROC$Time_point)
      #visualization of the ROC curves of multiple time points.
      pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
        geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
        geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
        theme_bw()+
        theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
              panel.grid = element_blank())+
        annotate("text",x = 0.75, y = 0.15,
                 label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
      pROC
      predict_effect_ver[[j]][[1]] <- pROC
      
      AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
      ifelse(AUC_max>0.5,{
        #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'low'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        library('survminer')
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                   legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                 paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
        {
          AUC_max <- min(for_multi_ROC$AUC)##另一个情况
          AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
          AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
          AUC_max_time <- AUC_max_time[length(AUC_max_time)]
          for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
          #find the optimal cutoff value within the ROC curve of the optimal time point.
          optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
          cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
          high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
          high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
          high_low[high_low == FALSE] <- 'high'
          risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
          gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
          #KM_plot generation.
          #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
          # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
          # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
          fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
          predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                     legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                   paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
    }, error = function(e) {print('error')})
    
    
    
    
    
    
    
    predict_effect_clinic_ver[[j]] <- list()
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
    expr_data <- gene_score[[j]]
    expr_data[,2] <- as.numeric(expr_data[,2])
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
    expr_data[,2] <- log10(expr_data[,2]+1)
    life_data <- lifetime_all[[j]]
    expr_data <- merge(expr_data,life_data[,c(2,5:6)],by=colnames(expr_data)[1],all=F)
    rownames(expr_data) <- expr_data[,1]
    expr_data <- expr_data[,-1]
    colnames(expr_data)[1] <- 'Gene_scores'
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- expr_data
    life_data <- life_data[,-5:-6]
    life_data <- life_data[life_data[,2]%in%rownames(DESeq_norm_vst_for_survival),]
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- rownames(as.data.frame(multi_variate_cox_clinic[[j]]$coefficients))
    ###
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_clinic[[j]]
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,gene_list], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,gene_list], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    
    ###
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
      library('dplyr')
      risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
      for(each_sig_gene in colnames(risk_score_table)){
        risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
      }
      risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
        cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
      risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
      risk_score_table
    }
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_clinic_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect_clinic_ver[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                        legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                      paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect_clinic_ver[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                          legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                        paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
  }, error = function(e) {print('error')})
}
names(predict_effect_clinic_ver) <- cancer_name
names(predict_effect_ver) <- cancer_name

predict_effect_ver[[j]][[1]]
predict_effect_clinic_ver[[j]][[1]]
predict_effect_ver[[j]][[2]]
predict_effect_clinic_ver[[j]][[2]]

####预后预测基因集的筛选（标准代码）
####预测预后的基因集
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据
library('DESeq2')
library('survival')
library('survminer')
library('dplyr')
library('glmnet')
library('ggplot2')
library('GGally')
library('rms')
library('survivalROC')
library('plotROC')
for (i in 1:15) {
  a <- read.csv(paste('/database/TCGA/',cancer_name[[i]],'/','information/clinical.tsv',sep = ''),sep = '\t',header = T)
  a <- a[!duplicated(a[,2]),]
  a <- cbind(a$case_submitter_id,a$age_at_index,a$ajcc_pathologic_t,a$ajcc_pathologic_n,a$ajcc_pathologic_m,a$ajcc_pathologic_stage)
  ifelse(length(which(a[,2]!="'--"&a[,6]!="'--"))>0,a <- a[a[,2]!="'--"&a[,6]!="'--",],0)
  a <- as.data.frame(a)
  colnames(a) <- c(colnames(lifetime_all[[i]])[1],'age','T','N','M','Stage')
  a <- a[a$Stage!='Stage X',]
  a$age[which(a$age<=30)] <- 1
  a$age[which(a$age>30&a$age<=40)] <- 2
  a$age[which(a$age>40&a$age<=50)] <- 3
  a$age[which(a$age>50&a$age<=60)] <- 4
  a$age[which(a$age>60)] <- 5
  a$Stage[a$Stage=="'--"] <- 0
  a$Stage[a$Stage=="Stage I"] <- 1
  a$Stage[a$Stage=="Stage IA"] <- 1
  a$Stage[a$Stage=="Stage IB"] <- 1
  a$Stage[a$Stage=="Stage II"] <- 2
  a$Stage[a$Stage=="Stage IIA"] <- 2
  a$Stage[a$Stage=="Stage IIB"] <- 2
  a$Stage[a$Stage=="Stage III"] <- 3
  a$Stage[a$Stage=="Stage IIIA"] <- 3
  a$Stage[a$Stage=="Stage IIIB"] <- 3
  a$Stage[a$Stage=="Stage IIIC"] <- 3
  a$Stage[a$Stage=="Stage IV"] <- 4
  a$Stage[a$Stage=="Stage IVA"] <- 4
  a$Stage[a$Stage=="Stage IVB"] <- 4
  a$Stage[a$Stage=="Stage IVC"] <- 4
  lifetime_all[[i]] <- merge(lifetime_all[[i]],a,by=colnames(a)[1],all=F)
  lifetime_all[[i]] <-  lifetime_all[[i]][,c(1,6,5,2,8,12)]
}##处理临床与生存数据
names(lifetime_all) <- cancer_name
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in colnames(risk_score_table)){
    risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
predict_effect <- list()
gene_score <- list()
single_genelist <- list()
for (j in 1:15) {
  tryCatch({
    predict_effect[[j]] <- list()
    expr_data <- tra_expr_data[[j]][rownames(tra_expr_data[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime_all[[j]][,1:4]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    ###
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                             legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                           paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                               legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                             paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name

##结合临床分期
predict_effect_clinic <- list()
for (j in 1:15) {
  tryCatch({
    predict_effect_clinic[[j]] <- list()
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
    expr_data <- gene_score[[j]]
    expr_data[,2] <- as.numeric(expr_data[,2])
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
    expr_data[,2] <- log10(expr_data[,2]+1)
    life_data <- lifetime_all[[j]]
    expr_data <- merge(expr_data,life_data[,c(2,5:6)],by=colnames(expr_data)[1],all=F)
    rownames(expr_data) <- expr_data[,1]
    expr_data <- expr_data[,-1]
    colnames(expr_data)[1] <- 'Gene_scores'
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- expr_data
    life_data <- life_data[,-5:-6]
    life_data <- life_data[life_data[,2]%in%rownames(DESeq_norm_vst_for_survival),]
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    ifelse(mean(survival_cancer$Stage)!=0,gene_list <- colnames(DESeq_norm_vst_for_survival),gene_list <- colnames(DESeq_norm_vst_for_survival)[-3])
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(gene_list, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_clinic[[j]] <- multi_variate_cox_2
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    
    ###
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
      library('dplyr')
      risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
      for(each_sig_gene in colnames(risk_score_table)){
        risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
      }
      risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
        cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
      risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
      risk_score_table
    }
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_clinic[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect_clinic[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect_clinic[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                    legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                  paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect_clinic[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect_clinic[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                      legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                    paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
  }, error = function(e) {print('error')})
}
names(predict_effect_clinic) <- cancer_name
predict_effect[[j]][[1]]
predict_effect_clinic[[j]][[1]]
predict_effect[[j]][[2]]
predict_effect_clinic[[j]][[2]]
multi_variate_cox_clinic[[j]]
multi_variate_cox_gene[[j]]

##(veridication)
predict_effect_clinic_ver <- list()
predict_effect_ver <- list()
for (j in 1:15) {
  tryCatch({
    ##计算基因模型风险评分
    tryCatch({
      predict_effect_ver[[j]] <- list()
      gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
      expr_data <- ver_expr_data[[j]]
      rownames(expr_data) <- gsub('-','_',rownames(expr_data))
      expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
      expr_data <- log2(expr_data+1)
      life_data <- lifetime_all[[j]][,1:4]
      life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
      colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
      DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
      # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
      # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
      for (i in 1:nrow(life_data)) {
        life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
      }
      for (k in 3:ncol(life_data)) {
        life_data[,k] <- as.numeric(life_data[,k])
      }
      survival_cancer <- life_data
      ###
      #使用合格的基因进行多变量cox回归。
      multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
      
      #calculate the risk score of each sample.
      candidate_genes_for_cox2 <- gene_list
      risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                               candidate_genes_for_cox=candidate_genes_for_cox2, 
                                               cox_report=multi_variate_cox_2)
      ###ROC曲线
      multi_ROC <- function(time_vector, risk_score_table){
        library('survivalROC')
        single_ROC <- function(single_time){
          for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                                 status = risk_score_table$censoring_status,
                                 marker = risk_score_table$total_risk_score,
                                 predict.time = single_time, method = 'KM')
          data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                     'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                     'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
        }
        multi_ROC_list <- lapply(time_vector, single_ROC)
        do.call(rbind, multi_ROC_list)
      }
      #We evaluate 11 AUCs between 3-5 years.
      for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
      AUC_max <- max(for_multi_ROC$AUC)
      AUC_max_time <- max(for_multi_ROC$Time_point)
      #visualization of the ROC curves of multiple time points.
      pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
        geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
        geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
        theme_bw()+
        theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
              panel.grid = element_blank())+
        annotate("text",x = 0.75, y = 0.15,
                 label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
      pROC
      predict_effect_ver[[j]][[1]] <- pROC
      
      AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
      ifelse(AUC_max>0.5,{
        #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'low'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        library('survminer')
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                   legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                 paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
        {
          AUC_max <- min(for_multi_ROC$AUC)##另一个情况
          AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
          AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
          AUC_max_time <- AUC_max_time[length(AUC_max_time)]
          for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
          #find the optimal cutoff value within the ROC curve of the optimal time point.
          optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
          cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
          high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
          high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
          high_low[high_low == FALSE] <- 'high'
          risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
          predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
          gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
          #KM_plot generation.
          #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
          # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
          # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
          fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
          predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                     legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                   paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
    }, error = function(e) {print('error')})
    predict_effect_clinic_ver[[j]] <- list()
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%surv_sig_dgree[[j]][surv_sig_dgree[[j]][,2]>10,1],]
    expr_data <- gene_score[[j]]
    expr_data[,2] <- as.numeric(expr_data[,2])
    # expr_data <- expr_data_raw[[j]][rownames(expr_data_raw[[j]])%in%c(surv_sig_inter[[j]][surv_sig_inter[[j]][,1]%in%surv_sig_dgree[[j]][1,1],3]),]
    expr_data[,2] <- log10(expr_data[,2]+1)
    life_data <- lifetime_all[[j]]
    expr_data <- merge(expr_data,life_data[,c(2,5:6)],by=colnames(expr_data)[1],all=F)
    rownames(expr_data) <- expr_data[,1]
    expr_data <- expr_data[,-1]
    colnames(expr_data)[1] <- 'Gene_scores'
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- expr_data
    life_data <- life_data[,-5:-6]
    life_data <- life_data[life_data[,2]%in%rownames(DESeq_norm_vst_for_survival),]
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- rownames(as.data.frame(multi_variate_cox_clinic[[j]]$coefficients))
    ###
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_clinic[[j]]
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,gene_list], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,gene_list], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    
    ###
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
      library('dplyr')
      risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
      for(each_sig_gene in colnames(risk_score_table)){
        risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
      }
      risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
        cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
      risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
      risk_score_table
    }
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_clinic_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect_clinic_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect_clinic_ver[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                        legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                      paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect_clinic_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect_clinic_ver[[j]][[2]] <- ggsurvplot(fit_km,conf.int = F,pval = T,legend.title="total risk score",
                                                          legend.labs=c(paste0('>',as.character(round(cut.off,2))),
                                                                        paste0('<=',as.character(round(cut.off,2)))),palette = c('red','blue'))})
  }, error = function(e) {print('error')})
}
names(predict_effect_clinic_ver) <- cancer_name
names(predict_effect_ver) <- cancer_name

predict_effect_ver[[j]][[1]]
predict_effect_clinic_ver[[j]][[1]]
predict_effect_ver[[j]][[2]]
predict_effect_clinic_ver[[j]][[2]]
library(ggplot2)
for (i in 1:15) {
  tryCatch({
    dir.create(paste('result/',cancer_name[i],'/predict_geneset',sep = ''))
    ggsave(paste('result/',cancer_name[i],'/predict_geneset/',cancer_name[i],'_tra_ROC','.pdf',sep = ''),
           plot = predict_effect[[i]][[1]],width = 10,height = 10)
    pdf(paste('result/',cancer_name[i],'/predict_geneset/',cancer_name[i],'_tra_KM','.pdf',sep = ''))
    print(predict_effect[[i]][[2]],newpage = FALSE)
    dev.off()
    ggsave(paste('result/',cancer_name[i],'/predict_geneset/',cancer_name[i],'_ver_ROC','.pdf',sep = ''),
           plot = predict_effect_ver[[i]][[1]],width = 10,height = 10)
    pdf(paste('result/',cancer_name[i],'/predict_geneset/',cancer_name[i],'_ver_KM','.pdf',sep = ''))
    print(predict_effect_ver[[i]][[2]],newpage = FALSE)
    dev.off()
  }, error = function(e) {print('error')})
}
plot(1:9)
totol_effect <- data.frame('','','','','','','','')
for (i in 1:15) {
  tryCatch({
    totol_effect[i,1] <- max(predict_effect[[i]][[1]][['data']][,5])
    totol_effect[i,2] <- 1-pchisq(predict_effect[[i]][[3]]$chisq,1)
    totol_effect[i,3] <- max(predict_effect_clinic[[i]][[1]][['data']][,5])
    totol_effect[i,4] <- 1-pchisq(predict_effect_clinic[[i]][[3]]$chisq,1)
    totol_effect[i,5] <- max(predict_effect_ver[[i]][[1]][['data']][,5])
    totol_effect[i,6] <- 1-pchisq(predict_effect_ver[[i]][[3]]$chisq,1)
    totol_effect[i,7] <- max(predict_effect_clinic_ver[[i]][[1]][['data']][,5])
    totol_effect[i,8] <- 1-pchisq(predict_effect_clinic_ver[[i]][[3]]$chisq,1)
  }, error = function(e) {print('error')
  })
}
rownames(totol_effect) <- cancer_name
colnames(totol_effect) <- c('gene_tra_AUC','gene_tra_P','clinic_tra_AUC','clinic_tra_P','gene_ver_AUC','gene_ver_P','clinic_ver_AUC','clinic_ver_P')
write.csv(totol_effect,'result/total_predict_effection.csv')
predict_effect_clinic_ver[[8]][[2]]
i=1
cancer_name
####screen target drug
##读取cMAP数据库中对应GDSC和显著基因(比对之后显著基因只剩93个)的数据
cell_line_expr <- read.csv('sig_gene_data.csv',header = F,row.names = 1)
cell_line_expr_cp <- as.data.frame(cell_line_expr)
cell_line_expr_cp[1,] <- as.character(cell_line_expr_cp[1,]) 
colnames(cell_line_expr_cp) <- cell_line_expr_cp[1,]
cell_line_expr_cp <- cell_line_expr_cp[-1,]

##读取显著基因列表
sig_gene_cmap <- read.csv('sig_gene.csv',sep = '\t')
a <- colnames(cell_line_expr_cp)
a <- a[a%in%sig_gene_cmap[,2]]
for (i in 1:length(a)) {
  a[i] <- sig_gene_cmap[sig_gene_cmap[,2]%in%a[i],1]
}
colnames(cell_line_expr_cp) <- a
for (i in 1:ncol(cell_line_expr_cp)) {
  cell_line_expr_cp[,i] <- as.numeric(cell_line_expr_cp[,i])
}

##拆分细胞系与药物,能将细胞系拆分成每种癌症对应
library(stringr)
b <- rownames(cell_line_expr_cp)
b <- str_split(b,'[_]',simplify = T)
# a <- str_split(b[,1],'[_]',simplify = T)
# b <- cbind(a,b[,2:9])
cell_line_expr_drug <- list()
for (i in 1:15) {
  a <- colnames(base_expr_cell[[i]])
  a <- gsub('-','',a)
  cell_line_expr_drug[[i]] <- list()
  for (j in 1:length(a)) {
    cell_line_expr_drug[[i]][[j]] <- cell_line_expr_cp[b[,2]%in%a[j],colnames(cell_line_expr_cp)%in%rownames(base_expr_cell[[i]])]
    cell_line_expr_drug[[i]][[j]] <- as.data.frame(cell_line_expr_drug[[i]][[j]])
    rownames(cell_line_expr_drug[[i]][[j]]) <- rownames(cell_line_expr_cp[b[,2]%in%a[j],])
    colnames(cell_line_expr_drug[[i]][[j]]) <- colnames(cell_line_expr_cp)[colnames(cell_line_expr_cp)%in%rownames(base_expr_cell[[i]])]
  }
  names(cell_line_expr_drug[[i]]) <- a
}
names(cell_line_expr_drug) <- cancer_name
for (i in 1:15) {
  for (j in 1:length(cell_line_expr_drug[[i]])) {
    ifelse(length(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
    ifelse(nrow(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
  }
}
for (i in 1:15) {
  cell_line_expr_drug[[i]] <- cell_line_expr_drug[[i]][names(cell_line_expr_drug[[i]])!='no']
}

##药物筛选
LUAD_cmap <- cell_line_expr_drug[[8]]
LUAD_cmap_drug <- list()
drug_id <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_inst_info.txt.gz',sep = '\t')
# c <- gdsc[,c(5,9,19)]
# c[,1] <- gsub('-','',c[,1])
# c[,2] <- tolower(c[,2])
# for (i in 1:length(LUAD_cmap)) {
#   # LUAD_cmap[[i]] <- LUAD_cmap[[i]][LUAD_cmap[[i]][,1]<0&LUAD_cmap[[i]][,2]<0,]
#   a <- rownames(LUAD_cmap[[i]])
#   a <- str_split(a,'[:]',simplify = T)
#   a <- cbind(a[,1],substring(a[,2],1,13),a[,3])
#   a <- cbind(str_split(a[,1],'[_]',simplify = T),a[,2:3])
#   a <- as.data.frame(a)
#   b <- drug_id[drug_id[,4]%in%a[,4],]
#   b <- b[!duplicated(b[,4]),]
#   LUAD_cmap[[i]] <- LUAD_cmap[[i]][a[,4]%in%b[,4],]
#   a <- a[a[,4]%in%b[,4],]
#   for (j in 1:nrow(a)) {
#     a[j,6] <- b[b[,4]%in%a[j,4],5]
#   }
#   a[,6] <- tolower(a[,6])
#   LUAD_cmap[[i]] <- cbind(a[,6],LUAD_cmap[[i]])
#   d <- c
#   d <- d[d[,1]%in%a[,2],]
#   if (nrow(d)!=0) {
#     for (j in 1:nrow(LUAD_cmap[[i]])) {
#       if (LUAD_cmap[[i]][j,1]%in%d[,2]) {
#         LUAD_cmap[[i]][j,4:(3+length(which(d[,2]%in%LUAD_cmap[[i]][j,1])))] <- d[which(d[,2]%in%LUAD_cmap[[i]][j,1]),3]
#       }
#     }
#   }
# }
library(stringr)
b <- rownames(cell_line_expr_cp)
b <- str_split(b,'[_]',simplify = T)
# a <- str_split(b[,1],'[_]',simplify = T)
# b <- cbind(a,b[,2:9])
cell_line_expr_drug <- list()
for (i in 1:15) {
  a <- colnames(base_expr_cell[[i]])
  a <- gsub('-','',a)
  cell_line_expr_drug[[i]] <- list()
  for (j in 1:length(a)) {
    cell_line_expr_drug[[i]][[j]] <- cell_line_expr_cp[b[,2]%in%a[j],colnames(cell_line_expr_cp)%in%rownames(base_expr_cell[[i]])]
    cell_line_expr_drug[[i]][[j]] <- as.data.frame(cell_line_expr_drug[[i]][[j]])
    rownames(cell_line_expr_drug[[i]][[j]]) <- rownames(cell_line_expr_cp[b[,2]%in%a[j],])
    colnames(cell_line_expr_drug[[i]][[j]]) <- colnames(cell_line_expr_cp)[colnames(cell_line_expr_cp)%in%rownames(base_expr_cell[[i]])]
  }
  names(cell_line_expr_drug[[i]]) <- a
}
names(cell_line_expr_drug) <- cancer_name
for (i in 1:15) {
  for (j in 1:length(cell_line_expr_drug[[i]])) {
    ifelse(length(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
    ifelse(nrow(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
  }
}
for (i in 1:15) {
  cell_line_expr_drug[[i]] <- cell_line_expr_drug[[i]][names(cell_line_expr_drug[[i]])!='no']
}
c <- gdsc[,c(5,9,19)]
c[,1] <- gsub('-','',c[,1])
c[,2] <- tolower(c[,2])
for (i in 1:15) {
  if (length(cell_line_expr_drug[[i]])>0) {
    for (j in 1:length(cell_line_expr_drug[[i]])) {
      row_name <- rownames(cell_line_expr_drug[[i]][[j]])
      a <- row_name
      a <- str_split(a,'[:]',simplify = T)
      a <- cbind(a[,1],substring(a[,2],1,13),a[,3])
      a <- cbind(str_split(a[,1],'[_]',simplify = T),a[,2:3])
      a <- as.data.frame(a)
      b <- drug_id[drug_id[,4]%in%a[,4],]
      b <- b[!duplicated(b[,4]),]
      # cell_line_expr_drug[[i]][[j]] <- cell_line_expr_drug[[i]][[j]][a[,4]%in%b[,4],]
      # a <- a[a[,4]%in%b[,4],]
      for (k in 1:nrow(a)) {
        if (length(which(b[,4]%in%a[k,4]))>=1) {
          a[k,6] <- b[b[,4]%in%a[k,4],5]
        }
      }
      a[,6] <- tolower(a[,6])
      cell_line_expr_drug[[i]][[j]] <- as.data.frame(cbind(a[,6],cell_line_expr_drug[[i]][[j]]))
      
      d <- c
      d <- d[d[,1]%in%a[,2],]
      n <- ncol(cell_line_expr_drug[[i]][[j]])
      if (nrow(d)!=0) {
        for (k in 1:nrow(cell_line_expr_drug[[i]][[j]])) {
          if (cell_line_expr_drug[[i]][[j]][k,1]%in%d[,2]) {
            cell_line_expr_drug[[i]][[j]][k,(n+1):(n+length(which(d[,2]%in%cell_line_expr_drug[[i]][[j]][k,1])))] <- d[which(d[,2]%in%cell_line_expr_drug[[i]][[j]][k,1]),3]
          }
        }
        rownames(cell_line_expr_drug[[i]][[j]]) <- row_name
      }
    }
  }
}
##绘制韦恩图
luad <- cell_line_expr_drug[[8]][[7]]
luad_dmso <- cell_line_0.25_0.75_dmso[[8]][[2]][[2]][[5]]
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
##BUB1/NCAPG
luad_dmso <- cell_line_0.25_0.75_dmso[[8]][[2]][[2]][[5]]
cMAP_BUB1_A549 <- luad[luad$BUB1<luad_dmso[1,2],]
cMAP_BUB1_A549 <- cMAP_BUB1_A549[!is.na(cMAP_BUB1_A549[,1]),]
cMAP_BUB1_A549 <- cMAP_BUB1_A549[!duplicated(cMAP_BUB1_A549[,1]),1]
luad_dmso <- cell_line_0.25_0.75_dmso[[8]][[1]][[2]][[5]]
cMAP_NCAPG_A549 <- luad[luad$NCAPG<luad_dmso[1,2],]
cMAP_NCAPG_A549 <- cMAP_NCAPG_A549[!is.na(cMAP_NCAPG_A549[,1]),]
cMAP_NCAPG_A549 <- cMAP_NCAPG_A549[!duplicated(cMAP_NCAPG_A549[,1]),1]
gdsc_A549 <- tolower(gdsc_A549[,3])

library(VennDiagram)
library(RColorBrewer)
venn.plot <- venn.diagram(x=list(cMAP_BUB1_A549=cMAP_BUB1_A549, cMAP_NCAPG_A549=cMAP_NCAPG_A549, GDSC_A549=gdsc_A549), 
                          height = 1500, width = 1500, resolution =600, 
                          imagetype="tiff", col="white", 
                          fill=c(colors()[616], colors()[38], colors()[468]), 
                          alpha=c(0.6, 0.6, 0.6), #颜色的深浅
                          lwd=c(1, 1, 1), cex=0.45, cat.dist=c(-0.07, -0.07, -0.05), 
                          fontfamily = "serif", fontface = "bold",
                          cat.pos=c(280, 80, 180), #位置
                          cat.cex=0.45)
pdf("venn.pdf")
grid.draw(venn.plot)
dev.off()
?venn.diagram
luad_overlap <- luad
luad_dmso <- cell_line_0.25_0.75_dmso[[8]][[2]][[2]][[5]]
luad_overlap <- luad_overlap[luad_overlap$BUB1<luad_dmso[1,2],]
luad_dmso <- cell_line_0.25_0.75_dmso[[8]][[1]][[2]][[5]]
luad_overlap <- luad_overlap[luad_overlap$NCAPG<luad_dmso[1,2],]
luad_overlap <- luad_overlap[!is.na(luad_overlap[,1]),]
luad_overlap <- luad_overlap[!is.na(luad_overlap[,4]),]
func_A=function(x) {x[which.min(x[,2]+x[,3]),]}
a <- luad_overlap[,1][!duplicated(luad_overlap[,1])]
c <- data.frame('','','','','','')
for (i in 1:length(a)) {
  b <- luad_overlap[luad_overlap[,1]==a[i],]
  c[i,] <- b[which.min(b[,2]+b[,3]),]
}
for (i in 2:ncol(c)) {
  c[,i] <- as.numeric(c[,i])
}
colnames(c) <- colnames(luad_overlap)
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549[,3] <- tolower(gdsc_A549[,3])
gdsc_A549 <- gdsc_A549[!duplicated(gdsc_A549[,3]),]
colnames(c)[1] <- colnames(gdsc_A549)[3]
gdsc_A549 <- merge(gdsc_A549[,3:5],c,by=colnames(gdsc_A549)[3],all=F)

write.csv(c,'result/luad_drug_screen.csv')
write.csv(gdsc_A549,'result/luad_drug_info.csv')
predict_effect_clinic[[2]][[1]]

####画图
##折线图
# library(tidyverse)
# library(ggplot2)
# library(cowplot)
# library(dplyr)
# a <- surv_data[[1]][[1]]
# colnames(a) <- seq(40,400,40)
# a$Gene <- rownames(a)
# a <- pivot_longer(data = a,cols = 1:(dim(a)[2]-1),
#                                  names_to = "Sample_size",values_to = "sig_rate")
# plot_data <- test_data_longer %>% 
#   separate(col = Type, sep = "_",into = c("tissue","time"))
# plot_data <- a
# str_sort(unique(plot_data$Sample_size),numeric = T)
# plot_data$Sample_size <- factor(plot_data$Sample_size, levels = str_sort(unique(plot_data$Sample_size),numeric = T))
# ggplot(data = plot_data, aes(x = Sample_size, y = sig_rate,
#                              group = Gene)) +
#   geom_line(aes(color = Gene),linetype = 2) +
#   # geom_point(aes(fill = tissue),shape = 21,size = 5) +
#   theme_bw() +
#   ggtitle(label = unique(plot_data$Gene))

##双柱状图
##获取批量生存分析的每个基因标签
library(survival)
library(survminer)
HR_all <- list()
surv_p_all <- list()
for (x in 1:15) {
  HR_all[[x]] <- data.frame()
  surv_p_all[[x]] <- data.frame()
  b <- lifetime_all[[x]][lifetime_all[[x]][,2] %in% colnames(expression[[x]]),]
  for (j in 1:nrow(expression[[x]])) {
    tryCatch({a <- expression[[x]][j,]
    b[b[,2]%in%colnames(expression[[x]])[which(a <= median(as.numeric(a)))],7] <- 'low'
    b[b[,2]%in%colnames(expression[[x]])[which(a > median(as.numeric(a)))],7] <- 'high'
    c <- survdiff(Surv(b[,3],as.numeric(b[,4]))~b[,7], data=b)
    surv_p_all[[x]][j,1] <- 1-pchisq(c$chisq,1)
    HR_all[[x]][j,1] <- (c$obs[2]/c$exp[2])/(c$obs[1]/c$exp[1])},warning = function(w){
      print('warning')}, error = function(e){surv_p_all[[x]][j,1] <- 1
      HR_all[[x]][j,1] <- 1
      print('error')})
  }
  rownames(surv_p_all[[x]]) <- rownames(expression[[x]])
  rownames(HR_all[[x]]) <- rownames(expression[[x]])
}
names(surv_p_all) <- cancer_name
names(HR_all) <- cancer_name
for (i in 1:15) {
  surv_p_all[[i]][is.na(surv_p_all[[i]][,1]),1] <- 1
  surv_p_all[[i]][surv_p_all[[i]][,1]<0.05,2] <- 'sig'
  surv_p_all[[i]][surv_p_all[[i]][,1]>=0.05,2] <- 'non-sig'
}

##画柱状图
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
A <- surv_data[[8]][[1]]
A$group <- surv_p_all[[8]][,2]
A$Gene <- rownames(A)
A <- pivot_longer(data = A,cols = 1:(dim(A)[2]-2),
                  names_to = "Type",values_to = "count")
str_sort(unique(A$Type),numeric = T)
A$Type <- factor(A$Type, levels = str_sort(unique(A$Type),numeric = T))
A$Type <- as.factor(A$Type)
A$Type <- fct_inorder(A$Type)
A$group <- as.factor(A$group)
A$group <- fct_inorder(A$group)

ggplot(A, aes(fill=group, y=count, x=Type))+
  geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
  theme_classic(base_size = 12)+
  theme(legend.direction = "horizontal", legend.position = "top")+
  labs(title = "", y="Surv-sig rate ", x = "Sample Size")+
  stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
               width = 0.5,position = position_dodge(1))+
  scale_y_continuous(limits = c(0,1),expand = c(0,0))+
  theme(axis.text.x = element_text(size = 12))+
  theme(axis.text.y = element_text(size = 12))+
  theme(axis.title = element_text(size = 14))

##画折线图
sig_gene_num <- data.frame()
for (i in 1:15) {
  for (j in 1:10) {
    sig_gene_num[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8))
  }
}
rownames(sig_gene_num) <- cancer_name
colnames(sig_gene_num) <- c(seq(0.1,1,0.1))
sig_gene_num$cancer_name <- rownames(sig_gene_num)
sig_gene_num <- pivot_longer(data = sig_gene_num,cols = 1:(dim(sig_gene_num)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_num$cancer_name <- factor(sig_gene_num$cancer_name, levels = str_sort(unique(sig_gene_num$cancer_name),numeric = T))
sig_gene_num$cancer_name <- as.factor(sig_gene_num$cancer_name)

ggplot(sig_gene_num, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  geom_line(size=1)#size是线的宽度
##画通路图
BiocManager::install('Rgraphviz')
library(topGO)
library(GO.db)
library(clusterProfiler)
a <- apply(surv_data[[1]][[1]], 2, max)
b <- surv_data[[1]][[1]][,which.max(a[a!=0])]
c <- rownames(surv_data[[1]][[1]])
c <- bitr(c,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
d <- rownames(surv_data[[1]][[1]])[b>=0.8]
d <- bitr(d,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
geneList <- names(c[,2])
geneList <- factor(as.integer(c[,2]%in%d[,2]))##注意，这里因子的设置是通过转换布尔值变成1和0来设置的
names(geneList) <- c[,2]##这里是进行命名

GOdata <- new(
  "topGOdata",
  ontology = "BP",
  allGenes = geneList,
  nodeSize = 10,
  annot = annFUN.org,
  mapping = "org.Hs.eg.db",
  ID = "entrez")
test.stat <- new("classicCount", testStatistic = GOFisherTest, name = "Fisher test")
resultFisher <- getSigGroups(GOdata, test.stat)
test.stat <- new("elimScore", testStatistic = GOKSTest, name = "Fisher test", cutOff = 0.01)
resultElim <- getSigGroups(GOdata, test.stat)
test.stat <- new("weightCount", testStatistic = GOFisherTest, name="Fisher test", sigRatio = "ratio")
resultWeight <- getSigGroups(GOdata, test.stat)
test.stat <- new("classicScore", testStatistic = GOKSTest, name = "KS tests")
resultKS <- getSigGroups(GOdata, test.stat)
elim.ks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
allRes <- GenTable(GOdata, classic=elim.ks, KS=resultKS, weight = resultWeight,
                   orderBy = "weight", ranksOf = "classic", topNodes =10)
a <- showSigOfNodes(GOdata, score(resultWeight), firstSigNodes = 10, useInfo = "all")
pdf('result/Figure/有向图.pdf')
print(a,newpage = FALSE)
dev.off()
##处理GO条目，给每一条GO加上level
go_basic <- read.csv('/database/Gene Ontology/homo_sapiens/go-basic-clean.csv')
a <- str_split(go_basic[1:140122,],': ',simplify = T)##按照某符号拆分某列
a <- a[a[,1]%in%c('id','is_a'),]
a <- a[grep(pattern='GO:',a[,2]),]
a[,2] <- substring(a[,2],1,10)
a <- a[,1:2]
b <- a
locate <- which(a[,1]=='id')#获取id行的定位
locate <- c(locate,117784)#为了下面方便使用，加一个末尾
for (i in 1:47273) {
  b[locate[i]:(locate[i+1]-1),1] <- a[locate[i],2]#修改所有的is_a为id行GO
}
c <- b[a[,1]!='id',]
GO_inter <- as.data.frame(c)



go_level <- list()
go_level[[1]] <- b[!b[,1]%in%b[duplicated(b[,1]),1],1]
names(go_level)[1] <- paste('Level',1,sep = '')
for (i in 2:18) {
  go_level[[i]] <- c[c[,2]%in%go_level[[i-1]],1]
  go_level[[i]] <- go_level[[i]][!duplicated(go_level[[i]])]
  names(go_level)[i] <- paste('Level',i,sep = '')
}

go_basic <- a[a[,1]=='id',]
go_basic <- as.data.frame(go_basic)
for (i in 1:18) {
  go_basic[go_basic[,2]%in%go_level[[i]],3] <- names(go_level)[i]
}


##构建生存相关的显著基因网络
surv_raw_data <- list()
result <- list()
surv_sig_inter <- list()
surv_sig_dgree <- list()
for (i in 1:length(cancer_name)) {
  file_name <- dir(paste('result/',cancer_name[i],'/raw_data',sep = ''))
  surv_raw_data[[i]] <- read.csv(paste('result/',cancer_name[i],'/raw_data/',file_name,sep = ''),row.names = 1,header = T)
  surv_raw_data[[i]] <- as.matrix(surv_raw_data[[i]])
  surv_raw_data[[i]][surv_raw_data[[i]]>=0.05] <- 0
  surv_raw_data[[i]][surv_raw_data[[i]]!=0] <- 1
  a <- surv_raw_data[[i]][rownames(surv_raw_data[[i]])%in%rownames(surv_data_sig[[i]][[1]]),]
  result[[i]] <- data.frame()
  for (x in 1:nrow(a)) {
    for (j in 1:nrow(surv_raw_data[[i]])) {
      result[[i]][j,x] <- length(which(which(surv_raw_data[[i]][j,]==1)%in%which(a[x,]==1)))/((length(which(a[x,]==1))+length(which(surv_raw_data[[i]][j,]==1)))-2*length(which(which(a[x,]==1)%in%which(surv_raw_data[[i]][j,]==1)))+1)
    }
  }
  rownames(result[[i]]) <- rownames(surv_raw_data[[i]])
  colnames(result[[i]]) <- rownames(a)
  result_matrix <- as.matrix(result[[i]])
  a <- seq(0.01,1,0.01)
  b <- data.frame()
  for (x in 1:100) {
    b[x,1] <- a[x]
    b[x,2] <- length(which(result_matrix>a[x]))-ncol(result_matrix)
  }
  plot(b)
  surv_sig_inter[[i]] <- data.frame()
  for (x in 1:ncol(result[[i]])) {
    a <- which(result[[i]][,x]>=max(b[which(b[,2]>=1000),1]))##此处还需更改，应当需要一个合适的数字
    n <- nrow(surv_sig_inter[[i]])
    surv_sig_inter[[i]][(n+1):(n+length(a)),1] <- rep(colnames(result[[i]])[x],length(a))
    surv_sig_inter[[i]][(n+1):(n+length(a)),2] <- result[[i]][a,x]
    surv_sig_inter[[i]][(n+1):(n+length(a)),3] <- rownames(result[[i]])[a]
  }
  for (x in 1:nrow(surv_sig_inter[[i]])) {
    ifelse(surv_sig_inter[[i]][x,1]==surv_sig_inter[[i]][x,3],surv_sig_inter[[i]][x,2] <- 0,0)
  }
  surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]!=0,]
  a <- surv_sig_inter[[i]][,1][!duplicated(surv_sig_inter[[i]][,1])]
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- length(which(surv_sig_inter[[i]][,1]==a[x]))
  }
  dir.create(paste('result/',cancer_name[i],'/inter_probality',sep = ''))
  write.csv(surv_sig_inter[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_inter_new.csv',sep = ''),quote = F,row.names = F)
  write.csv(surv_sig_dgree[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_dgree_new.csv',sep = ''),quote = F,row.names = F)
  write.csv(result[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_result_new.csv',sep = ''),quote = F)
}
names(surv_sig_inter) <- cancer_name
names(surv_sig_dgree) <- cancer_name
names(result) <- cancer_name
for (i in 1:15) {
  write.csv(surv_sig_inter[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_inter_top1000.csv',sep = ''),quote = F,row.names = F)
}

##extract top1000
for (i in 1:15) {
  a <- surv_sig_inter[[i]][order(surv_sig_inter[[i]][,2],decreasing = T)[1000],2]
  surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]>=a,]
}
# surv_sig_inter[[3]] <- read.csv('result/CESC/inter_probality/surv_sig_inter_new.csv')
for (i in 1:15) {
  a <- surv_sig_inter[[i]][,1][!duplicated(surv_sig_inter[[i]][,1])]
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- length(which(surv_sig_inter[[i]][,1]==a[x]))
  }
  write.csv(surv_sig_dgree[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_dgree_new.csv',sep = ''),quote = F,row.names = F)
}

####富集基因
library(clusterProfiler)
for (i in 1:length(cancer_name)) {
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
}
####富集通路
library(clusterProfiler)
library(stringr)

cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- apply(surv_data[[j]][[1]], 2, max)
  b <- surv_data[[j]][[1]][,which.max(a[a!=0])]
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which.max(a[a!=0])] >= 0.8),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name
surv_pathway <- list()
for (j in 1:length(cancer_name)) {
  surv_pathway[[j]] <- list()
  names(surv_pathway)[j] <- cancer_name[j]
  a <- bitr(rownames(surv_data_sig[[j]][[1]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[1]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  a <- bitr(rownames(surv_data[[j]][[2]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[2]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  a <- bitr(rownames(surv_data[[j]][[3]]),fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
            toType = c('ENTREZID'), #totype指需要转换成的ID类型
            OrgDb='org.Hs.eg.db')
  surv_pathway[[j]][[3]] <- enrichGO(a[,2], #数据源
                                     pvalueCutoff = 0.05, #P值阈值
                                     qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                     OrgDb = org.Hs.eg.db, #人类参考基因组
                                     ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                     readable = TRUE) #是否将基因ID转换为基因名
  names(surv_pathway[[j]]) <- names(surv_data[[j]])[1]
  surv_pathway[[j]][[1]] <- as.data.frame(surv_pathway[[j]][[1]])
  surv_pathway[[j]][[2]] <- as.data.frame(surv_pathway[[j]][[2]])
  surv_pathway[[j]][[3]] <- as.data.frame(surv_pathway[[j]][[3]])
}

surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- rownames(surv_data_sig[[i]][[1]])
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}
names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
sig_pathway_plot_all <- surv_sig_pathway
sig_pathway_plot_all@compareClusterResult <- sig_pathway_plot_all@compareClusterResult[sig_pathway_plot_all@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_all,showCategory=5,includeAll=TRUE,label_format = 80)
##对网络top10进行富集
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- surv_sig_dgree[[i]][1:10,1]
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}

names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
##提取指定层次的通路进行绘制通路图
sig_pathway_plot_top10 <- surv_sig_pathway
sig_pathway_plot_top10@compareClusterResult <- sig_pathway_plot_top10@compareClusterResult[sig_pathway_plot_top10@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_top10,showCategory=5,includeAll=TRUE,label_format = 80)

##画免疫浸润的生存曲线
library(survival)
library(survminer)
library(data.table)
expression_raw <- list()
for (i in 1:15) {
  a <- fread(paste('/database/TCGA/',cancer_name[i],'/tumor_TCGA_',cancer_name[i],'_immune.csv',sep = ''),sep = ',') 
  a <- as.data.frame(a)
  rownames(a) <- a$V1
  a <- a[,-1]
  # expression_raw[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/tumor_TCGA_',cancer_name[i],'_immune.csv',sep = ''),row.names = 1) 
  expression_raw[[i]] <- a
}
names(expression_raw) <-cancer_name

lifetime <- list()
for (i in 1:15) {
  lifetime[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/',cancer_name[i],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[[i]][,6] <- gsub('-','.',lifetime[[i]][,6])
  expression_raw[[i]] <- expression_raw[[i]][,which(colnames(expression_raw[[i]]) %in% lifetime[[i]][,6])]
  lifetime[[i]] <- lifetime[[i]][which(lifetime[[i]][,6] %in% colnames(expression_raw[[i]])),]
  lifetime[[i]] <- lifetime[[i]][which(!duplicated(lifetime[[i]][,6])),]
  lifetime[[i]]$Sample.ID <- factor(lifetime[[i]]$Sample.ID, levels = colnames(expression_raw[[i]]))
  lifetime[[i]] <- lifetime[[i]][order(lifetime[[i]]$Sample.ID),]
  lifetime[[i]][which(lifetime[[i]][,2]=='Alive'),2] <- 0
  lifetime[[i]][which(lifetime[[i]][,2]=='Dead'),2] <- 1
}
names(lifetime) <- cancer_name

immune_surv <- list()
immune_surv_plot <- list()
for (i in 1:15) {
  d <- expression_raw[[i]][1:10,]
  immune_surv[[i]] <- list()
  immune_surv_plot[[i]] <- list()
  for (j in 1:10) {
    a <- d[j,]
    b <- lifetime[[i]][lifetime[[i]][,6] %in% colnames(a),] 
    b[b[,6]%in%colnames(a)[which(a <= median(as.numeric(a)))],7] <- 'low'
    b[b[,6]%in%colnames(a)[which(a > median(as.numeric(a)))],7] <- 'high'
    c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
    immune_surv[[i]][[j]] <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
    immune_surv_plot[[i]][[j]] <- ggsurvplot(immune_surv[[i]][[j]],            # 创建的拟合对象
                                             conf.int = T,    # 显示置信区间
                                             pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                             add.all = F,     # 添加总患者生存曲线
                                             palette = "hue",    # 自定义调色板
                                             surv.median.line = "hv",     # 添加中位生存时间线
                                             risk.table = TRUE,             # 添加风险表
                                             xlab = "Follow up time(m)", # 指定x轴标签
                                             legend = c(0.8,0.75),         # 指定图例位置
                                             title = paste(cancer_name[i],'-',rownames(d)[j],sep = ''),                 # 设置图例标题
                                             legend.labs = c('high','low'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致
                                             break.x.by = 500)              # 设置x轴刻度间距
  }
}
ggsave('ucec-Treg.pdf',path = 'result/Figure/')
names(immune_surv_plot) <- cancer_name
immune_surv_plot[[10]][[1]]
a <- t(a)
a <- expression_raw[[i]][rownames(expression_raw[[i]])=='CD19',]
b <- lifetime[[i]][lifetime[[i]][,6] %in% colnames(a),] 
b[b[,6]%in%colnames(a)[which(a <= mean(as.numeric(a)))],7] <- 'low'
b[b[,6]%in%colnames(a)[which(a > mean(as.numeric(a)))],7] <- 'high'
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = T,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(m)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = paste(cancer_name[i],'-',rownames(d)[j],sep = ''),                 # 设置图例标题
           legend.labs = c('high','low'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致
           break.x.by = 500)              # 设置x轴刻度间距


####使用显著基因对LUAD进行分类，并与TCGA三种亚型进行分类
subtype <- read.csv('/database/文献/肺癌的分子分型/肺腺癌/luad_subtype.csv')
subtype <- subtype[,c('Tumor.ID','expression_subtype')]
subtype[,2] <- subtype[,2]
subtype[,2][subtype[,2]=='prox.-inflam'] <- 'PI'
subtype[,2][subtype[,2]=='prox.-prolif.'] <- 'PP'
luad_subtype <- lifetime[[8]]
colnames(subtype)[1] <- 'case_id'
luad_subtype <- merge(luad_subtype,subtype,by = 'case_id',all=F)

####LUAD层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- luad_subtype
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'Z'

##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,7]=='X',6],],data[rownames(data)%in%b[b[,7]=='Y',6],],data[rownames(data)%in%b[b[,7]=='Z',6],])
annotation_col <- rbind(b[b[,7]=='X',7:8],b[b[,7]=='Y',7:8],b[b[,7]=='Z',7:8])
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster','subtype')
rownames(annotation_col) <- rownames(hotmap)
ann_colors = list(subtype = c(PI="#1B9E77", PP="firebrick",TRU='#D95F02'), #连续数值型分组可设置成渐变  
                  cluster = c(X = "#7570B3", Y = "#E7298A", Z = "#66A61E")) 
hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                   annotation_colors = ann_colors)

##生存分析分组状况
#聚类分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('LUAD_siggene_cluster'),                 # 设置图例标题
           #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)
#TCGA分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,8], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,8], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('LUAD_siggene_cluster'),                 # 设置图例标题
           legend.labs = c('PI','PP','TRU'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)

##画柱状图看统计情况
library(tidyr)
subtype_sum <- data.frame()
for (i in 1:3) {
  subtype_sum[1,i] <- length(which(b[b[,7]==c('X','Y','Z')[i],8]=='PI'))
  subtype_sum[2,i] <- length(which(b[b[,7]==c('X','Y','Z')[i],8]=='PP'))
  subtype_sum[3,i] <- length(which(b[b[,7]==c('X','Y','Z')[i],8]=='TRU'))
}
colnames(subtype_sum) <- c('X','Y','Z')
rownames(subtype_sum) <- c('PI','PP','TRU')
subtype_sum <- apply(subtype_sum, 2, function(x){x/sum(x)})
subtype_sum <- as.data.frame(subtype_sum)
subtype_sum[1:3,4] <- rownames(subtype_sum)
colnames(subtype_sum)[4] <- 'subtype'
subtype_sum <- pivot_longer(data = subtype_sum,cols = 1:(ncol(subtype_sum)-1),
                            names_to = "cluster",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$subtype <- factor(subtype_sum$subtype)
subtype_sum$cluster <- factor(subtype_sum$cluster)

p <- ggplot(subtype_sum, aes(x=cluster, y=percents,fill=subtype)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack")
p+theme(
  text = element_text(size=20),  #所有字体大小为20
  axis.text.x = element_text(angle=0, vjust = 0.5),  #X轴文字90度摆放,水平微调0.5
  axis.title.x=element_blank(),  #删除X轴标题
  axis.title.y=element_blank(),  #删除Y轴标题
  panel.background = element_blank() #删除灰色背景
)

####LUAD的模型构建与验证
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据
library('DESeq2')
library('survival')
library('survminer')
library('dplyr')
library('glmnet')
library('ggplot2')
library('GGally')
library('rms')
library('survivalROC')
library('plotROC')
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in 1:ncol(risk_score_table)){
    risk_score_table[,each_sig_gene] <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[colnames(risk_score_table)[each_sig_gene],1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
# predict_effect <- list()
# gene_score <- list()
# single_genelist <- list()
for (j in 8) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
      AUC_max_time <- 1825
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                             conf.int = F,    # 显示置信区间
                                             pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                             add.all = F,     # 添加总患者生存曲线
                                             palette = "hue",    # 自定义调色板
                                             surv.median.line = "hv",     # 添加中位生存时间线
                                             risk.table = TRUE,             # 添加风险表
                                             xlab = "Follow up time(m)", # 指定x轴标签
                                             legend = c(0.8,0.75),         # 指定图例位置
                                             title = c('LUAD_siggene_cluster'),                 # 设置图例标题
                                             #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                             break.x.by = 500,# 设置x轴刻度间距
                                             pval.method=T)},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(m)", # 指定x轴标签
                                               legend = c(0.8,0.75),         # 指定图例位置
                                               title = c('LUAD_siggene_cluster'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 500,# 设置x轴刻度间距
                                               pval.method=T)})
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证
ver_expr_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/tumor_CPTAC_LUAD_immune.csv',row.names = 1)
for (j in 8) {
  tryCatch({
    ##计算基因模型风险评分
    tryCatch({
      predict_effect_ver[[j]] <- list()
      gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
      expr_data <- ver_expr_data
      rownames(expr_data) <- gsub('-','_',rownames(expr_data))
      expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
      expr_data <- log2(expr_data+1)
      life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
      life_data[life_data[,2]=='Alive',2] <- 1
      life_data[life_data[,2]=='Dead',2] <- 0
      life_data <- life_data[,c(1,6,5,2)]
      life_data[,2] <- gsub('-','.',life_data[,2])
      life_data[,2] <- gsub(', ','..',life_data[,2])
      life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
      colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
      DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
      # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
      # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
      for (i in 1:nrow(life_data)) {
        life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
      }
      for (k in 3:ncol(life_data)) {
        life_data[,k] <- as.numeric(life_data[,k])
      }
      survival_cancer <- life_data
      ###
      #使用合格的基因进行多变量cox回归。
      multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
      
      #calculate the risk score of each sample.
      candidate_genes_for_cox2 <- gene_list
      risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                               candidate_genes_for_cox=candidate_genes_for_cox2, 
                                               cox_report=multi_variate_cox_2)
      ###ROC曲线
      multi_ROC <- function(time_vector, risk_score_table){
        library('survivalROC')
        single_ROC <- function(single_time){
          for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                                 status = risk_score_table$censoring_status,
                                 marker = risk_score_table$total_risk_score,
                                 predict.time = single_time, method = 'KM')
          data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                     'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                     'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
        }
        multi_ROC_list <- lapply(time_vector, single_ROC)
        do.call(rbind, multi_ROC_list)
      }
      #We evaluate 11 AUCs between 3-5 years.
      for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
      AUC_max <- max(for_multi_ROC$AUC)
      AUC_max_time <- max(for_multi_ROC$Time_point)
      #visualization of the ROC curves of multiple time points.
      pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
        geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
        geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
        theme_bw()+
        theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
              panel.grid = element_blank())+
        annotate("text",x = 0.75, y = 0.15,
                 label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
      pROC
      predict_effect_ver[[j]][[1]] <- pROC
      
      AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
      ifelse(AUC_max>0.5,{
        #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'low'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        library('survminer')
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                                   conf.int = F,    # 显示置信区间
                                                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                                   add.all = F,     # 添加总患者生存曲线
                                                   palette = "hue",    # 自定义调色板
                                                   surv.median.line = "hv",     # 添加中位生存时间线
                                                   risk.table = TRUE,             # 添加风险表
                                                   xlab = "Follow up time(m)", # 指定x轴标签
                                                   legend = c(0.8,0.75),         # 指定图例位置
                                                   title = c('LUAD_siggene_cluster'),                 # 设置图例标题
                                                   #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                                   break.x.by = 500,# 设置x轴刻度间距
                                                   pval.method=T)},
        {
          AUC_max <- min(for_multi_ROC$AUC)##另一个情况
          AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
          AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
          AUC_max_time <- AUC_max_time[length(AUC_max_time)]
          for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
          #find the optimal cutoff value within the ROC curve of the optimal time point.
          optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
          cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
          high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
          high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
          high_low[high_low == FALSE] <- 'high'
          risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
          predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
          gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
          #KM_plot generation.
          #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
          # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
          # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
          fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
          ggsurvplot(fit_km,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Follow up time(m)", # 指定x轴标签
                     legend = c(0.8,0.75),         # 指定图例位置
                     title = c('LUAD_siggene_cluster'),                 # 设置图例标题
                     #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 500,# 设置x轴刻度间距
                     pval.method=T)})
    }, error = function(e) {print('error')})
  }
}



##对5年生存的预测
for (j in 8) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
      AUC_max_time <- 1825
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                             conf.int = F,    # 显示置信区间
                                             pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                             add.all = F,     # 添加总患者生存曲线
                                             palette = "hue",    # 自定义调色板
                                             surv.median.line = "hv",     # 添加中位生存时间线
                                             risk.table = TRUE,             # 添加风险表
                                             xlab = "Follow up time(d)", # 指定x轴标签
                                             legend = c(0.8,0.9),         # 指定图例位置
                                             title = c('LUAD_predict'),                 # 设置图例标题
                                             #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                             break.x.by = 365,# 设置x轴刻度间距
                                             pval.method=T)},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_predict'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)})
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证
ver_expr_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/tumor_CPTAC_LUAD_immune.csv',row.names = 1)
for (j in 8) {
  ##计算基因模型风险评分
  tryCatch({
    predict_effect_ver[[j]] <- list()
    gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
    expr_data <- ver_expr_data
    rownames(expr_data) <- gsub('-','_',rownames(expr_data))
    expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
    expr_data <- log2(expr_data+1)
    life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
    life_data[life_data[,2]=='Alive',2] <- 1
    life_data[life_data[,2]=='Dead',2] <- 0
    life_data <- life_data[,c(1,6,5,2)]
    life_data[,2] <- gsub('-','.',life_data[,2])
    life_data[,2] <- gsub(', ','..',life_data[,2])
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    ###
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
    
    #calculate the risk score of each sample.
    candidate_genes_for_cox2 <- gene_list
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      AUC_max_time <- 1825
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                                 conf.int = F,    # 显示置信区间
                                                 pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                                 add.all = F,     # 添加总患者生存曲线
                                                 palette = "hue",    # 自定义调色板
                                                 surv.median.line = "hv",     # 添加中位生存时间线
                                                 risk.table = TRUE,             # 添加风险表
                                                 xlab = "Follow up time(d)", # 指定x轴标签
                                                 legend = c(0.8,0.9),         # 指定图例位置
                                                 title = c('LUAD_predict'),                 # 设置图例标题
                                                 #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                                 break.x.by = 365,# 设置x轴刻度间距
                                                 pval.method=T)},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        AUC_max_time <- 1825
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        ggsurvplot(fit_km,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,1),         # 指定图例位置
                   title = c('LUAD_siggene_cluster'),                 # 设置图例标题
                   #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)})
  }, error = function(e) {print('error')})
}



##LUAD去除ROC,对5年生存的预测
for (j in 8) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    b <- risk_score_table_multi_cox2
    b$censoring_status[which(b$overall_survival > AUC_max_time)] <- 0
    b$overall_survival[which(b$overall_survival > AUC_max_time)] <- AUC_max_time
    b[b[,8]>median(b[,8]),9] <- 'high'
    b[b[,8]<=median(b[,8]),9] <- 'low'
    c <- survfit(Surv(b[,2],as.numeric(b[,3]))~b[,9], data = b)
    ggsurvplot(c,            # 创建的拟合对象
               conf.int = F,    # 显示置信区间
               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
               add.all = F,     # 添加总患者生存曲线
               palette = "hue",    # 自定义调色板
               surv.median.line = "hv",     # 添加中位生存时间线
               risk.table = TRUE,             # 添加风险表
               xlab = "Follow up time(m)", # 指定x轴标签
               legend = c(0.8,0.75),         # 指定图例位置
               title = c('LUAD_siggene_cluster'),                 # 设置图例标题
               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
               break.x.by = 500,# 设置x轴刻度间距
               pval.method=T)
  }, error = function(e) {print('error')})
}
for (j in 8) {
  tryCatch({
    ##计算基因模型风险评分
    tryCatch({
      predict_effect_ver[[j]] <- list()
      gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
      expr_data <- ver_expr_data
      rownames(expr_data) <- gsub('-','_',rownames(expr_data))
      expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
      expr_data <- log2(expr_data+1)
      life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
      life_data[life_data[,2]=='Alive',2] <- 1
      life_data[life_data[,2]=='Dead',2] <- 0
      life_data <- life_data[,c(1,6,5,2)]
      life_data[,2] <- gsub('-','.',life_data[,2])
      life_data[,2] <- gsub(', ','..',life_data[,2])
      life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
      colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
      DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
      # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
      # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
      for (i in 1:nrow(life_data)) {
        life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
      }
      for (k in 3:ncol(life_data)) {
        life_data[,k] <- as.numeric(life_data[,k])
      }
      survival_cancer <- life_data
      ###
      #使用合格的基因进行多变量cox回归。
      multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
      
      #calculate the risk score of each sample.
      candidate_genes_for_cox2 <- gene_list
      risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                               candidate_genes_for_cox=candidate_genes_for_cox2, 
                                               cox_report=multi_variate_cox_2)
      AUC_max_time <- 1825
      b <- risk_score_table_multi_cox2
      b$censoring_status[which(b$overall_survival > AUC_max_time)] <- 0
      b$overall_survival[which(b$overall_survival > AUC_max_time)] <- AUC_max_time
      b[b[,8]>median(b[,8]),9] <- 'high'
      b[b[,8]<=median(b[,8]),9] <- 'low'
      c <- survfit(Surv(b[,2],as.numeric(b[,3]))~b[,9], data = b)
      ggsurvplot(c,            # 创建的拟合对象
                 conf.int = F,    # 显示置信区间
                 pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                 add.all = F,     # 添加总患者生存曲线
                 palette = "hue",    # 自定义调色板
                 surv.median.line = "hv",     # 添加中位生存时间线
                 risk.table = TRUE,             # 添加风险表
                 xlab = "Follow up time(m)", # 指定x轴标签
                 legend = c(0.8,0.75),         # 指定图例位置
                 title = c('LUAD_siggene_cluster'),                 # 设置图例标题
                 #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                 break.x.by = 500,# 设置x轴刻度间距
                 pval.method=T)
    }, error = function(e) {print('error')})
  }
}##不能去除ROC

#回归系数test,修改了bug
# library('dplyr')
# survival_cancer_df <- survival_cancer
# candidate_genes_for_cox <- candidate_genes_for_cox2
# cox_report <- multi_variate_cox_2
# risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
# # for(each_sig_gene in colnames(risk_score_table)){
# #   risk_score_table$each_sig_gene <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[each_sig_gene,1])
# #   print('1')
# # }#这一步代码应该写错了，实际上没有用上系数
# for(each_sig_gene in 1:ncol(risk_score_table)){
#   risk_score_table[,each_sig_gene] <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[colnames(risk_score_table)[each_sig_gene],1])
#   print('1')
# }
# risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
#   cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
# risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
# risk_score_table


##乳腺癌的5年生存的预测
####使用显著基因对LUAD进行分类，并与TCGA三种亚型进行分类
##去除ROC
for (j in 8) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    b <- risk_score_table_multi_cox2
    b[b[,8]>median(b[,8]),9] <- 'high'
    b[b[,8]<=median(b[,8]),9] <- 'low'
    c <- survfit(Surv(b[,2],as.numeric(b[,3]))~b[,9], data = b)
    ggsurvplot(c,            # 创建的拟合对象
               conf.int = F,    # 显示置信区间
               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
               add.all = F,     # 添加总患者生存曲线
               palette = "hue",    # 自定义调色板
               surv.median.line = "hv",     # 添加中位生存时间线
               risk.table = TRUE,             # 添加风险表
               xlab = "Follow up time(m)", # 指定x轴标签
               legend = c(0.8,0.75),         # 指定图例位置
               title = c('BRCA_siggene_cluster'),                 # 设置图例标题
               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
               break.x.by = 500,# 设置x轴刻度间距
               pval.method=T)
  }, error = function(e) {print('error')})
}
for (j in 8) {
  tryCatch({
    ##计算基因模型风险评分
    tryCatch({
      predict_effect_ver[[j]] <- list()
      gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
      expr_data <- ver_expr_data[[j]]
      rownames(expr_data) <- gsub('-','_',rownames(expr_data))
      expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
      expr_data <- log2(expr_data+1)
      life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
      life_data[life_data[,2]=='Alive',2] <- 1
      life_data[life_data[,2]=='Dead',2] <- 0
      life_data <- life_data[,c(1,6,5,2)]
      life_data[,2] <- gsub('-','.',life_data[,2])
      life_data[,2] <- gsub(', ','..',life_data[,2])
      life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
      colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
      DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
      # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
      # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
      for (i in 1:nrow(life_data)) {
        life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
      }
      for (k in 3:ncol(life_data)) {
        life_data[,k] <- as.numeric(life_data[,k])
      }
      survival_cancer <- life_data
      ###
      #使用合格的基因进行多变量cox回归。
      multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
      
      #calculate the risk score of each sample.
      candidate_genes_for_cox2 <- gene_list
      risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                               candidate_genes_for_cox=candidate_genes_for_cox2, 
                                               cox_report=multi_variate_cox_2)
      b <- risk_score_table_multi_cox2
      b[b[,8]>median(b[,8]),9] <- 'high'
      b[b[,8]<=median(b[,8]),9] <- 'low'
      c <- survfit(Surv(b[,2],as.numeric(b[,3]))~b[,9], data = b)
      ggsurvplot(c,            # 创建的拟合对象
                 conf.int = F,    # 显示置信区间
                 pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                 add.all = F,     # 添加总患者生存曲线
                 palette = "hue",    # 自定义调色板
                 surv.median.line = "hv",     # 添加中位生存时间线
                 risk.table = TRUE,             # 添加风险表
                 xlab = "Follow up time(m)", # 指定x轴标签
                 legend = c(0.8,0.75),         # 指定图例位置
                 title = c('LUAD_siggene_cluster'),                 # 设置图例标题
                 #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                 break.x.by = 500,# 设置x轴刻度间距
                 pval.method=T)
    }, error = function(e) {print('error')})
  }
}##去除ROC








####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:10,1]),]))
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- lifetime[[2]]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'Z'

##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,7]=='X',6],],data[rownames(data)%in%b[b[,7]=='Y',6],])
# annotation_col <- rbind(b[b[,7]=='X',6:7],b[b[,7]=='Y',6:7],b[b[,7]=='Z',6:7])
# colnames(annotation_col) <- c('cluster','subtype')
# rownames(annotation_col) <- rownames(hotmap)
# ann_colors = list(cluster = c(X = "#7570B3", Y = "#E7298A")#连续数值型分组可设置成渐变  
#                   ) 
hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
pheatmap::pheatmap(hotmap,cluster_col = F,show_colnames = F,
                   annotation_colors = ann_colors)

##生存分析分组状况
#聚类分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('BRAD_siggene_cluster'),                 # 设置图例标题
           #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)

####重新分析药物响应数据
####鉴定不同基因表达不同的细胞系
cell_lines_backgroud <- read.table('/database/GDSC/backgroud_expression/Cell_line_RMA_proc_basalExp.txt',header = T,sep = '\t',fill=T)
cell_lines_backgroud <- cell_lines_backgroud[cell_lines_backgroud[,1]!='',]
rownames(cell_lines_backgroud) <- cell_lines_backgroud[,1]
cell_lines_backgroud <- cell_lines_backgroud[,-1:-2]
cell_line_name <- read.table('/database/GDSC/backgroud_expression/E-MTAB-3610.sdrf.txt',sep = '\t',header = T)
a <- colnames(cell_lines_backgroud)
a <- str_split(a,'[.]',simplify = T)
for (i in 1:nrow(a)) {
  a[grep(pattern=a[i,2],cell_line_name[,1]),3] <- cell_line_name[i,3]
}
colnames(cell_lines_backgroud) <- a[,3]

a <- cell_line_name[,1]
a <- str_split(a,'[_]',simplify = T)
for (i in 1:nrow(a)) {
  a[grep(pattern=a[i,2],cell_line_name[,1]),3] <- cell_line_name[i,3]
}
colnames(cell_lines_backgroud) <- a[,3]
a <- a[,-1:-3]
for (i in 1:nrow(a)) {
  b <- a[i,]
  b <- b[b!='']
  b <- b[-length(b)]
  b <- paste(b,collapse = '_')
  a[i,1] <- b
}
cell_line_name[,2] <- a[,1]

write.table(cell_line_name[,2][!duplicated(cell_line_name[,2])],'gdsc_classification.txt',sep = '\t',row.names = F,quote = F)
gdsc_classification <- data.frame(1:length(cancer_name))
rownames(gdsc_classification) <- cancer_name
gdsc_classification[1,1:2] <- c('Bladder','urinary_tract')
gdsc_classification[2,1:2] <- c('Breast','breast')
gdsc_classification[3,1:2] <- c('Cervix','cervix')
gdsc_classification[4,1:2] <- c('large_intestine','Intestine')
gdsc_classification[5,1:2] <- c('kidney','Kidney')
gdsc_classification[6,1:2] <- c('Brain','central_nervous_system')
gdsc_classification[7,1] <- c('Liver')
gdsc_classification[8,1:4] <- c('lung','Lung','Lung:NSCLC','[JPC-3]_Lung')
gdsc_classification[9,1:4] <- c('lung','Lung','Lung:NSCLC','[JPC-3]_Lung')
gdsc_classification[10,1:2] <- c('Ovary','ovary')
gdsc_classification[11,1:2] <- c('Pancreas','pancreas')
gdsc_classification[12,1:2] <- c('Prostate','prostate')
gdsc_classification[13,1:2] <- c('Stomach','gastrointestinal_tract_(site_indeterminate)')
gdsc_classification[14,1:2] <- c('Thyroid','thyroid')
gdsc_classification[15,1] <- c('endometrium')
base_expr_cell <- list()
for (i in 1:length(cancer_name)) {
  a <- cell_line_name[cell_line_name[,2]%in%gdsc_classification[i,],3]
  base_expr_cell[[i]] <- cell_lines_backgroud[rownames(cell_lines_backgroud)%in%surv_sig_dgree[[i]][1:10,1],colnames(cell_lines_backgroud)%in%a]
}
names(base_expr_cell) <- cancer_name

a <- character()
for (i in 1:15) {
  a <- c(a,surv_sig_dgree[[i]][1:10,1])
}
a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
write.table(a,'sig_gene.csv',row.names = F,quote = F,sep = '\t')
a <- character()
for (i in 1:15) {
  a <- c(a,colnames(base_expr_cell[[i]]))
}
a <- gsub('-','',a)
write.csv(a,'cell_line_name.csv')
##读取显著基因的细胞系背景表达谱
cell_line_expr <- read.csv('sig_gene_data_1.csv',header = F,row.names = 1)##服务器中提取的cMAP相应的TOP10数据

cell_line_expr_cp <- as.data.frame(cell_line_expr)
cell_line_expr_cp[1,] <- as.character(cell_line_expr_cp[1,]) 
colnames(cell_line_expr_cp) <- cell_line_expr_cp[1,]
cell_line_expr_cp <- cell_line_expr_cp[-1,]
sig_gene_cmap <- read.csv('sig_gene.csv',sep = '\t')
a <- colnames(cell_line_expr_cp)
a <- a[a%in%sig_gene_cmap[,2]]
for (i in 1:length(a)) {
  a[i] <- sig_gene_cmap[sig_gene_cmap[,2]%in%a[i],1]
}
colnames(cell_line_expr_cp) <- a
for (i in 1:ncol(cell_line_expr_cp)) {
  cell_line_expr_cp[,i] <- as.numeric(cell_line_expr_cp[,i])
}
##拆分细胞系与药物
library(stringr)
b <- rownames(cell_line_expr_cp)
b <- str_split(b,'[_]',simplify = T)
# a <- str_split(b[,1],'[_]',simplify = T)
# b <- cbind(a,b[,2:9])
cell_line_expr_drug <- list()
for (i in 1:15) {
  a <- colnames(base_expr_cell[[i]])
  a <- gsub('-','',a)
  cell_line_expr_drug[[i]] <- list()
  for (j in 1:length(a)) {
    cell_line_expr_drug[[i]][[j]] <- cell_line_expr_cp[b[,2]%in%a[j],colnames(cell_line_expr_cp)%in%surv_sig_dgree[[i]][1:10,1]]
    cell_line_expr_drug[[i]][[j]] <- as.data.frame(cell_line_expr_drug[[i]][[j]])
    rownames(cell_line_expr_drug[[i]][[j]]) <- rownames(cell_line_expr_cp[b[,2]%in%a[j],])
    colnames(cell_line_expr_drug[[i]][[j]]) <- colnames(cell_line_expr_cp)[colnames(cell_line_expr_cp)%in%surv_sig_dgree[[i]][1:10,1]]
  }
  names(cell_line_expr_drug[[i]]) <- a
}
names(cell_line_expr_drug) <- cancer_name
for (i in 1:15) {
  for (j in 1:length(cell_line_expr_drug[[i]])) {
    ifelse(length(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
    ifelse(nrow(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
  }
}
for (i in 1:15) {
  cell_line_expr_drug[[i]] <- cell_line_expr_drug[[i]][names(cell_line_expr_drug[[i]])!='no']
}

##提取上下0.25的细胞系(由于以前的bug，此段代码原功能已经无效，此时只是为了把格式变为下面的代码可用的形式)
cell_line_0.25_0.75 <- list()
for (i in 1:15) {
  cell_line_0.25_0.75[[i]] <- list()
  a <- colnames(base_expr_cell[[i]])
  a <- gsub('-','',a)
  if (length(cell_line_expr_drug[[i]])>0) {
    for (j in 1:ncol(cell_line_expr_drug[[i]][[1]])) {
      tryCatch({
        cell_line_0.25_0.75[[i]][[j]] <- list()
        cell_line_0.25_0.75[[i]][[j]][[1]] <- character()
        cell_line_0.25_0.75[[i]][[j]][[2]] <- character()
        # b <- quantile(base_expr_cell[[i]][j,])
        cell_line_0.25_0.75[[i]][[j]][[1]] <- names(cell_line_expr_drug[[i]])
        # cell_line_0.25_0.75[[i]][[j]][[2]] <- names(cell_line_expr_drug[[i]])
        # cell_line_0.25_0.75[[i]][[j]][[2]] <- a[base_expr_cell[[i]][j,]]
        names(cell_line_0.25_0.75[[i]][[j]]) <- c('0.25','0.75')
      }, error = function(e) {print('error')})
    }
    names(cell_line_0.25_0.75[[i]]) <- colnames(cell_line_expr_drug[[i]][[1]])
  }
}
names(cell_line_0.25_0.75) <- cancer_name

####整理数据
cell_line_0.25_0.75_cmap <- cell_line_0.25_0.75
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_cmap[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75[[i]])) {
      for (x in 1:2) {
        cell_line_0.25_0.75_cmap[[i]][[j]][[x]] <- cell_line_expr_drug[[i]][names(cell_line_expr_drug[[i]])%in%cell_line_0.25_0.75[[i]][[j]][[x]]]
      }
    }
  }
}

cmap_drug_name <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_pert_info.txt.gz',sep = '\t')
gdsc_drug_name <- read.csv('/database/GDSC/drug_IC50/screened_compunds_rel_8.2.csv',row.names = 1)
cmap_drug_name[,2] <- tolower(cmap_drug_name[,2])
gdsc_drug_name[,2] <- tolower(gdsc_drug_name[,2])
map_cmap_gdsc <- cmap_drug_name[,2][cmap_drug_name[,2]%in%gdsc_drug_name[,2]]
# cmap_drug_name <- cmap_drug_name[cmap_drug_name[,2]%in%map_cmap_gdsc,]

# b <- rownames(cell_line_expr_cp)
# b <- str_split(b,'[_]',simplify = T)
# b <- b[!duplicated(b[,2]),2]
# for (i in 1:length(cancer_name)) {
#   for (j in 1:length(cell_line_0.25_0.75_cmap[[i]])) {
#     for (x in 1:2) {
#       cell_line_0.25_0.75_cmap[[i]][[j]][[x]] <- cell_line_0.25_0.75_cmap[[i]][[j]][[x]][cell_line_0.25_0.75_cmap[[i]][[j]][[x]]%in%b]
#     }
#   }
# }

##这是为了整理药物与基因表达的联系
for (i in 1:length(cancer_name)) {
  for (j in 1:length(cell_line_0.25_0.75_cmap[[i]])) {
    for (x in 1:2) {
      tryCatch({
        for (e in 1:length(cell_line_0.25_0.75_cmap[[i]][[j]][[x]])) {
          a <- rownames(cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]])
          a <- str_split(a,'[_]',simplify = T)
          a <- as.data.frame(a)
          a[,3:5] <- as.data.frame(str_split(a[,3],'[:]',simplify = T))
          b <- str_split(a[,4],'[-]',simplify = T)
          a <- cbind(a[,1:3],b,5)
          a[,10] <- apply(a[,4:5],1,function(ve){paste(ve,collapse = '-')})
          for (s in 1:nrow(a)) {
            tryCatch({
              a[s,11] <- cmap_drug_name[cmap_drug_name[,1]%in%a[s,10],2]
            }, error = function(e) {0})
          }
          a[is.na(a[,11]),11] <- a[is.na(a[,11]),4]
          cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]] <- cbind(a[,11],cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]])
          cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]] <- aggregate(cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]][,names(cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]])%in%names(cell_line_0.25_0.75_cmap[[i]])[j]],
                                                                    by=list(cell_line_0.25_0.75_cmap[[i]][[j]][[x]][[e]][,1]),
                                                                    FUN=function(data){data[which.max(abs(data))]})##取绝对值最大的值
        }
      }, error = function(e) {print('error')})
    }
  }
  print(cancer_name[i])
}

##反复运行下面两段代码3编
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_cmap[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75_cmap[[i]])) {
      if (length(cell_line_0.25_0.75_cmap[[i]][[j]])>0) {
        for (k in 1:length(cell_line_0.25_0.75_cmap[[i]][[j]])) {
          if (length(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])>0) {
            for (x in 1:length(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])) {
              if (length(cell_line_0.25_0.75_cmap[[i]][[j]][[k]][[x]])>0) {
                if (ncol(cell_line_0.25_0.75_cmap[[i]][[j]][[k]][[x]])==1) {
                  names(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])[x] <- 'no'
                }
              }else{names(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])[x] <- 'no'}
            }
          }else{names(cell_line_0.25_0.75_cmap[[i]][[j]])[k] <- 'no'}
        }
      }else{cell_line_0.25_0.75_cmap[[i]][[j]] <- list()
      names(cell_line_0.25_0.75_cmap[[i]])[j] <- 'no'}
    }
  }
}
for (i in 1:15) {
  tryCatch({
    if (length(cell_line_0.25_0.75_cmap[[i]])>0) {
      cell_line_0.25_0.75_cmap[[i]] <- cell_line_0.25_0.75_cmap[[i]][names(cell_line_0.25_0.75_cmap[[i]])!='no']
      for (j in 1:length(cell_line_0.25_0.75_cmap[[i]])) {
        if (length(cell_line_0.25_0.75_cmap[[i]][[j]])>0) {
          for (k in 1:length(cell_line_0.25_0.75_cmap[[i]][[j]])) {
            cell_line_0.25_0.75_cmap[[i]][[j]][[k]] <- cell_line_0.25_0.75_cmap[[i]][[j]][[k]][names(cell_line_0.25_0.75_cmap[[i]][[j]][[k]])!='no']
          }
          cell_line_0.25_0.75_cmap[[i]][[j]] <- cell_line_0.25_0.75_cmap[[i]][[j]][names(cell_line_0.25_0.75_cmap[[i]][[j]])!='no']
        }
      }
    }
  }, error = function(e) {print('error')})
}

####计算细胞死亡与药物响应的相关性
cell_line_0.25_0.75_cor <- cell_line_0.25_0.75_cmap
gdsc_data <- gdsc[,c(5,9,19)]
gdsc_data[,1] <- gsub('-','',gdsc_data[,1])
gdsc_data[,2] <- tolower(gdsc_data[,2])
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_cor[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75_cor[[i]])) {
      for (x in 1:length(cell_line_0.25_0.75_cor[[i]][[j]])) {
        for (e in 1:length(cell_line_0.25_0.75_cor[[i]][[j]][[x]])) {
          a <- cell_line_0.25_0.75_cor[[i]][[j]][[x]][[e]]
          b <- gdsc_data[gdsc_data[,1]==names(cell_line_0.25_0.75_cor[[i]][[j]][[x]])[e]&gdsc_data[,2]%in%a[,1],]
          colnames(a)[1] <- colnames(b)[2]
          a <- merge(a,b[,2:3],by=colnames(a)[1],all=F)
          cell_line_0.25_0.75_cor[[i]][[j]][[x]][[e]] <- a
        }
      }
    } 
  }
}

cor_drug_cell_survive <- as.data.frame(t(data.frame(rep('',5))))
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_cor[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75_cor[[i]])) {
      for (k in 1:length(cell_line_0.25_0.75_cor[[i]][[j]])) {
        for (x in 1:length(cell_line_0.25_0.75_cor[[i]][[j]][[k]])) {
          if (nrow(cell_line_0.25_0.75_cor[[i]][[j]][[k]][[x]])>0) {
            tryCatch({
              b <- character()
              a <- cell_line_0.25_0.75_cor[[i]][[j]][[k]][[x]]
              ifelse(ncol(cell_line_0.25_0.75_dmso[[i]][[j]][[k]][[x]])==2,
                     a <- a[a[,2]<=mean(cell_line_0.25_0.75_dmso[[i]][[j]][[k]][[x]][,2])&a[,3]<=0,],
                     a <- a[a[,2]<=0&a[,3]<=0,])
              a <- aggregate(a[,2:3],list(a[,1]),FUN=function(data){data[which.max(abs(data))]})
              a[,3] <- as.numeric(a[,3])
              b[1] <- names(cell_line_0.25_0.75_cor)[i]
              b[2] <- names(cell_line_0.25_0.75_cor[[i]])[j]
              b[3] <- names(cell_line_0.25_0.75_cor[[i]][[j]])[k]
              b[4] <- names(cell_line_0.25_0.75_cor[[i]][[j]][[k]])[x]
              c <- cor.test(a[,2],a[,3],method = 'spearman')
              ifelse(c$p.value<0.05,b[5] <- c$estimate,b[5] <- 0)
              cor_drug_cell_survive <- rbind(cor_drug_cell_survive,b)
            }, error = function(e) {0})
          }
        }
      }
    }
  }
}
cor_drug_cell_survive <- cor_drug_cell_survive[-1,]
cor_drug_cell_survive[,5] <- as.numeric(cor_drug_cell_survive[,5])
cor_drug_cell_survive[,3][cor_drug_cell_survive[,3]==0.25] <- 'low'
cor_drug_cell_survive[,3][cor_drug_cell_survive[,3]==0.75] <- 'high'
colnames(cor_drug_cell_survive) <- c('cancer_name','gene_name','expr_level','cell_line','cor')
write.csv(cor_drug_cell_survive,'result/cor_drug_cell_survive.csv')

##获取DMSO和H2O处理的值
a <- rownames(cell_line_expr_cp)
a <- str_split(a,'[_]',simplify = T)
a <- as.data.frame(a)
a[,3:5] <- as.data.frame(str_split(a[,3],'[:]',simplify = T))
b <- str_split(a[,4],'[-]',simplify = T)
a <- cbind(a[,1:3],b,5)
cell_line_0.25_0.75_dmso <- cell_line_0.25_0.75_cor
for (i in 1:15) {
  if (length(cell_line_0.25_0.75_dmso[[i]])>0) {
    for (j in 1:length(cell_line_0.25_0.75_dmso[[i]])) {
      for (k in 1:length(cell_line_0.25_0.75_dmso[[i]][[j]])) {
        for (x in 1:length(cell_line_0.25_0.75_dmso[[i]][[j]][[k]])) {
          b <- cell_line_expr_cp[a[,4]%in%c('DMSO','H2O')&a[,2]%in%names(cell_line_0.25_0.75_dmso[[i]][[j]][[k]])[x],colnames(cell_line_expr_cp)%in%names(cell_line_0.25_0.75_dmso[[i]])[j]]
          b <- as.data.frame(b)
          if (nrow(b)>0) {
            b <- cbind(a[,4][a[,4]%in%c('DMSO','H2O')&a[,2]%in%names(cell_line_0.25_0.75_dmso[[i]][[j]][[k]])[x]],b)
            colnames(b) <- c('drug',names(cell_line_0.25_0.75_dmso[[i]])[j])
            b <- aggregate(b[,2],list(b[,1]),mean)
            cell_line_0.25_0.75_dmso[[i]][[j]][[k]][[x]] <- b
          }else{cell_line_0.25_0.75_dmso[[i]][[j]][[k]][[x]] <- b}
        }
      }
    }
  }
}

##筛选靶向药物
####screen target drug
##读取cMAP数据库中对应GDSC和显著基因(比对之后显著基因只剩93个)的数据
cell_line_expr <- read.csv('sig_gene_data.csv',header = F,row.names = 1)
cell_line_expr_cp <- as.data.frame(cell_line_expr)
cell_line_expr_cp[1,] <- as.character(cell_line_expr_cp[1,]) 
colnames(cell_line_expr_cp) <- cell_line_expr_cp[1,]
cell_line_expr_cp <- cell_line_expr_cp[-1,]

##读取显著基因列表
sig_gene_cmap <- read.csv('sig_gene.csv',sep = '\t')
a <- colnames(cell_line_expr_cp)
a <- a[a%in%sig_gene_cmap[,2]]
for (i in 1:length(a)) {
  a[i] <- sig_gene_cmap[sig_gene_cmap[,2]%in%a[i],1]
}
colnames(cell_line_expr_cp) <- a
for (i in 1:ncol(cell_line_expr_cp)) {
  cell_line_expr_cp[,i] <- as.numeric(cell_line_expr_cp[,i])
}

##拆分细胞系与药物,能将细胞系拆分成每种癌症对应
library(stringr)
b <- rownames(cell_line_expr_cp)
b <- str_split(b,'[_]',simplify = T)
# a <- str_split(b[,1],'[_]',simplify = T)
# b <- cbind(a,b[,2:9])
cell_line_expr_drug <- list()
for (i in 1:15) {
  a <- colnames(base_expr_cell[[i]])
  a <- gsub('-','',a)
  cell_line_expr_drug[[i]] <- list()
  for (j in 1:length(a)) {
    cell_line_expr_drug[[i]][[j]] <- cell_line_expr_cp[b[,2]%in%a[j],colnames(cell_line_expr_cp)%in%surv_sig_dgree[[i]][1:10,1]]
    cell_line_expr_drug[[i]][[j]] <- as.data.frame(cell_line_expr_drug[[i]][[j]])
    rownames(cell_line_expr_drug[[i]][[j]]) <- rownames(cell_line_expr_cp[b[,2]%in%a[j],])
    colnames(cell_line_expr_drug[[i]][[j]]) <- colnames(cell_line_expr_cp)[colnames(cell_line_expr_cp)%in%surv_sig_dgree[[i]][1:10,1]]
  }
  names(cell_line_expr_drug[[i]]) <- a
}
names(cell_line_expr_drug) <- cancer_name
for (i in 1:15) {
  for (j in 1:length(cell_line_expr_drug[[i]])) {
    ifelse(length(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
    ifelse(nrow(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
  }
}
for (i in 1:15) {
  cell_line_expr_drug[[i]] <- cell_line_expr_drug[[i]][names(cell_line_expr_drug[[i]])!='no']
}

##药物筛选
LUAD_cmap <- cell_line_expr_drug[[8]]
LUAD_cmap_drug <- list()
drug_id <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_inst_info.txt.gz',sep = '\t')

library(stringr)
b <- rownames(cell_line_expr_cp)
b <- str_split(b,'[_]',simplify = T)
# a <- str_split(b[,1],'[_]',simplify = T)
# b <- cbind(a,b[,2:9])
cell_line_expr_drug <- list()
for (i in 1:15) {
  a <- colnames(base_expr_cell[[i]])
  a <- gsub('-','',a)
  cell_line_expr_drug[[i]] <- list()
  for (j in 1:length(a)) {
    cell_line_expr_drug[[i]][[j]] <- cell_line_expr_cp[b[,2]%in%a[j],colnames(cell_line_expr_cp)%in%surv_sig_dgree[[i]][1:10,1]]
    cell_line_expr_drug[[i]][[j]] <- as.data.frame(cell_line_expr_drug[[i]][[j]])
    rownames(cell_line_expr_drug[[i]][[j]]) <- rownames(cell_line_expr_cp[b[,2]%in%a[j],])
    colnames(cell_line_expr_drug[[i]][[j]]) <- colnames(cell_line_expr_cp)[colnames(cell_line_expr_cp)%in%surv_sig_dgree[[i]][1:10,1]]
  }
  names(cell_line_expr_drug[[i]]) <- a
}
names(cell_line_expr_drug) <- cancer_name
for (i in 1:15) {
  for (j in 1:length(cell_line_expr_drug[[i]])) {
    ifelse(length(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
    ifelse(nrow(cell_line_expr_drug[[i]][[j]])==0,names(cell_line_expr_drug[[i]])[j] <- 'no',0)
  }
}
for (i in 1:15) {
  cell_line_expr_drug[[i]] <- cell_line_expr_drug[[i]][names(cell_line_expr_drug[[i]])!='no']
}
c <- gdsc[,c(5,9,19)]
c[,1] <- gsub('-','',c[,1])
c[,2] <- tolower(c[,2])
for (i in 1:15) {
  if (length(cell_line_expr_drug[[i]])>0) {
    for (j in 1:length(cell_line_expr_drug[[i]])) {
      row_name <- rownames(cell_line_expr_drug[[i]][[j]])
      a <- row_name
      a <- str_split(a,'[:]',simplify = T)
      a <- cbind(a[,1],substring(a[,2],1,13),a[,3])
      a <- cbind(str_split(a[,1],'[_]',simplify = T),a[,2:3])
      a <- as.data.frame(a)
      b <- drug_id[drug_id[,4]%in%a[,4],]
      b <- b[!duplicated(b[,4]),]
      # cell_line_expr_drug[[i]][[j]] <- cell_line_expr_drug[[i]][[j]][a[,4]%in%b[,4],]
      # a <- a[a[,4]%in%b[,4],]
      for (k in 1:nrow(a)) {
        if (length(which(b[,4]%in%a[k,4]))>=1) {
          a[k,6] <- b[b[,4]%in%a[k,4],5]
        }
      }
      a[,6] <- tolower(a[,6])
      cell_line_expr_drug[[i]][[j]] <- as.data.frame(cbind(a[,6],cell_line_expr_drug[[i]][[j]]))
      
      d <- c
      d <- d[d[,1]%in%a[,2],]
      n <- ncol(cell_line_expr_drug[[i]][[j]])
      if (nrow(d)!=0) {
        for (k in 1:nrow(cell_line_expr_drug[[i]][[j]])) {
          if (cell_line_expr_drug[[i]][[j]][k,1]%in%d[,2]) {
            cell_line_expr_drug[[i]][[j]][k,(n+1):(n+length(which(d[,2]%in%cell_line_expr_drug[[i]][[j]][k,1])))] <- d[which(d[,2]%in%cell_line_expr_drug[[i]][[j]][k,1]),3]
          }
        }
        rownames(cell_line_expr_drug[[i]][[j]]) <- row_name
      }
    }
  }
}
##绘制LUAD韦恩图
luad <- cell_line_expr_drug[[8]][[7]]
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
##基因提取
luad_dmso <- list()#这一步是获取低于每个sig_gene的表达量的药物
for (i in 1:length(cell_line_0.25_0.75_dmso[[8]])) {
  luad_dmso[[i]] <- cell_line_0.25_0.75_dmso[[8]][[i]][[1]][[5]]
  luad_dmso[[i]] <- luad[luad[,names(cell_line_0.25_0.75_dmso[[8]])[i]]<luad_dmso[[i]][1,2],]
  luad_dmso[[i]] <- luad_dmso[[i]][!is.na(luad_dmso[[i]][,1]),]
  luad_dmso[[i]] <- luad_dmso[[i]][!duplicated(luad_dmso[[i]][,1]),]
  names(luad_dmso)[i] <- names(cell_line_0.25_0.75_dmso[[8]])[i]
}
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA
gdsc_A549 <- tolower(gdsc_A549[,3])##将药物名称统一为小写
gdsc_A549 <- gdsc_A549[!duplicated(gdsc_A549)]##去重复

# luad_dmso[[length(luad_dmso)+1]] <- gdsc_A549
# names(luad_dmso)[length(luad_dmso)] <- 'gdsc_A549'

library(VennDiagram)
library(RColorBrewer)

luad_overlap <- luad_dmso[[1]][,1]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
for (i in 1:9) {
  luad_overlap <- luad_overlap[luad_overlap%in%luad_dmso[[i]][,1]]
}
luad_overlap <- luad_overlap[!duplicated(luad_overlap)]#去重复
venn.plot <- venn.diagram(x = list(sig_gene=luad_overlap,gdsc_A549=gdsc_A549,All_drug=All_drug),
                          category.names = c('sig_gene','gdsc_A549','All_drug'),
                          filename = NULL,
                          height = 1500, width = 1500, resolution =600,
                          alpha=c(0.6, 0.6, 0.6),
                          fill=c(colors()[616], colors()[38], colors()[468]), 
                          lwd=rep(1,3), cex=0.45, 
                          fontfamily = "serif", fontface = "bold",
                          cat.dist=c(-0.07, -0.07, -0.07),
                          output=TRUE,
                          cat.pos=c(280, 80, 180), #位置
                          cat.cex=0.45)##画韦恩图

pdf("result/Figure/luad_drug_screen_3.pdf")
grid.draw(venn.plot)
dev.off()

a <- luad
luad_overlap <- a[a[,1]%in%All_drug,]
luad_overlap <- a[a[,1]%in%luad_overlap,]
luad_overlap <- luad_overlap[!is.na(luad_overlap[,1]),]
luad_overlap <- luad_overlap[!is.na(luad_overlap[,11]),]
func_A=function(x) {x[which.min(x[,2]+x[,3]),]}
a <- luad_overlap[,1][!duplicated(luad_overlap[,1])]
c <- data.frame(t(rep('',13)))
for (i in 1:length(a)) {
  b <- luad_overlap[luad_overlap[,1]==a[i],]
  c[i,] <- b[which.min(apply(b[,2:10], 1, sum)),]
  rownames(c)[i] <- rownames(b)[which.min(apply(b[,2:10], 1, sum))]
}
for (i in 2:ncol(c)) {
  c[,i] <- as.numeric(c[,i])
}
colnames(c) <- colnames(luad_overlap)

gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549[,3] <- tolower(gdsc_A549[,3])##将药物名称统一为小写
gdsc_A549 <- gdsc_A549[!duplicated(gdsc_A549[,3]),]##去重复
median(plot_data[,11])
median(gdsc_A549[,6])


#画火山图
library(ggpubr)
library(ggplot2)
library(ggthemes)
library(ggrepel)
plot_data <- c
for (i in 1:nrow(plot_data)) {
  plot_data[i,11] <- min(plot_data[i,11:13][!is.na(plot_data[i,11:13])])
}
a <- apply(plot_data[,2:10], 1, sum)
plot_data <- cbind(plot_data[,c(1,11)],a)
colnames(plot_data) <- c('Drug_name','IC-50_Z-score','gene_expr_sum')
DEG <- as.data.frame(plot_data)
DESeq2_DEG <- na.omit(DEG)
DEG_data <- DESeq2_DEG

dim(DEG_data)
## [1] 5268    7
# 将基因分为两类：overlap，no_overlap
#将adj.P.value小于0.05，logFC大于2的基因设置为显著上调基因
#将adj.P.value小于0.05，logFC小于-2的基因设置为显著上调基因
DEG_data$Group <- "no_overlap"
DEG_data$Group[which(DEG_data$Drug_name%in%c[,1])] <- "overlap"
# DEG_data$Group[which((DEG_data$FDR < 0.05) & DEG_data$IncLevelDifference < -0.5)] <- "down-regulated"
# DEG_data$FDR <- -log10(DEG_data$FDR) # 对差异基因矫正后p-value进行log10()转换
# DEG_data$FDR[!is.finite(DEG_data$FDR)] <- 15
table(DEG_data$Group)
DEG_data <- DEG_data[order(DEG_data$`IC-50_Z-score`),]#对差异表达基因调整后的p值进行排序
#火山图中添加点(数据构建)
up_label <- DEG_data[DEG_data$Group == "overlap",]
deg_label_gene <- data.frame(gene = c(up_label$Drug_name),label = c(up_label$Drug_name))
DEG_data$gene <- DEG_data$Drug_name
DEG_data <- merge(DEG_data,deg_label_gene,by = 'gene',all = T)

#添加特定基因label
ggscatter(DEG_data,x = "gene_expr_sum",y = "IC-50_Z-score",
          color = "Group", #label = DEG_data$label,
          repel = T, ylab = "IC-50_Z-score", size = 2) + 
  theme_base()+
  theme(element_line(size = 0),element_rect(size = 1.5))+ #坐标轴线条大小设置
  scale_y_continuous(limits = c(-4,4))+
  scale_x_continuous(limits = c(-60,3))+
  geom_hline(yintercept = 2,linetype = "dashed")+
  geom_vline(xintercept = c(0),linetype = "dashed")
#+geom_vline(xintercept = c(-0.5,0.5),linetype = "dashed")

a <- plot_data
a[,11] <- as.character(a[,11])
rownames(a) <- a[,1]
pheatmap::pheatmap(a[,2:10],display_numbers = T)


gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549[,3] <- tolower(gdsc_A549[,3])
gdsc_A549 <- gdsc_A549[!duplicated(gdsc_A549[,3]),]
colnames(c)[1] <- colnames(gdsc_A549)[3]
gdsc_A549 <- merge(gdsc_A549[,3:5],c,by=colnames(gdsc_A549)[3],all=F)
write.csv(c,'result/luad_drug_screen_3.csv')
write.csv(gdsc_A549,'result/luad_drug_info_3.csv')



##计算基因表达与细胞死亡的相关性
library(Hmisc)
colnames(plot_data)[11] <- 'cell_survival'
cell_gene_drug_cor <- rcorr(as.matrix(plot_data[,2:11]),type = 'spearman')
cell_gene_drug_cor <- rcorr(as.matrix(luad[,2:11]),type = '')
a <- cell_gene_drug_cor[[1]]
pheatmap::pheatmap(a,display_numbers = T)


a <- cell_gene_drug_cor[[3]]
cell_gene_drug_cor <- rcorr(as.matrix(luad[,2:11]),type = 'spearman')
a <- cell_gene_drug_cor[[1]]
a <- cell_gene_drug_cor[[3]]
b <- expression[[2]][rownames(expression[[2]])%in%b,]
b <- t(b)
library(Hmisc)
b <- rcorr(b,type = 'spearman')
c <- b[[1]]

b <- rcorr(as.matrix(cell_line_expr_drug[[2]][[3]][,2:11]),type = 'spearman')[[1]]

##通路test
library(clusterProfiler)
b <- surv_sig_inter[[8]][surv_sig_inter[[8]][,1]%in%'BUB1B',3]
b <- surv_sig_inter[[8]][surv_sig_inter[[8]][,1]%in%b,3]
a <- bitr(b,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
barplot(a)

a <- expression[[8]][rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1],]
b <- rcorr(t(a),type = 'spearman')
pheatmap::pheatmap(b[[1]])
bk = unique(c(seq(-1,1, length=200)))
a <- pheatmap::pheatmap(a)
a <- pheatmap::pheatmap(b[[1]],breaks = bk,show_rownames = T,
                        c(colorRampPalette(c("navy", "white"))(180),colorRampPalette(c("white","red"))(20)),
                        clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)


####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 1:15) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:11,],expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%c('GZMA','GZMB','PRF1','PRF2'),])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:10,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name


sig_gene_immune_analysis_plot <- list()
bk = unique(c(seq(-1,1, length=200)))
for (i in 1:15) {
  a <- sig_gene_immune_analysis[[i]][-11,]
  sig_gene_immune_analysis_plot[[i]] <- pheatmap::pheatmap(a,breaks = bk,show_rownames = T,
                                                           color = c(colorRampPalette(c("navy", "white"))(70),colorRampPalette(c("white"))(60),colorRampPalette(c("white","red"))(70)),
                                                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
}
names(sig_gene_immune_analysis_plot) <- cancer_name
##保存图片
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/immune',sep = ''))
  tryCatch({
    a <- sig_gene_immune_analysis_plot[[j]]
    save_pheatmap_pdf(a,width=((50/268)*(ncol(b)+8))*1.8, 
                      height =((50/268)*(nrow(b)+8))*1.8, 
                      paste('result/',cancer_name[j],'/immune/',cancer_name[j],'_immune.pdf',sep = ''))
  }, error = function(e) {print(cancer_name[[j]])})
}

for (i in 1:15) {
  sig_gene_immune_analysis_plot[[i]]
}





##chemokine的表达与转录因子调控
chemokine <- read.csv('/database/chemokine_data/target_cell_target_cell.csv',header = F)
colnames(chemokine) <- c('target_cell','chemokine')
a <- str_split(chemokine[,2],' ',simplify = T)
chemokine <- cbind(chemokine[,1],a)
a <- as.list(chemokine[,1])
names(a) <- chemokine[,1]
for (i in 1:length(a)) {
  b <- chemokine[i,2:ncol(chemokine)]
  b <- b[b!='']
  b <- b[!duplicated(b)]
  a[[i]] <- b
}
chemokine <- a
cell_chem_expr <- expr_data_raw[[2]]
cell_chem_cor <- list()
for (i in 1:10) {
  cell_chem_cor[[i]] <- cell_chem_expr[rownames(cell_chem_expr)%in%c(chemokine[[i]],names(chemokine)[i],surv_sig_dgree[[2]][1:10,1]),]
}
names(cell_chem_cor) <- names(chemokine)
for (i in 1:10) {
  cell_chem_cor[[i]] <- rcorr(t(cell_chem_cor[[i]]),type = 'spearman')
  cell_chem_cor[[i]] <- cell_chem_cor[[i]][[1]]
  cell_chem_cor[[i]] <- as.data.frame(cell_chem_cor[[i]])
  cell_chem_cor[[i]] <- cell_chem_cor[[i]][colnames(cell_chem_cor[[i]])%in%chemokine[[i]],colnames(cell_chem_cor[[i]])%in%c(names(chemokine)[i],surv_sig_dgree[[2]][1:10,1])]
}
pheatmap::pheatmap(cell_chem_cor[[8]])

human_TF <- read.table('/database/TRRUST/transcipt_factor_rawdata.human.tsv',sep = '\t')
colnames(human_TF) <- c('TF','Target','Mode of Regulation','References(PMID)')
CD8_T_BRCA_chemokine_TF <- cell_chem_cor[[8]][cell_chem_cor[[8]][,1]>=0.5,]
a <- human_TF[human_TF[,2]%in%rownames(CD8_T_BRCA_chemokine_TF),]
CD8_T_BRCA_chemokine_TF <- expr_data_raw[[2]][rownames(expr_data_raw[[2]])%in%c(a[,1],a[,2]),]
CD8_T_BRCA_chemokine_TF <- rcorr(t(CD8_T_BRCA_chemokine_TF),type = 'spearman')
CD8_T_BRCA_chemokine_TF <- CD8_T_BRCA_chemokine_TF[[1]]
CD8_T_BRCA_chemokine_TF <- as.data.frame(CD8_T_BRCA_chemokine_TF)
CD8_T_BRCA_chemokine_TF <- CD8_T_BRCA_chemokine_TF[rownames(CD8_T_BRCA_chemokine_TF)%in%a[,1],colnames(CD8_T_BRCA_chemokine_TF)%in%a[,2]]
pheatmap::pheatmap(CD8_T_BRCA_chemokine_TF)


a <- expression[[2]][rownames(expression[[2]])%in%surv_sig_dgree[[2]][1,1],]
for (i in 2:nrow(surv_sig_dgree[[2]])) {
  a <- rbind(a,expression[[2]][rownames(expression[[2]])%in%surv_sig_dgree[[2]][i,1],])
}
a <- log2(a+1)
pheatmap::pheatmap(a,cluster_rows = F)


####药物筛选
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA



##画韦恩图
venn.plot <- venn.diagram(x = list(cMAP_A549=All_drug,GDSC_A549=gdsc_A549_drug),
                          category.names = c('cMAP_A549','GDSC_A549'),
                          filename = NULL,
                          scaled = F,
                          height = 1500, width = 1500, resolution =600,
                          alpha=c(0.6, 0.6),
                          fill=c(colors()[616], colors()[38]), 
                          lwd=rep(1,2), cex=0.45, 
                          fontfamily = "serif", fontface = "bold",
                          cat.dist=c(-0.07, -0.07),
                          output=TRUE,
                          area.vector = 0,
                          cat.pos=c(280, 80), #位置
                          cat.cex=0.45)##画韦恩图

pdf("result/Figure/luad_drug_screen_5.pdf")
grid.draw(venn.plot)
dev.off()
##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
pheatmap::pheatmap(luad_overlap[,2:10],clustering_method = 'ward.D2')
bk = unique(c(seq(-4,4, length=200)))
hotmap <- pheatmap::pheatmap(luad_overlap[,2:10],breaks = bk,show_rownames = F,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = T,cluster_rows = T,cluster_cols = T)
cluster <- hotmap$tree_row
plot(cluster,hang = -1,cex=0.6,axes=FALSE,ann=FALSE)
cut <- as.data.frame(cutree(cluster,2))
drug_inhibit_gene <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==1],]
for (i in 1:nrow(drug_inhibit_gene)) {
  drug_inhibit_gene[i,11] <- min(drug_inhibit_gene[i,11:13][!is.na(drug_inhibit_gene[i,11:13])])
}
colnames(drug_inhibit_gene)[c(1,11)] <- c('drug_name','IC50_Z-score')
write.csv(drug_inhibit_gene[,1:10],'result/Figure/table1_effect_drug_gene_res.csv',row.names = T)
drug_inhibit_gene_name <- drug_inhibit_gene[!duplicated(drug_inhibit_gene[,1]),c(1,11)]
write.csv(drug_inhibit_gene_name,'result/Figure/table2_effect_drug_name.csv',row.names = F)
pheatmap::pheatmap(rcorr(as.matrix(drug_inhibit_gene[,2:10]))[[1]])##画相关性图

##绘制显著基因表达相关性热图
a <- expression[[8]]
a <- t(a[rownames(a)%in%surv_sig_dgree[[8]][1:10,1],])
a <- rcorr(a,type = 'spearman')[[1]]
pheatmap::pheatmap(a)

##绘制散点图
A549_drug_gdsc1 <- read.csv('result/Figure/table3_from_GDSC1_A549.csv')
A549_drug_gdsc1[,6] <- 'GDSC1'
A549_drug_gdsc1[,7] <- rownames(A549_drug_gdsc1)
A549_drug_gdsc2 <- read.csv('result/Figure/table3_from_GDSC2_A549.csv')
A549_drug_gdsc2[,6] <- 'GDSC2'
A549_drug_gdsc2[,7] <- rownames(A549_drug_gdsc2)
a <- rbind(A549_drug_gdsc1[,c(7,4,6)],A549_drug_gdsc2[,c(7,4,6)])
colnames(a) <- c('num','Z_score','version')
a[,1] <- as.numeric(a[,1])

ggplot(a, aes(x=num, y=Z_score,color=version)) + 
  ggtitle("GDSC_drug_screen")+
  geom_point(size=0.8,stroke =1)+
  theme_bw()+
  geom_hline(yintercept = c(-2,2),linetype = "dashed")+
  annotate('text',x=150,y=2.2,label=expression('resistant'),size=4,color='red')+
  annotate('text',x=50,y=-2.2,label=expression('sensitive'),size=4,color='blue')##画散点图5cm*8cm

####乳腺癌层次聚类与生存分析
####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:9,1]),]))
#data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
a <- rbind(data[rownames(data)%in%rownames(result)[result[,1]==1],],
           data[rownames(data)%in%rownames(result)[result[,1]==2],],
           data[rownames(data)%in%rownames(result)[result[,1]==3],])
a <- log2(t(a)+1)
brca_gene_cluster <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,clustering_method = 'ward.D2', color = c(colorRampPalette(c("navy", "white"))(60),colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                                        cluster_cols = F,cluster_rows = T,annotation_col = result)


paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- lifetime[[2]]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'Z'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('BRAD_siggene_cluster'),                 # 设置图例标题
           #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)

##亚型生存曲线
all_subtype <- read.table('/database/TCGA/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('BRAD_siggene_cluster'),                 # 设置图例标题
           #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)











##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,7]=='X',6],],data[rownames(data)%in%b[b[,7]=='Y',6],],data[rownames(data)%in%b[b[,7]=='Z',6],])
annotation_col <- rbind(b[b[,7]=='X',6:7],b[b[,7]=='Y',6:7],b[b[,7]=='Z',6:7])
annotation_col <- as.data.frame(annotation_col[,-1])
colnames(annotation_col)[1] <- c('cluster')
rownames(annotation_col) <- rownames(hotmap)
#ann_colors = list(cluster = c(X = "#7570B3", Y = "#E7298A")#连续数值型分组可设置成渐变  
#                   ) 
hotmap <- log10(hotmap+1)
hotmap <- t(hotmap)
bk = unique(c(seq(0,4, length=200)))
pheatmap::pheatmap(hotmap,cluster_col = F,show_colnames = F,clustering_method = 'ward.D2',breaks = bk,
                   color = c(colorRampPalette(c("navy", "white"))(60),colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                   annotation_colors = ann_colors,cluster_cols = F,annotation_col = annotation_col)
##相关性情况
immune_gene <- read.table('result/BRCA/immune_gene.txt')
other_gene <- read.table('result/BRCA/other_gene.txt')
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(surv_sig_inter[[j]][,1],surv_sig_inter[[j]][,3])[!duplicated(c(surv_sig_inter[[j]][,1],surv_sig_inter[[j]][,3]))]),]))
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(surv_sig_inter[[j]][,1])),]))
data <- data[,colnames(data)%in%c(immune_gene[,1],other_gene[,1])]
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(rownames(surv_data_sig[[2]][[1]]))),]))
a <- rcorr(data)
a <- as.data.frame(a[[1]])
immune_gene <- immune_gene[immune_gene[,1]%in%surv_sig_inter[[j]][,1],]
immune_gene <- as.data.frame(immune_gene)
immune_gene[,2] <- 'immune'

other_gene <- other_gene[other_gene[,1]%in%surv_sig_inter[[j]][,1],]
other_gene <- as.data.frame(other_gene)
other_gene[,2] <- 'other'
colnames(other_gene) <- colnames(immune_gene)
annotation_col <- rbind(immune_gene,other_gene)

b <- annotation_col[,1]
annotation_col <- as.data.frame(annotation_col[,2])
colnames(annotation_col)[1] <- c('gene_type')
rownames(annotation_col) <- b
pheatmap::pheatmap(a,treeheight_col = 0,show_rownames = F,show_colnames = F)
pheatmap::pheatmap(data,show_colnames = F,clustering_method = 'ward.D2', color = c(colorRampPalette(c("navy", "white"))(60),colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                   annotation_colors = ann_colors,cluster_cols = T,annotation_col = annotation_col)

data <- as.data.frame(data)
a <- data
for (i in 1:ncol(data)) {
  a[data[,i]>=median(data[,i]),i] <- 1
  a[data[,i]<median(data[,i]),i] <- 0
}
brca_gene_cluster <- pheatmap::pheatmap(a,show_colnames = T,show_rownames = F,clustering_method = 'ward.D2', color = c(colorRampPalette(c("navy", "white"))(60),colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                                        annotation_colors = ann_colors,cluster_cols = T,annotation_col = annotation_col)
result <- cutree(brca_gene_cluster$tree_col,k=4)#分类
result <- as.data.frame(result)
result <- cbind(rownames(result),result)
brca_gene_cluster <- pheatmap::pheatmap(a,show_colnames = T,show_rownames = F,clustering_method = 'ward.D2', color = c(colorRampPalette(c("navy", "white"))(60),colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                                        annotation_colors = ann_colors,cluster_cols = T,annotation_col = result)
library(clusterProfiler) #clusterProfiler的主体
library(org.Hs.eg.db) #人类的参考基因组数据包
library(stringr) #处理表格数据的包
library(msigdbr) #对GSEA官网的通路数据
brca_gene_pathway_kegg <- list()
brca_gene_pathway_go <- list()
for (i in 1:6) {tryCatch({
  brca_gene <- bitr(result[result[,2]==i,1],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                    toType = c('ENTREZID'), #totype指需要转换成的ID类型
                    OrgDb='org.Hs.eg.db')
  brca_gene_pathway_kegg[[i]] <- enrichKEGG(brca_gene[,2], #数据源
                                            organism = 'hsa', #物种
                                            keyType = 'kegg', #"kegg"/'ncbi-geneid'/'ncib-proteinid'/'uniprot'之一，KEGG就写kegg
                                            pvalueCutoff = 1,
                                            pAdjustMethod = 'BH',#P值校正方法
                                            qvalueCutoff = 1)
  brca_gene_pathway_go[[i]] <- enrichGO(brca_gene[,2], #数据源
                                        pvalueCutoff = 0.05, #P值阈值
                                        qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                        OrgDb = org.Hs.eg.db, #人类参考基因组
                                        ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                        readable = TRUE) #是否将基因ID转换为基因名
}, error = function(e) {print('error')})
}

####BRCA的分子分型与显著基因表达特征
immune_gene <- read.table('result/BRCA/immune_gene.txt')
other_gene <- read.table('result/BRCA/other_gene.txt')
immune_gene <- immune_gene[immune_gene[,1]%in%surv_sig_inter[[j]][,1],]
immune_gene <- as.data.frame(immune_gene)
immune_gene[,2] <- 'immune'
other_gene <- other_gene[other_gene[,1]%in%surv_sig_inter[[j]][,1],]
other_gene <- as.data.frame(other_gene)
other_gene[,2] <- 'other'
colnames(other_gene) <- colnames(immune_gene)
annotation_col <- rbind(immune_gene,other_gene)
b <- annotation_col[,1]
annotation_col <- as.data.frame(annotation_col[,2])
colnames(annotation_col)[1] <- c('gene_type')
rownames(annotation_col) <- b

all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(BRCA_data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

BRCA_data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(surv_sig_inter[[j]][,1],surv_sig_inter[[j]][,3])[!duplicated(c(surv_sig_inter[[j]][,1],surv_sig_inter[[j]][,3]))]),]))
BRCA_data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(surv_sig_inter[[j]][,1])),]))
BRCA_data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(surv_sig_dgree[[2]][1:10,1])),]))
BRCA_data <- BRCA_data[rownames(BRCA_data)%in%rownames(annotation_row),]
BRCA_data <- as.data.frame(BRCA_data)
BRCA_data <- log2(BRCA_data+1)
a <- BRCA_data
for (i in 1:ncol(BRCA_data)) {
  a[BRCA_data[,i]>=median(BRCA_data[,i]),i] <- 1
  a[BRCA_data[,i]<median(BRCA_data[,i]),i] <- 0
}

brca_gene_cluster <- pheatmap::pheatmap(t(a),show_colnames = T,show_rownames = F,clustering_method = 'ward.D2', 
                                        color = c(colorRampPalette(c("navy", "white"))(60),colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                                        annotation_colors = ann_colors,cluster_cols = T,annotation_col = annotation_col,annotation_row = annotation_row)
result <- cutree(brca_gene_cluster$tree_row,k=2)#分类
result <- as.data.frame(result)
result <- cbind(rownames(result),result)
b <- lifetime[[2]]
b <- b[b[,6]%in%result[,1],]
b[b[,6]%in%rownames(result)[result[,2]==1],7] <- 'X'
b[b[,6]%in%rownames(result)[result[,2]==2],7] <- 'Y'
b[b[,6]%in%rownames(result)[result[,2]==3],7] <- 'Z'

c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('BRAD_siggene_cluster'),                 # 设置图例标题
           #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)

brca_gene_cluster <- pheatmap::pheatmap(BRCA_data[,colnames(BRCA_data)%in%other_gene[,1]],show_colnames = T,show_rownames = F,clustering_method = 'ward.D2', 
                                        color = c(colorRampPalette(c("navy", "white"))(60),colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                                        annotation_colors = ann_colors,cluster_cols = T,annotation_col = annotation_col,annotation_row = annotation_row)



a












##生存分析分组状况
#聚类分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('BRAD_siggene_cluster'),                 # 设置图例标题
           #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)



##BRCA对5年生存的预测
for (j in 2) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[2]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    #expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,10,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
      #AUC_max_time <- 3650
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                             conf.int = F,    # 显示置信区间
                                             pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                             add.all = F,     # 添加总患者生存曲线
                                             palette = "hue",    # 自定义调色板
                                             #surv.median.line = "hv",     # 添加中位生存时间线
                                             risk.table = TRUE,             # 添加风险表
                                             xlab = "Follow up time(d)", # 指定x轴标签
                                             legend = c(0.8,0.9),         # 指定图例位置
                                             title = c('LUAD_predict'),                 # 设置图例标题
                                             #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                             break.x.by = 365,# 设置x轴刻度间距
                                             pval.method=T)},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               #surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_predict'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)})
  }, error = function(e) {print('error')})
}#这是全部用来训练，下面是70%训练，30%验证
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证

train_sample <- sample(1:1089,ceiling(0.7*1089))
BRCA_train <- expression[[2]][,train_sample]
for (j in 2) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[2]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- BRCA_train[rownames(BRCA_train)%in%c(surv_sig_inter[[2]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    a <- multi_variate_cox_2$concordance
    
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,10,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
      #AUC_max_time <- 1825
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
      cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                             conf.int = F,    # 显示置信区间
                                             pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                             add.all = F,     # 添加总患者生存曲线
                                             palette = "hue",    # 自定义调色板
                                             surv.median.line = "hv",     # 添加中位生存时间线
                                             risk.table = TRUE,             # 添加风险表
                                             xlab = "Follow up time(d)", # 指定x轴标签
                                             legend = c(0.8,0.9),         # 指定图例位置
                                             title = c('LUAD_predict'),                 # 设置图例标题
                                             #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                             break.x.by = 365,# 设置x轴刻度间距
                                             pval.method=T)},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_predict'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)})
  }, error = function(e) {print('error')})
}#这是全部用来训练，下面是70%训练，30%验证
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##训练数据集
BRCA_ver <- expression[[2]][,!1:1089%in%train_sample]
for (j in 2) {
  ##计算基因模型风险评分
  tryCatch({
    predict_effect_ver[[j]] <- list()
    gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
    expr_data <- BRCA_ver
    rownames(expr_data) <- gsub('-','_',rownames(expr_data))
    expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    ###
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
    
    #calculate the risk score of each sample.
    candidate_genes_for_cox2 <- gene_list
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,10,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    ifelse(AUC_max>0.5,{
      #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
      AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
      AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
      AUC_max_time <- AUC_max_time[length(AUC_max_time)]
      AUC_max_time <- 1825
      for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
      #find the optimal cutoff value within the ROC curve of the optimal time point.
      optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
      #cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
      high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
      high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
      high_low[high_low == FALSE] <- 'low'
      risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
      predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
      gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
      #KM_plot generation.
      library('survminer')
      #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
      risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
      risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
      fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
      predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                                 conf.int = F,    # 显示置信区间
                                                 pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                                 add.all = F,     # 添加总患者生存曲线
                                                 palette = "hue",    # 自定义调色板
                                                 surv.median.line = "hv",     # 添加中位生存时间线
                                                 risk.table = TRUE,             # 添加风险表
                                                 xlab = "Follow up time(d)", # 指定x轴标签
                                                 legend = c(0.8,0.9),         # 指定图例位置
                                                 title = c('LUAD_predict'),                 # 设置图例标题
                                                 #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                                 break.x.by = 365,# 设置x轴刻度间距
                                                 pval.method=T)},
      {
        AUC_max <- min(for_multi_ROC$AUC)##另一个情况
        AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
        AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
        AUC_max_time <- AUC_max_time[length(AUC_max_time)]
        AUC_max_time <- 1825
        for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
        #find the optimal cutoff value within the ROC curve of the optimal time point.
        optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
        cut.off <- optimal_time_ROC_df$Cut_values[which.min(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
        high_low <- (risk_score_table_multi_cox2$total_risk_score < cut.off)##ROC曲线在对角线上方是>，下方是<
        high_low[high_low == TRUE] <- 'low'####ROC曲线在对角线上方是high，下方是low
        high_low[high_low == FALSE] <- 'high'
        risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
        predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
        gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
        #KM_plot generation.
        #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
        risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
        risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
        fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
        ggsurvplot(fit_km,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,1),         # 指定图例位置
                   title = c('LUAD_siggene_cluster'),                 # 设置图例标题
                   #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)})
  }, error = function(e) {print('error')})
}








###################################从头开始画图
####读取算到的数据

##extract top1000
for (i in 1:15) {
  surv_sig_inter[[i]] <- read.csv(paste('result/',cancer_name[i],'/inter_probality/surv_sig_inter_new.csv',sep = ''),header = T)
  a <- surv_sig_inter[[i]][order(surv_sig_inter[[i]][,2],decreasing = T)[1000],2]
  surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]>=a,]
}
# surv_sig_inter[[3]] <- read.csv('result/CESC/inter_probality/surv_sig_inter_new.csv')
for (i in 1:15) {
  a <- surv_sig_inter[[i]][,1][!duplicated(surv_sig_inter[[i]][,1])]
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- length(which(surv_sig_inter[[i]][,1]==a[x]))
  }
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
  write.csv(surv_sig_dgree[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_dgree_new.csv',sep = ''),quote = F,row.names = F)
}
########figure1
##
##双柱状图
##获取批量生存分析的每个基因标签
library(survival)
library(survminer)
HR_all <- list()
surv_p_all <- list()
for (x in 1:15) {
  HR_all[[x]] <- data.frame()
  surv_p_all[[x]] <- data.frame()
  b <- lifetime_all[[x]][lifetime_all[[x]][,2] %in% colnames(expression[[x]]),]
  for (j in 1:nrow(expression[[x]])) {
    tryCatch({a <- expression[[x]][j,]
    b[b[,2]%in%colnames(expression[[x]])[which(a <= median(as.numeric(a)))],7] <- 'low'
    b[b[,2]%in%colnames(expression[[x]])[which(a > median(as.numeric(a)))],7] <- 'high'
    c <- survdiff(Surv(b[,3],as.numeric(b[,4]))~b[,7], data=b)
    surv_p_all[[x]][j,1] <- 1-pchisq(c$chisq,1)
    HR_all[[x]][j,1] <- (c$obs[2]/c$exp[2])/(c$obs[1]/c$exp[1])},warning = function(w){
      print('warning')}, error = function(e){surv_p_all[[x]][j,1] <- 1
      HR_all[[x]][j,1] <- 1
      print('error')})
  }
  rownames(surv_p_all[[x]]) <- rownames(expression[[x]])
  rownames(HR_all[[x]]) <- rownames(expression[[x]])
}
names(surv_p_all) <- cancer_name
names(HR_all) <- cancer_name
for (i in 1:15) {
  surv_p_all[[i]][is.na(surv_p_all[[i]][,1]),1] <- 1
  surv_p_all[[i]][surv_p_all[[i]][,1]<0.05,2] <- 'sig'
  surv_p_all[[i]][surv_p_all[[i]][,1]>=0.05,2] <- 'non-sig'
}

##画柱状图
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
A <- surv_data[[8]][[1]]
A$group <- surv_p_all[[8]][,2]
A$Gene <- rownames(A)
A <- pivot_longer(data = A,cols = 1:(dim(A)[2]-2),
                  names_to = "Type",values_to = "count")
str_sort(unique(A$Type),numeric = T)
A$Type <- factor(A$Type, levels = str_sort(unique(A$Type),numeric = T))
A$Type <- as.factor(A$Type)
A$Type <- fct_inorder(A$Type)
A$group <- as.factor(A$group)
A$group <- fct_inorder(A$group)

ggplot(A, aes(fill=group, y=count, x=Type))+
  geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
  theme_classic(base_size = 12)+
  theme(legend.direction = "horizontal", legend.position = "top")+
  labs(title = "", y="Surv-sig rate ", x = "Sample Size")+
  stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
               width = 0.5,position = position_dodge(1))+
  scale_y_continuous(limits = c(0,1),expand = c(0,0))+
  theme(axis.text.x = element_text(size = 12))+
  theme(axis.text.y = element_text(size = 12))+
  theme(axis.title = element_text(size = 14))

##画折线图
sig_gene_num <- data.frame()
sig_gene_max <- data.frame()
sig_gene_add <- data.frame()
for (i in 1:15) {
  for (j in 1:10) {
    sig_gene_num[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8))
    sig_gene_max[i,j] <- max(surv_data[[i]][[1]][,j])
    ifelse(j==1,sig_gene_add[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8)),
           sig_gene_add[i,j] <- (length(which(surv_data[[i]][[1]][,j]>=0.8))-sig_gene_add[i,j-1]))
  }
}
rownames(sig_gene_num) <- cancer_name
colnames(sig_gene_num) <- c(seq(0.1,1,0.1))
rownames(sig_gene_max) <- cancer_name
colnames(sig_gene_max) <- c(seq(0.1,1,0.1))
rownames(sig_gene_add) <- cancer_name
colnames(sig_gene_add) <- c(seq(0.1,1,0.1))

sig_gene_num$cancer_name <- rownames(sig_gene_num)
sig_gene_num <- pivot_longer(data = sig_gene_num,cols = 1:(dim(sig_gene_num)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_num$cancer_name <- factor(sig_gene_num$cancer_name, levels = str_sort(unique(sig_gene_num$cancer_name),numeric = T))
sig_gene_num$cancer_name <- as.factor(sig_gene_num$cancer_name)

sig_gene_max$cancer_name <- rownames(sig_gene_max)
sig_gene_max <- pivot_longer(data = sig_gene_max,cols = 1:(dim(sig_gene_max)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_max$cancer_name <- factor(sig_gene_max$cancer_name, levels = str_sort(unique(sig_gene_max$cancer_name),numeric = T))
sig_gene_max$cancer_name <- as.factor(sig_gene_max$cancer_name)

sig_gene_add$cancer_name <- rownames(sig_gene_add)
sig_gene_add <- pivot_longer(data = sig_gene_add,cols = 1:(dim(sig_gene_add)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_add$cancer_name <- factor(sig_gene_add$cancer_name, levels = str_sort(unique(sig_gene_add$cancer_name),numeric = T))
sig_gene_add$cancer_name <- as.factor(sig_gene_add$cancer_name)

ggplot(sig_gene_max, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  theme_base()+
  geom_line(size=1)#size是线的宽度
ggplot(sig_gene_add, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  geom_line(size=1)#size是线的宽度
####fig2C排版
####富集通路
library(clusterProfiler)
library(stringr)

cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- apply(surv_data[[j]][[1]], 2, max)
  b <- surv_data[[j]][[1]][,which.max(a[a!=0])]
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which.max(a[a!=0])] >= 0.8),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- rownames(surv_data_sig[[i]][[1]])
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}
names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
sig_pathway_plot_all <- surv_sig_pathway
sig_pathway_plot_all@compareClusterResult <- sig_pathway_plot_all@compareClusterResult[sig_pathway_plot_all@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
a <- sig_pathway_plot_all@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(2,15,7,8,6,11,5,3,9,1)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_all
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(2,15,7,8,6,11,5,3,9,1)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(2,15,7,8,6,11,5,3,9,1)])
dotplot(a,showCategory=5,includeAll=TRUE,label_format = 70)

##对网络top10进行富集
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- surv_sig_dgree[[i]][1:10,1]
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}

names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
##提取指定层次的通路进行绘制通路图
sig_pathway_plot_top10 <- surv_sig_pathway
sig_pathway_plot_top10@compareClusterResult <- sig_pathway_plot_top10@compareClusterResult[sig_pathway_plot_top10@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_top10,showCategory=5,includeAll=TRUE,label_format = 70)
a <- sig_pathway_plot_top10@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(2,15,7,8,6)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_top10
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(2,15,7,8,6)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(2,15,7,8,6,11,5,3,9,1)])
dotplot(a,showCategory=5,includeAll=TRUE,label_format = 70)

######fig3的修改
####Depmap分析
##read database
cell_line_crispr <- read.csv('/database/depmap/CRISPR_(DepMap_21Q4_Public+Score,_Chronos).csv')
RNAi_raw <- read.csv('/database/depmap/RNAi_(Achilles+DRIVE+Marcotte,_DEMETER2).csv')
crispr_raw <- read.csv('/database/depmap/CRISPR_gene_effect_after_process.csv',header = T,row.names = 1)
#从此处接着运行
cell_line <- cell_line_crispr
cell_line <- cell_line[,1:6]
RNAi <- RNAi_raw
rownames(RNAi) <- RNAi[,1]
RNAi <- RNAi[,-1:-6]
crispr <- crispr_raw
cancer_name_crispr_RNAi <- read.csv('cancer_name_crispr_rnai.csv',header = F)
##提取相关crispr数据
sig_gene_expr_plot <- list()
sig_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr/high_dgree',sep = ''))
  tryCatch({
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    sig_gene_expr_plot[[j]] <- a
    sig_gene_expr_crispr[[j]] <- b
    save_pheatmap_pdf(a,width=((50/268)*(ncol(b)+8))*1.8, 
                      height =((50/268)*(nrow(b)+8))*1.8, 
                      paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_crispr.pdf',sep = ''))
  }, error = function(e) {print('error')})
}
##提取相关RNAi数据
sig_gene_expr_RNAi_plot <- list()
sig_gene_expr_RNAi <- list()
for (j in 1:length(cancer_name)) {
  dir.create(paste('result/',cancer_name[j],'/crispr/high_dgree',sep = ''))
  tryCatch({
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(RNAi[,which(colnames(RNAi)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    b <- b[,order(colnames(b))]
    cancer_cell_line <- cancer_cell_line[cancer_cell_line[,1]%in%colnames(b),]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0, length=100)))
    b <- as.matrix(b)
    b[is.na(b)] <- 0
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    sig_gene_expr_RNAi_plot[[j]] <- a
    sig_gene_expr_RNAi[[j]] <- b
    save_pheatmap_pdf(a,width=(50/268)*(ncol(b)+8)*1.8, 
                      height = (50/268)*(nrow(b)+8)*1.8, 
                      paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_RNAi.pdf',sep = ''))
  }, error = function(e) {print('error')})
}
names(sig_gene_expr_plot) <- cancer_name
names(sig_gene_expr_crispr) <- cancer_name
names(sig_gene_expr_RNAi_plot) <- cancer_name
names(sig_gene_expr_RNAi) <- cancer_name

#Depmap分析有丝分裂通路中的基因对细胞生存的影响
ref_path_mitotic <- read.csv('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/GO0000278_mitotic_cell_cycle.csv',header = F)
ref_path_mitotic <- as.matrix(ref_path_mitotic[,1])
ref_path_mitotic <- as.vector(ref_path_mitotic)
a <- read.csv('reference/cell_cycle_mitotic.csv',header = T)
a <- as.matrix(a[,1])
a <- as.vector(a)
ref_path_mitotic <- c(ref_path_mitotic,a)
ref_path_mitotic <- ref_path_mitotic[!duplicated(ref_path_mitotic)]

mitotic_gene_expr_plot <- list()
mitotic_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  tryCatch({
    # a <- surv_sig_dgree[[j]][1:10,1][surv_sig_dgree[[j]][1:10,1]%in%ref_path_mitotic]
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    mitotic_gene_expr_plot[[j]] <- a
    mitotic_gene_expr_crispr[[j]] <- b
    names(mitotic_gene_expr_plot)[j] <- cancer_name[j]
    names(mitotic_gene_expr_crispr)[j] <- cancer_name[j]
  }, error = function(e) {print(cancer_name[[j]])})
}

a <- mitotic_gene_expr_crispr[[6]]##LGG
b <- apply(a, 1, mean)
a <- a[order(b,decreasing = T),]
annotation_row <- as.data.frame(rownames(a))
rownames(annotation_row) <- annotation_row[,1]
annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
colnames(annotation_row) <- 'function'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
bk = unique(c(seq(-1.5,0, length=100)))
ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,
                   color = c(colorRampPalette(c("navy", "white"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                   cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                   annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm

a <- mitotic_gene_expr_crispr[[7]]##LIHC
b <- apply(a, 1, mean)
a <- a[order(b,decreasing = T),]
annotation_row <- as.data.frame(rownames(a))
rownames(annotation_row) <- annotation_row[,1]
annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
colnames(annotation_row) <- 'function'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
bk = unique(c(seq(-1.5,0, length=100)))
ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,
                   color = c(colorRampPalette(c("navy", "white"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                   cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                   annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm

a <- mitotic_gene_expr_crispr[[8]]##LUAD
b <- apply(a, 1, mean)
a <- a[order(b,decreasing = T),]
annotation_row <- as.data.frame(rownames(a))
rownames(annotation_row) <- annotation_row[,1]
annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
colnames(annotation_row) <- 'function'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
bk = unique(c(seq(-1.5,0, length=100)))
ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,
                   color = c(colorRampPalette(c("navy", "white"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                   cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                   annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm

####fig4_subtype
####使用显著基因对LUAD进行分类，并与TCGA三种亚型进行分类
subtype <- read.csv('/database/文献/肺癌的分子分型/肺腺癌/luad_subtype.csv')
subtype <- subtype[,c('Tumor.ID','expression_subtype')]
subtype[,2] <- subtype[,2]
subtype[,2][subtype[,2]=='prox.-inflam'] <- 'PI'
subtype[,2][subtype[,2]=='prox.-prolif.'] <- 'PP'
luad_subtype <- lifetime[[8]]
colnames(subtype)[1] <- 'case_id'
luad_subtype <- merge(luad_subtype,subtype,by = 'case_id',all=F)

####LUAD层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- luad_subtype
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'ML'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'MH'

##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,8]=='PI',6],],data[rownames(data)%in%b[b[,8]=='PP',6],],data[rownames(data)%in%b[b[,8]=='TRU',6],])
hotmap <- rbind(hotmap[rownames(hotmap)%in%b[b[,7]=='ML',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MM',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MH',6],])
annotation_col <- rbind(b[b[,7]=='ML',7:8],b[b[,7]=='MM',7:8],b[b[,7]=='MH',7:8])
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster','subtype')
rownames(annotation_col) <- c(b[b[,7]=='ML',6],b[b[,7]=='MM',6],b[b[,7]=='MH',6])
ann_colors = list(subtype = c(PI="#ED5163", PP="#4498F2",TRU="#72FCA0"), #连续数值型分组可设置成渐变  
                  cluster = c(ML = "blue",MM = "#F2CA20", MH = "#E24A0E")) 
hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                   annotation_colors = ann_colors)#4cm*8cm

##生存分析分组状况
#聚类分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('LUAD_siggene_cluster'),                 # 设置图例标题
           #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)
#TCGA分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,8], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,8], data = b)
ggsurvplot(c,            # 创建的拟合对象
           conf.int = F,    # 显示置信区间
           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
           add.all = F,     # 添加总患者生存曲线
           palette = "hue",    # 自定义调色板
           surv.median.line = "hv",     # 添加中位生存时间线
           risk.table = TRUE,             # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75),         # 指定图例位置
           title = c('LUAD_siggene_cluster'),                 # 设置图例标题
           legend.labs = c('PI','PP','TRU'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
           break.x.by = 365,# 设置x轴刻度间距
           pval.method=T)

##画柱状图看统计情况堆叠柱状图
library(tidyr)
subtype_sum <- data.frame()
for (i in 1:3) {
  subtype_sum[1,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='PI'))
  subtype_sum[2,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='PP'))
  subtype_sum[3,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='TRU'))
}
colnames(subtype_sum) <- c('MM','ML','MH')
rownames(subtype_sum) <- c('PI','PP','TRU')
subtype_sum <- apply(subtype_sum, 2, function(x){x/sum(x)})
subtype_sum <- as.data.frame(subtype_sum)
subtype_sum[1:3,4] <- rownames(subtype_sum)
colnames(subtype_sum)[4] <- 'subtype'
subtype_sum <- pivot_longer(data = subtype_sum,cols = 1:(ncol(subtype_sum)-1),
                            names_to = "cluster",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$subtype <- factor(subtype_sum$subtype)
subtype_sum$cluster <- factor(subtype_sum$cluster)

p <- ggplot(subtype_sum, aes(x=cluster, y=percents,fill=subtype)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack",color="black", width=0.6,size=0.25)+
  scale_fill_manual(values=c("#ED5163","#4498F2","#72FCA0","darkgreen","black"))+
  labs(x = "",y = "Percent")+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()#6cm*5cm
# +
#   theme(panel.background=element_rect(fill="white",colour="black",size=0.25), # 填充框内主题颜色，边框颜色和边框线条粗细
#         axis.line=element_line(colour="black",size=0.25), # x,y轴颜色，粗细
#         axis.title=element_text(size=13,color="black"), # x,y轴名设置
#         axis.text = element_text(size=12,color="black"), # x,y轴文本设置
#         legend.position= c(0.8,0.5) # 显示图例，c(x,y)这里指将轴默认为1，里面的数字为轴的占比
#   )

####深究一下被归纳到不同聚类组的亚型的样本之间的区别-突变分析
library(maf)
LUAD_mut <- read.table('/database/TCGA/LUAD/mutation/raw_data/',sep = '\t',header = T)
sample_ID <- read.table('/database/TCGA/LUAD/mutation/information/gdc_sample_sheet.2022-05-08.tsv',sep = '\t',header = T)
text <- dir('/database/TCGA/LUAD/mutation/raw_data/')
all_gene_mut <- character()
for (i in 1:length(text)) {
  a <- read.table(paste('/database/TCGA/LUAD/mutation/raw_data/',text[i],sep = ''),sep = '\t',header = T)
  all_gene_mut <- c(all_gene_mut,a[,1])
}
all_gene_mut <- all_gene_mut[!duplicated(all_gene_mut)]

LUAD_mut <- data.frame()
LUAD_mut[1:length(all_gene_mut),1] <- all_gene_mut
rownames(LUAD_mut) <- LUAD_mut[,1]
for (i in 1:length(text)) {
  a <- read.table(paste('/database/TCGA/LUAD/mutation/raw_data/',text[i],sep = ''),sep = '\t',header = T)
  LUAD_mut[rownames(LUAD_mut)%in%a[,1],i] <- 1
  LUAD_mut[!rownames(LUAD_mut)%in%a[,1],i] <- 0
  colnames(LUAD_mut)[i] <- substring(a$Tumor_Sample_Barcode[1],first = 1,last = 16)
}
colnames(LUAD_mut) <- gsub(x = colnames(LUAD_mut),pattern = '-',replacement = '.')
LUAD_mut_raw <- LUAD_mut
LUAD_mut <- LUAD_mut_raw
LUAD_mut <- LUAD_mut[,colnames(LUAD_mut)%in%luad_subtype[,6]]
a <- apply(LUAD_mut,1,function(x){length(which(x==1))/length(x)})
a <- as.data.frame(a)
a <- cbind(rownames(LUAD_mut),a)
colnames(a) <- c('gene','percent')
LUAD_mut <- LUAD_mut[rownames(LUAD_mut)%in%a[a[,2]>0.01,1],]
a <- a[a[,2]>0.01,]
for (i in 1:ncol(LUAD_mut)) {
  LUAD_mut[,i] <- as.numeric(LUAD_mut[,i])
}
LUAD_mut <- cbind(LUAD_mut[,colnames(LUAD_mut)%in%rownames(annotation_col)[annotation_col[,1]=='ML']],
                  LUAD_mut[,colnames(LUAD_mut)%in%rownames(annotation_col)[annotation_col[,1]=='MM']],
                  LUAD_mut[,colnames(LUAD_mut)%in%rownames(annotation_col)[annotation_col[,1]=='MH']])
LUAD_mut <- cbind(LUAD_mut[,colnames(LUAD_mut)%in%rownames(annotation_col)[annotation_col[,2]=='PI']],
                  LUAD_mut[,colnames(LUAD_mut)%in%rownames(annotation_col)[annotation_col[,2]=='PP']],
                  LUAD_mut[,colnames(LUAD_mut)%in%rownames(annotation_col)[annotation_col[,2]=='TRU']])

LUAD_mut <- LUAD_mut[a[order(a[,2],decreasing = T),1],]
pheatmap::pheatmap(LUAD_mut,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                   annotation_colors = ann_colors,treeheight_col = 0,treeheight_row = 0,
                   show_rownames = F,cluster_rows = F)#4cm*8cm

mutation_load <- apply(LUAD_mut,2,function(x){length(which(x==1))/length(x)})
mutation_load <- as.data.frame(mutation_load)
mutation_load <- cbind(colnames(LUAD_mut),mutation_load)
colnames(mutation_load) <- c('sample_ID','percent')
a <- cbind(rownames(annotation_col),annotation_col)
colnames(a)[1] <- 'sample_ID'
mutation_load <- merge(mutation_load,a,by = 'sample_ID',all = F)

####分析突变特征
##MM/MH突变负荷低减去ML突变负荷高
ML_0.05 <- mutation_load[mutation_load[,3]=='ML',]
MMH_0.01 <- rbind(mutation_load[mutation_load[,3]=='MM',],
                  mutation_load[mutation_load[,3]=='MH',])

ML_0.05 <- LUAD_mut_raw[,colnames(LUAD_mut_raw)%in%ML_0.05[,1]]
a <- apply(ML_0.05, 1, sum)
a <- ML_0.05[apply(ML_0.05, 1, function(x){sum(as.numeric(x))})>3,]
for (i in 1:ncol(a)) {
  a[,i] <- as.numeric(a[,i])
}
pheatmap::pheatmap(a)

MMH_0.01 <- LUAD_mut_raw[,colnames(LUAD_mut_raw)%in%MMH_0.01[,1]]
a <- apply(MMH_0.01, 1, sum)
a <- MMH_0.01[apply(MMH_0.01, 1, function(x){sum(as.numeric(x))})>3,]
for (i in 1:ncol(a)) {
  a[,i] <- as.numeric(a[,i])
}
pheatmap::pheatmap(a)

MMH_0.01 <- LUAD_mut_raw[,colnames(LUAD_mut_raw)%in%MMH_0.01[,1]]
a <- apply(ML_0.05, 1, function(x){sum(as.numeric(x))/length(x)})
ML_0.05 <- as.data.frame(a)
a <- apply(MMH_0.01, 1, function(x){sum(as.numeric(x))/length(x)})
MMH_0.01 <- as.data.frame(a)

a <- MMH_0.01-ML_0.05
a <- a[a%in%rownames(LUAD_mut)]
a <- cbind(ML_0.05,MMH_0.01,a)
colnames(a) <- c('ML','MMH','diff_value')
library(clusterProfiler)
diff_mut <- a
diff_mut <- diff_mut[order(diff_mut[,3],decreasing = T),]
a <- diff_mut[diff_mut[,1]<=0.01,]
a <- bitr(rownames(a)[1:100],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
##maftools走流程
#maf数据整合单样本整合多样本
a <- read.table(paste('/database/TCGA/LUAD/mutation/raw_data/',text[i],sep = ''),sep = '\t',header = T)
read.maf(paste('/database/TCGA/LUAD/mutation/raw_data/',text[i],sep = ''))
library(stringr)
a <- read.maf(paste('/database/TCGA/LUAD/mutation/raw_data/',text[1],sep = ''))
LUAD_mut_raw <- a@data
for (i in 332:length(text)) {
  tryCatch({
    a <- read.maf(paste('/database/TCGA/LUAD/mutation/raw_data/',text[i],sep = ''))
    LUAD_mut_raw <- rbind(LUAD_mut_raw,a@data)
  }, error = function(e) {print('error')})
}
LUAD_mut <- LUAD_mut_raw
LUAD_mut$Tumor_Sample_Barcode <- substring(text = LUAD_mut$Tumor_Sample_Barcode,first = 1,last = 12)
write.table(LUAD_mut,'/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',sep = '\t',quote = F,row.names = F)
LUAD_mut <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = '/database/TCGA/LUAD/mutation/information/clinical.tsv')
# LUAD_mut_raw$Tumor_Sample_Barcode <- gsub(LUAD_mut_raw$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

##常用函数
library(maftools)
LUAD_mut <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = )
plotmafSummary(maf=LUAD_mut, rmOutlier=TRUE, addStat="median", dashboard=TRUE, titvRaw = FALSE)
oncoplot(maf=LUAD_mut, top=10, borderCol=NULL)
lollipopPlot(maf=LUAD_mut, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
luad.mutload <- tcgaCompare(maf=LUAD_mut, cohortName="Download_LUAD")

####比较ML/MMH的突变情况
LUAD_mut <- LUAD_mut_raw
LUAD_mut$Tumor_Sample_Barcode <- substring(text = LUAD_mut$Tumor_Sample_Barcode,first = 1,last = 12)
LUAD_mut$Tumor_Sample_Barcode <- gsub(LUAD_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

ML_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster=='ML',5],]
MMH_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[c(which(mutation_load$cluster=='MM'),which(mutation_load$cluster=='MH')),5],]

write.table(ML_mut,'result/LUAD/mutation/ML_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(MMH_mut,'result/LUAD/mutation/MMH_mut.maf',sep = '\t',quote = F,row.names = F)
ML_mut <- read.maf(maf ='result/LUAD/mutation/ML_mut.maf')
MMH_mut <- read.maf(maf ='result/LUAD/mutation/MMH_mut.maf')
ML_mut_vs_MMH_mut <- mafCompare(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', minMut = 2, useCNV =FALSE)
forestPlot(mafCompareRes = ML_mut_vs_MMH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MMH_mut$results
g0<-r1[which(r1$pval<0.005),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', genes = g, removeNonMutated = F)
coBarplot(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut')

a <- ML_mut_vs_MMH_mut$results[which(ML_mut_vs_MMH_mut$results$MMH_mut>0&ML_mut_vs_MMH_mut$results$ML_mut==0),1]
a <- bitr(a$Hugo_Symbol,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

####比较ML_PPI/MMH_PPI中的区别
# ML_PPI <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster=='ML',5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('PI','PP'),5],]
# MMH_PPI <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster%in%c('MM','MH'),5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('PI','PP'),5],]
# 
# write.table(ML_PPI,'result/LUAD/mutation/ML_PPI.maf',sep = '\t',quote = F,row.names = F)
# write.table(MMH_PPI,'result/LUAD/mutation/MMH_PPI.maf',sep = '\t',quote = F,row.names = F)
ML_PPI <- read.maf(maf ='result/LUAD/mutation/ML_PPI.maf')
MMH_PPI <- read.maf(maf ='result/LUAD/mutation/MMH_PPI.maf')
ML_mut_vs_MMH_mut <- mafCompare(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI', minMut = 1, useCNV =FALSE)
forestPlot(mafCompareRes = ML_mut_vs_MMH_mut, pVal = 0.039765877, 
           color = c('royalblue', 'maroon'), geneFontSize = 0.8)#8cm*6cm

r1<-ML_mut_vs_MMH_mut$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI', genes = g, removeNonMutated = F)
coBarplot(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI')



a <- ML_mut_vs_MMH_mut$results[which(ML_mut_vs_MMH_mut$results$MMH_PPI>8&ML_mut_vs_MMH_mut$results$ML_PPI==0),1]
a <- bitr(a$Hugo_Symbol,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

####比较ML_TRU/MMH_TRU中的区别
# ML_TRU <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster=='ML',5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('TRU'),5],]
# MMH_TRU <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster%in%c('MM','MH'),5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('TRU'),5],]
# 
# write.table(ML_TRU,'result/LUAD/mutation/ML_TRU.maf',sep = '\t',quote = F,row.names = F)
# write.table(MMH_TRU,'result/LUAD/mutation/MMH_TRU.maf',sep = '\t',quote = F,row.names = F)
ML_TRU <- read.maf(maf ='result/LUAD/mutation/ML_TRU.maf')
MMH_TRU <- read.maf(maf ='result/LUAD/mutation/MMH_TRU.maf')
ML_mut_vs_MMH_mut <- mafCompare(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU', minMut = 1, useCNV =FALSE)
forestPlot(mafCompareRes = ML_mut_vs_MMH_mut, pVal = 0.004, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MMH_mut$results
g0<-r1[which(r1$pval<0.005),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU', genes = g, removeNonMutated = T)
coBarplot(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU')

a <- ML_mut_vs_MMH_mut$results[ML_mut_vs_MMH_mut$results$pval<0.005,1]
a <- bitr(a$Hugo_Symbol,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
##单独可视化有丝分裂突变基因
#a <- a[which(a$SYMBOL%in%ref_path_mitotic),1]
b <- ML_mut_vs_MMH_mut
b$results <- ML_mut_vs_MMH_mut$results[ML_mut_vs_MMH_mut$results$Hugo_Symbol%in%ref_path_mitotic,]
forestPlot(mafCompareRes = b, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
r1<-b$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', genes = g, removeNonMutated = F)






########ML/MMH的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = ML_mut)
TMB[[2]] <- tmb(maf = MMH_mut)
names(TMB) <- c('ML_mut','MMH_mut')
write.csv(TMB[[1]],'result/LUAD/mutation/ML_mut_TMB.csv')
write.csv(TMB[[2]],'result/LUAD/mutation/MMH_mut_TMB.csv')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('ML_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('MMH_mut',nrow(TMB[[2]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- as.factor(TMB_plot$cluster)

library(ggplot2)
library(ggpubr)
p = ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) + 
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)
p+geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.5,)+
  stat_compare_means(method = "t.test" )

ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) + 
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,fill='grey')+
  geom_jitter(aes(color=cluster),shape=16, position = position_jitter(0.3))+
  stat_compare_means(method = "t.test" )
ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test" )#5cm*4cm

####drug effection significance
####药物筛选
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA



##画韦恩图
venn.plot <- venn.diagram(x = list(cMAP_A549=All_drug,GDSC_A549=gdsc_A549_drug),
                          category.names = c('cMAP_A549','GDSC_A549'),
                          filename = NULL,
                          scaled = F,
                          height = 1500, width = 1500, resolution =600,
                          alpha=c(0.6, 0.6),
                          fill=c(colors()[616], colors()[38]), 
                          lwd=rep(1,2), cex=0.45, 
                          fontfamily = "serif", fontface = "bold",
                          cat.dist=c(-0.07, -0.07),
                          output=TRUE,
                          area.vector = 0,
                          cat.pos=c(280, 80), #位置
                          cat.cex=0.45)##画韦恩图

pdf("result/Figure/luad_drug_screen_5.pdf")
grid.draw(venn.plot)
dev.off()
##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
pheatmap::pheatmap(luad_overlap[,2:10],clustering_method = 'ward.D2')
bk = unique(c(seq(-4,4, length=200)))
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:10]),breaks = bk,show_rownames = T,treeheight_row = 0,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = F,cluster_rows = T,cluster_cols = T)
cluster <- hotmap$tree_row
plot(cluster,hang = -1,cex=0.6,axes=FALSE,ann=FALSE)
cut <- as.data.frame(cutree(cluster,2))
annotation_row <- cut
colnames(annotation_row) <- 'cluster'
annotation_row[annotation_row[,1]==1,1] <- 'mitotic_i'
annotation_row[annotation_row[,1]==2,1] <- 'con'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
ann_colors = list(cluster = c(con="#ED5163", mitotic_i="#4498F2")) 
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:10]),breaks = bk,show_rownames = T,treeheight_row = 0,annotation_col = annotation_row,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = F,cluster_rows = T,cluster_cols = T,
                             annotation_colors = ann_colors)#6cm*8cm

drug_effection <- list()
drug_effection[[1]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==1],]
drug_effection[[2]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==2],]
names(drug_effection) <- c('mitotic_i','mitotic_con')
for (i in 1:2) {
  a <- aggregate(drug_effection[[i]]$V11,by=list(drug_effection[[i]][,1]),FUN=mean)
  drug_effection[[i]] <- a
}
for (i in 1:2) {
  drug_effection[[i]] <- cbind(drug_effection[[i]],rep(c('mitotic_i','con')[i],nrow(drug_effection[[i]])))
  colnames(drug_effection[[i]]) <- c('drug_name','cell_viability','cluster')
}
#drug_effection[[1]] <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
a <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
b <- drug_effection[[2]][!drug_effection[[2]]$drug_name%in%drug_effection[[1]]$drug_name,]
drug_effection_plot <- rbind(a,b)

#drug_effection_plot <- rbind(drug_effection[[1]],
#                            drug_effection[[2]])
drug_effection_plot$cluster <- as.factor(drug_effection_plot$cluster)

library(ggplot2)
library(ggpubr)
p = ggplot(drug_effection_plot, aes(x=cluster, y=cell_viability,fill=cluster)) + 
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)
p+geom_jitter(shape=16, position = position_jitter(0.2))+
  stat_compare_means(method = "t.test" )

ggplot(drug_effection_plot, aes(x=cluster, y=cell_viability,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test" )#5cm*4cm

####BUB1B相关性变化的气泡图
library(ggplot2)
BUB1B_drug_spearman <- rcorr(as.matrix(drug_inhibit_gene[,2:10]))
a <- expression[[8]]
a <- t(a[rownames(a)%in%colnames(drug_inhibit_gene[,2:10]),])
BUB1B_tcga_spearman <- rcorr(a,type = 'spearman')
a <- cbind(rownames(BUB1B_tcga_spearman[[1]]),BUB1B_tcga_spearman[[1]][,'BUB1B'],BUB1B_tcga_spearman[[3]][,'BUB1B'],rep('TCGA',nrow(BUB1B_tcga_spearman[[1]])))
b <- cbind(rownames(BUB1B_drug_spearman[[1]]),BUB1B_drug_spearman[[1]][,'BUB1B'],BUB1B_drug_spearman[[3]][,'BUB1B'],rep('cMap',nrow(BUB1B_drug_spearman[[1]])))
BUB1B_spearman_plot <- rbind(a,b)
colnames(BUB1B_spearman_plot) <- c('gene','spearman','p_value','data_source')
BUB1B_spearman_plot <- as.data.frame(BUB1B_spearman_plot[BUB1B_spearman_plot[,1]!="BUB1B",])
BUB1B_spearman_plot$p_value <- -1*log10(as.numeric(BUB1B_spearman_plot$p_value)+0.0001)
BUB1B_spearman_plot$spearman <- round(as.numeric(BUB1B_spearman_plot$spearman),2)

ggplot(BUB1B_spearman_plot,aes(x=gene,y=data_source))+
  geom_point()
plot <- ggplot(BUB1B_spearman_plot,aes(x=gene,y=data_source))+
  geom_point(aes(size=`p_value`,color=`spearman`))+
  scale_color_gradient(high="#F20808",low="#1E08F7")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=90,hjust = 1,vjust=0.5))+
  labs(x=NULL,y=NULL,title = 'the correlation of BUB1B in different situations')#3.54cm*4.34cm
save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
  stopifnot(!missing(x))
  stopifnot(!missing(filename))
  pdf(filename, width=width, height=height)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}
ggsave(plot = plot,filename = 'result/Figure/AI_plot_new/fig5/BUB1B相关性气泡图.pdf',width = 5,height = 2.5)

####画好看的生存曲线比较亚型分类和基因分类
subtype <- read.csv('/database/文献/肺癌的分子分型/肺腺癌/luad_subtype.csv')
subtype <- subtype[,c('Tumor.ID','expression_subtype')]
subtype[,2] <- subtype[,2]
subtype[,2][subtype[,2]=='prox.-inflam'] <- 'PI'
subtype[,2][subtype[,2]=='prox.-prolif.'] <- 'PP'
luad_subtype <- lifetime[[8]]
colnames(subtype)[1] <- 'case_id'
luad_subtype <- merge(luad_subtype,subtype,by = 'case_id',all=F)

####LUAD层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
# for (i in 1:ncol(data)) {
#   data[,i] <- scale(as.numeric(data[,i]))
# }
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- luad_subtype
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'ML'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'MH'

##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,8]=='PI',6],],data[rownames(data)%in%b[b[,8]=='PP',6],],data[rownames(data)%in%b[b[,8]=='TRU',6],])
hotmap <- rbind(hotmap[rownames(hotmap)%in%b[b[,7]=='ML',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MM',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MH',6],])
annotation_col <- rbind(b[b[,7]=='ML',7:8],b[b[,7]=='MM',7:8],b[b[,7]=='MH',7:8])
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster','subtype')
rownames(annotation_col) <- c(b[b[,7]=='ML',6],b[b[,7]=='MM',6],b[b[,7]=='MH',6])
ann_colors = list(subtype = c(PI="#ED5163", PP="#4498F2",TRU="#72FCA0"), #连续数值型分组可设置成渐变  
                  cluster = c(ML = "blue",MM = "#F2CA20", MH = "#E24A0E")) 
hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
bk = unique(c(seq(1,8, length=200)))
# bk = unique(c(seq(-3,3, length=200)))
pheatmap::pheatmap(hotmap,cluster_col = F,breaks = bk,
                   annotation_col = annotation_col,show_colnames = F,
                   color = c(colorRampPalette(c("#160993", "white"))(100),colorRampPalette(c("white","#F90623"))(100)),
                   annotation_colors = ann_colors)#4cm*8cm

##生存分析分组状况
#聚类分组
library('survival')
library('survminer')
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(type = c("#E24A0E","blue","#F4BD0B"),
                        breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        labels = c("ML","MM","MH"))##对齐坐标轴原点#4cm*5cm



#TCGA分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,8], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,8], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(type = c("#ED5163", "#4498F2","#89C890"),
                        breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
                        labels = c("PI","PP","TRU"))##对齐坐标轴原点#4cm*5cm
####FIG6的修改
####LUAD的模型构建与验证
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据
lifetime <- list()
for (i in 1:15) {
  lifetime[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/',cancer_name[i],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[[i]][,6] <- gsub('-','.',lifetime[[i]][,6])
  expression_raw[[i]] <- expression_raw[[i]][,which(colnames(expression_raw[[i]]) %in% lifetime[[i]][,6])]
  lifetime[[i]] <- lifetime[[i]][which(lifetime[[i]][,6] %in% colnames(expression_raw[[i]])),]
  lifetime[[i]] <- lifetime[[i]][which(!duplicated(lifetime[[i]][,6])),]
  lifetime[[i]]$Sample.ID <- factor(lifetime[[i]]$Sample.ID, levels = colnames(expression_raw[[i]]))
  lifetime[[i]] <- lifetime[[i]][order(lifetime[[i]]$Sample.ID),]
  lifetime[[i]][which(lifetime[[i]][,2]=='Alive'),2] <- 0
  lifetime[[i]][which(lifetime[[i]][,2]=='Dead'),2] <- 1
}
names(lifetime) <- cancer_name
library('DESeq2')
library('survival')
library('survminer')
library('dplyr')
library('glmnet')
library('ggplot2')
library('GGally')
library('rms')
library('survivalROC')
library('plotROC')
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in 1:ncol(risk_score_table)){
    risk_score_table[,each_sig_gene] <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[colnames(risk_score_table)[each_sig_gene],1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
##对5年生存的预测
for (j in 8) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    #formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    #correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)#5cm*9cm
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      #scale_color_gradient(high="#F20808",low="#1E08F7")+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                           conf.int = F,    # 显示置信区间
                                           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                           add.all = F,     # 添加总患者生存曲线
                                           palette = "hue",    # 自定义调色板
                                           surv.median.line = "hv",     # 添加中位生存时间线
                                           risk.table = F,             # 添加风险表
                                           xlab = "Follow up time(d)", # 指定x轴标签
                                           legend = c(0.8,0.9),         # 指定图例位置
                                           title = c('LUAD_predict'),                 # 设置图例标题
                                           #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                           break.x.by = 365,# 设置x轴刻度间距
                                           pval.method=T)
    predict_effect[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点 #4cm*5cm
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证
ver_expr_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/tumor_CPTAC_LUAD_immune.csv',row.names = 1)
for (j in 8) {
  ##计算基因模型风险评分
  tryCatch({
    predict_effect_ver[[j]] <- list()
    gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
    expr_data <- ver_expr_data
    rownames(expr_data) <- gsub('-','_',rownames(expr_data))
    expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
    expr_data <- log2(expr_data+1)
    life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
    life_data[life_data[,2]=='Alive',2] <- 1
    life_data[life_data[,2]=='Dead',2] <- 0
    life_data <- life_data[,c(1,6,5,2)]
    life_data[,2] <- gsub('-','.',life_data[,2])
    life_data[,2] <- gsub(', ','..',life_data[,2])
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
    
    #calculate the risk score of each sample.
    candidate_genes_for_cox2 <- gene_list
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_Validation'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)
    predict_effect_ver[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect_ver[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点#4cm*5cm
  })
}

####FIG7画图
####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 1:15) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:11,],expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%c('GZMA','GZMB','PRF1','PRF2'),])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:10,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name


sig_gene_immune_analysis_plot <- list()
bk = unique(c(seq(-1,1, length=200)))
for (i in 1:15) {
  a <- sig_gene_immune_analysis[[i]][-11,]
  
  sig_gene_immune_analysis_plot[[i]] <- pheatmap::pheatmap(a,breaks = bk,show_rownames = T,
                                                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                                                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
}
names(sig_gene_immune_analysis_plot) <- cancer_name
sig_gene_immune_analysis_plot[[2]]


##保存图片
i=15
a <- sig_gene_immune_analysis[[i]][-11,]
pheatmap::pheatmap(a,breaks = bk,show_rownames = T,
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white","red"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,
                   cluster_rows = T,cluster_cols = T,
                   treeheight_col = 0)#6cm*6.5cm

##批量生存分析绘图
immune_symbol <- rownames(expr_data_raw[[1]])[1:10]
library(survival)
library(survminer)
save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
  stopifnot(!missing(x))
  stopifnot(!missing(filename))
  pdf(filename, width=width, height=height)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}
surv_HR_immune <- list()
surv_P_immune <- list()
surv_plot_immune <- list()
for (x in 1:15) {
  surv_HR_immune[[x]] <- data.frame()
  surv_P_immune[[x]] <- data.frame()
  surv_plot_immune[[x]] <- list()
  b <- lifetime_all[[x]][lifetime_all[[x]][,6] %in% colnames(expr_data_raw[[x]]),]
  for (j in 1:10) {
    tryCatch({a <- expr_data_raw[[x]][rownames(expr_data_raw[[x]])==immune_symbol[j],]
    b[b[,6]%in%colnames(expr_data_raw[[x]])[which(a <= median(as.numeric(a)))],7] <- 'low'
    b[b[,6]%in%colnames(expr_data_raw[[x]])[which(a > median(as.numeric(a)))],7] <- 'high'
    c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
    surv_P_immune[[x]][j,1] <- 1-pchisq(c$chisq,1)
    surv_HR_immune[[x]][j,1] <- (c$obs[2]/c$exp[2])/(c$obs[1]/c$exp[1])
    fit_km <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)     
    surv_plot_immune[[x]][[j]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                             conf.int = F,    # 显示置信区间
                                             pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                             add.all = F,     # 添加总患者生存曲线
                                             palette = "hue",    # 自定义调色板
                                             surv.median.line = "hv",     # 添加中位生存时间线
                                             risk.table = TRUE,             # 添加风险表
                                             xlab = "Follow up time(d)", # 指定x轴标签
                                             legend = c(0.8,0.9),         # 指定图例位置
                                             title = paste(cancer_name[x],'_',immune_symbol[j],sep = ''),                 # 设置图例标题
                                             #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                             break.x.by = 365,# 设置x轴刻度间距
                                             pval.method=T)
    surv_plot_immune[[x]][[j]] <- surv_plot_immune[[x]][[j]]$plot+scale_x_continuous(expand = c(0,0))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = surv_plot_immune[[x]][[j]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点#4cm*5cm
    ggsave(filename = paste('result/Figure/AI_plot_new/fig7/',cancer_name[x],'_',immune_symbol[j],'.pdf',sep = ''),
           plot = surv_plot_immune[[x]][[j]],width = 5,height = 5)
    },error = function(e){surv_P_immune[[x]][j,1] <- 1
    surv_HR_immune[[x]][j,1] <- 1
    print('error')})
  }
  rownames(surv_P_immune[[x]]) <- immune_symbol
  rownames(surv_HR_immune[[x]]) <- immune_symbol
}
names(surv_P_immune) <- cancer_name
names(surv_HR_immune) <- cancer_name

# ggsave(filename = 'result/Figure/AI_plot_new/fig7/test.pdf',plot = surv_plot_immune[[x]][[j]],width = 5,height = 5)
# ggsave(plot = plot,filename = 'result/Figure/AI_plot_new/fig5/BUB1B相关性气泡图.pdf'
#        ,width = 5,height = 2.5)
# 
# print(predict_effect_ver[[i]][[2]],newpage = FALSE)
# save_pheatmap_pdf(x = surv_plot_immune[[x]][[j]],filename = 'result/Figure/test.pdf',width = 5,height = 5)
# a$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
#   scale_colour_discrete(type = c("red","blue"),
#                         breaks = predict_effect_ver[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
#                         labels = c("low","high"))##对齐坐标轴原点#4cm*5cm

####fig8_BRCA的分子分型与显著基因表达特征
####乳腺癌层次聚类与生存分析
####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:9,1]),]))
#data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
annotation_col[annotation_col[,1]==2,1] <- 'IM'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm


a <- log2(t(a)+1)
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E")) 
pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(60),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col)

paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#950599","blue","red"),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##亚型生存曲线
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#950599","blue","red","#12D658"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm

####FIG9
library(tidyverse)
library(DESeq2)
brca_counts <- read.csv('/database/TCGA/BRCA/TCGA_BRCA_counts.csv',header = T,row.names = 1)
brca_tpm <- expression_raw[[2]]
brca_cd8 <- brca_tpm[8,]
a <- quantile(brca_cd8[1,])
mycounts <- cbind(brca_counts[,colnames(brca_counts)%in%colnames(brca_cd8[,brca_cd8[1,]<=a[1,3]])],
                  brca_counts[,colnames(brca_counts)%in%colnames(brca_cd8[,brca_cd8[1,]>a[1,3]])])
colData <- data.frame(1:ncol(mycounts))
rownames(colData) <- colnames(mycounts)
colnames(colData) <- 'condition'
colData[rownames(colData)%in%colnames(brca_cd8)[brca_cd8[1,]>a[1,3]],1] <- 'High'
colData[rownames(colData)%in%colnames(brca_cd8)[brca_cd8[1,]<=a[1,3]],1] <- 'Low'
dds <- DESeqDataSetFromMatrix(mycounts, colData, design= ~ condition)
dds <- DESeq(dds)
res = results(dds, contrast=c("condition", "High", "Low"))
#或下面命令
res= results(dds)
res = res[order(res$pvalue),]
head(res)
summary(res)
#所有结果先进行输出
write.csv(res,file="result/Figure/AI_plot_new/fig9/All_results.csv")
table(res$padj<0.05)
diff_gene_deseq2 <-subset(res, padj < 0.05 & abs(log2FoldChange) > 1)
write.csv(diff_gene_deseq2,file= "result/Figure/AI_plot_new/fig9/DEG_High_vs_Low.csv")
diff_gene_deseq2 <- as.data.frame(diff_gene_deseq2)
write.csv(diff_gene_deseq2,'result/Figure/AI_plot_new/fig9/diff_gene_deseq2.csv')

##chemokine分析
chemokine <- read.csv('/database/chemokine_data/target_cell_target_cell.csv',header = F)
colnames(chemokine) <- c('target_cell','chemokine')
a <- str_split(chemokine[,2],' ',simplify = T)
chemokine <- cbind(chemokine[,1],a)
a <- as.list(chemokine[,1])
names(a) <- chemokine[,1]
for (i in 1:length(a)) {
  b <- chemokine[i,2:ncol(chemokine)]
  b <- b[b!='']
  b <- b[!duplicated(b)]
  a[[i]] <- b
}
chemokine <- a

diff_cd8_chemokine <- diff_gene_deseq2[rownames(diff_gene_deseq2)%in%chemokine[[8]],]
human_TF <- read.table('/database/TRRUST/transcipt_factor_rawdata.human.tsv',sep = '\t')
colnames(human_TF) <- c('TF','Target','Mode of Regulation','References(PMID)')
diff_cd8_TF <- diff_gene_deseq2[rownames(diff_gene_deseq2)%in%human_TF[,1],]
a <- human_TF[human_TF[,1]%in%rownames(diff_cd8_TF)&human_TF[,2]%in%chemokine[[8]],1]

write.csv(human_TF,'/database/TRRUST/humanTF.csv',row.names = F)
##画火山图
#画火山图
library(ggpubr)
library(ggplot2)
library(ggthemes)
library(ggrepel)

DEG <- as.data.frame(res)
DESeq2_DEG <- na.omit(DEG)
DEG_data <- DESeq2_DEG

dim(DEG_data)
## [1] 5268    7
#将基因分为三类：not-siginficant，up，dowm
#将adj.P.value小于0.05，logFC大于2的基因设置为显著上调基因
#将adj.P.value小于0.05，logFC小于-2的基因设置为显著上调基因
DEG_data$Group <- "not-siginficant"
DEG_data$Group[which((DEG_data$padj < 0.05) & DEG_data$log2FoldChange > 1)] <- "up-regulated"
DEG_data$Group[which((DEG_data$padj < 0.05) & DEG_data$log2FoldChange < -1)] <- "down-regulated"
DEG_data$padj <- -log10(DEG_data$padj) # 对差异基因矫正后p-value进行log10()转换
DEG_data$padj[!is.finite(DEG_data$padj)] <- 290
table(DEG_data$Group)
DEG_data <- DEG_data[order(DEG_data$padj),]#对差异表达基因调整后的p值进行排序
#火山图中添加点(数据构建)##上调下调最top的点
# up_label <- DEG_data[DEG_data$Group == "up-regulated",]
# down_label <- DEG_data[DEG_data$Group == "down-regulated",]
# deg_label_gene <- data.frame(gene = c(rownames(up_label),rownames(down_label)),
#                              label = c(rownames(up_label),rownames(down_label)))
# DEG_data$gene <- rownames(DEG_data)
# DEG_data <- merge(DEG_data,deg_label_gene,by = 'gene',all = T)
#指定转录因子和趋化因子点
ck_label <- DEG_data[DEG_data$Group != "not-siginficant"&rownames(DEG_data)%in%chemokine[[8]],]
TF_label <- DEG_data[DEG_data$Group != "not-siginficant"&rownames(DEG_data)%in%human_TF[human_TF[,2]%in%chemokine[[8]],1],]
deg_label_gene <- data.frame(gene = c(rownames(ck_label),rownames(TF_label)),
                             label = c(rownames(ck_label),rownames(TF_label)))
DEG_data$gene <- rownames(DEG_data)
DEG_data <- merge(DEG_data,deg_label_gene,by = 'gene',all = T)



#添加特定基因label
ggscatter(DEG_data,x = "log2FoldChange",y = "padj",color = "Group",
          palette = c("blue","gray","red"),
          repel = T, ylab = "-log10(Padj)", size = 2) + 
  theme_base()+
  theme(element_line(size = 0),element_rect(size = 1.5))+ #坐标轴线条大小设置
  #scale_y_continuous(limits = c(0,18))+
  scale_x_continuous(limits = c(-7,7))+
  geom_hline(yintercept = -log10(0.05),linetype = "dashed")+
  geom_vline(xintercept = c(-1,1),linetype = "dashed")+
  geom_text_repel(data = DEG_data,parse = F,fontface="bold",
                  color="black",min.segment.length = 0,force = 1,max.iter = 3e3,
                  aes(log2FoldChange, padj, label = label),
                  nudge_x=ifelse(DEG_data$log2FoldChange>=2, 1, -1),nudge_y=ifelse(DEG_data$padj>=100, 20, 10),
                  size = 4,segment.size=1,segment.colour='black')+
  theme_classic()

####增长曲线
sig_gene_add <- data.frame()
sig_gene_add_rate <- data.frame()
for (i in 1:15) {
  for (j in 1:10) {
    sig_gene_num[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8))
    sig_gene_max[i,j] <- max(surv_data[[i]][[1]][,j])
    ifelse(j==1,sig_gene_add[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8)),
           sig_gene_add[i,j] <- (length(which(surv_data[[i]][[1]][,j]>=0.8))-sig_gene_num[i,j-1]))
    ifelse(j==1,sig_gene_add_rate[i,j] <- sig_gene_add[i,j]/0,
           sig_gene_add_rate[i,j] <- sig_gene_add[i,j]/sig_gene_num[i,j-1])
  }
}
for (i in 1:15) {
  for (j in 1:10) {
    sig_gene_add_rate[i,j] <- sig_gene_add[i,j]/median(as.numeric(sig_gene_num[i,]))
  }
}
rownames(sig_gene_add) <- cancer_name
colnames(sig_gene_add) <- c(seq(0.1,1,0.1))
rownames(sig_gene_add_rate) <- cancer_name
colnames(sig_gene_add_rate) <- c(seq(0.1,1,0.1))


sig_gene_add_rate$cancer_name <- rownames(sig_gene_add_rate)
sig_gene_add_rate <- pivot_longer(data = sig_gene_add_rate,cols = 1:(dim(sig_gene_add_rate)[2]-1),
                                  names_to = "sample_size",##这一个参数是将列名命名为sample_size
                                  values_to = "rate")
sig_gene_add_rate$cancer_name <- factor(sig_gene_add_rate$cancer_name, levels = str_sort(unique(sig_gene_add_rate$cancer_name),numeric = T))
sig_gene_add_rate$cancer_name <- as.factor(sig_gene_add_rate$cancer_name)

sig_gene_add$cancer_name <- rownames(sig_gene_add)
sig_gene_add <- pivot_longer(data = sig_gene_add,cols = 1:(dim(sig_gene_add)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_add$cancer_name <- factor(sig_gene_add$cancer_name, levels = str_sort(unique(sig_gene_add$cancer_name),numeric = T))
sig_gene_add$cancer_name <- as.factor(sig_gene_add$cancer_name)

ggplot(sig_gene_max, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  geom_line(size=1)#size是线的宽度
ggplot(sig_gene_add, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  geom_line(size=1)#size是线的宽度
ggplot(sig_gene_add_rate, aes(x=sample_size, y=rate, colour=cancer_name,group=cancer_name))+
  geom_line(size=1)#size是线的宽度

######################################继续大修（第二次）
#####fig1
##画折线图
sig_gene_num <- data.frame()
sig_gene_max <- data.frame()
sig_gene_add <- data.frame()
for (i in 1:15) {
  for (j in 1:10) {
    sig_gene_num[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8))
    sig_gene_max[i,j] <- max(surv_data[[i]][[1]][,j])
    ifelse(j==1,sig_gene_add[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8)),
           sig_gene_add[i,j] <- (length(which(surv_data[[i]][[1]][,j]>=0.8))-sig_gene_add[i,j-1]))
  }
}
rownames(sig_gene_num) <- cancer_name
colnames(sig_gene_num) <- c(seq(0.1,1,0.1))
rownames(sig_gene_max) <- cancer_name
colnames(sig_gene_max) <- c(seq(0.1,1,0.1))
rownames(sig_gene_add) <- cancer_name
colnames(sig_gene_add) <- c(seq(0.1,1,0.1))

sig_gene_num$cancer_name <- rownames(sig_gene_num)
sig_gene_num <- pivot_longer(data = sig_gene_num,cols = 1:(dim(sig_gene_num)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_num$cancer_name <- factor(sig_gene_num$cancer_name, levels = str_sort(unique(sig_gene_num$cancer_name),numeric = T))
sig_gene_num$cancer_name <- as.factor(sig_gene_num$cancer_name)

sig_gene_max$cancer_name <- rownames(sig_gene_max)
sig_gene_max <- pivot_longer(data = sig_gene_max,cols = 1:(dim(sig_gene_max)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_max$cancer_name <- factor(sig_gene_max$cancer_name, levels = str_sort(unique(sig_gene_max$cancer_name),numeric = T))
sig_gene_max$cancer_name <- as.factor(sig_gene_max$cancer_name)

ggplot(sig_gene_max, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  theme_base()+
  geom_line(size=1)#size是线的宽度

#####fig2
####fig2C排版
####富集通路
library(clusterProfiler)
library(stringr)

cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- apply(surv_data[[j]][[1]], 2, max)
  b <- surv_data[[j]][[1]][,which.max(a[a!=0])]
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which.max(a[a!=0])] >= 0.8),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- rownames(surv_data_sig[[i]][[1]])
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}
names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
sig_pathway_plot_all <- surv_sig_pathway
sig_pathway_plot_all@compareClusterResult <- sig_pathway_plot_all@compareClusterResult[sig_pathway_plot_all@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
a <- sig_pathway_plot_all@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(2,15,7,8,6,11,5,3,9,1)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_all
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(2,15,7,8,6,11,5,3,9,1)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(2,15,7,8,6,11,5,3,9,1)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 70)

# #自动注释
# mitotic_pathway <- list()
# mitotic_pathway[[1]] <- 'GO:0022403'
# names(mitotic_pathway)[1] <- paste('Level',1,sep = '')
# for (i in 2:18) {
#   mitotic_pathway[[i]] <- GO_inter[GO_inter[,2]%in%mitotic_pathway[[i-1]],1]
#   mitotic_pathway[[i]] <- mitotic_pathway[[i]][!duplicated(mitotic_pathway[[i]])]
#   names(mitotic_pathway)[i] <- paste('Level',i,sep = '')
# }

# immune_pathway <- list()
# immune_pathway[[1]] <- 'GO:0002376'
# names(immune_pathway)[1] <- paste('Level',1,sep = '')
# for (i in 2:18) {
#   immune_pathway[[i]] <- GO_inter[GO_inter[,2]%in%immune_pathway[[i-1]],1]
#   immune_pathway[[i]] <- immune_pathway[[i]][!duplicated(immune_pathway[[i]])]
#   names(immune_pathway)[i] <- paste('Level',i,sep = '')
# }
# a <- character()
# for (i in 1:18) {
#   a <- c(a,immune_pathway[[i]])
# }
# immune_pathway <- a

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]
# write.csv(annotation_col,'result/Figure/AI_plot_new/fig2/v2/pathway_annotation.csv',row.names = F)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/pathway_annotation.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='others',3] <- 'black'
y_color[y_color[,2]=='mitotic',3] <- 'red'
y_color[y_color[,2]=='immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))



# plot + theme(axis.text.y = element_text(color = x_y_color$color))+
#   geom_polygon(data=x_y_color, aes(x, y, fill=factor(x_y_color$color), alpha=0.1,group=pathway))
# 
# plot+
#   theme(axis.text.y = element_text(color = y_color$color))+
#   geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
#                  aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax,
#                      group=pathway), fill = y_color$color, alpha=0.1)+
#   geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
#             aes(xmin=xmax,xmax=xmax,ymin=ymax,ymax=ymax,
#                 group=pathway, fill = y_color$type), fill = alpha=0.1)

# plot+
#   theme(axis.text.y = element_text(color = y_color$color))+
#   geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
#             aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax,
#                 group=type,fill = color), alpha=0.1)
a <- as.vector(y_color$type)
a <-as.vector(y_color$pathway)[c(which(a=='others'),
                                 which(a=='mitotic'),
                                 which(a=='immune'))]
plot$data$Description <- factor(plot$data$Description,levels = a)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='others'),
                                                           which(y_color$type=='mitotic'),
                                                           which(y_color$type=='immune'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=y_color$color[!duplicated(y_color$color)])#10cm*12cm

#画桑基图(结论，sankeyD3不好用)
devtools::install_github("fbreitwieser/sankeyD3")
library(sankeyD3)
#install.packages("webshot")
library(webshot)
#webshot::install_phantomjs()#这个是用来转换html和PDF的
sig_pathway_plot_top10@compareClusterResult <- sig_pathway_plot_top10@compareClusterResult[sig_pathway_plot_top10@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_top10,showCategory=5,includeAll=TRUE,label_format = 70)
a <- sig_pathway_plot_top10@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(2,15,7,8,6)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_top10
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(2,15,7,8,6)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(2,15,7,8,6,11,5,3,9,1)])
dotplot(a,showCategory=5,includeAll=TRUE,label_format = 70)
write.csv(a@compareClusterResult,'result/Figure/AI_plot_new/fig2/v2/annotation_top10.csv')
library("networkD3")
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/annotation_top10.csv')

b <- annotation_col[,c(1,2,4)]
b <- b[c(which(b$X=='mitotic'),which(b$X=='immune'),which(b$X=='others')),]
b$weight <- 1
# b$func <- factor(b$func,levels = c('mitotic','immune','others'))
# b$Cluster <- factor(b$Cluster,levels = c('LUAD\n(9)','LIHC\n(10)','LGG\n(9)','BRCA\n(10)','UCEC\n(10)'))
nodes <- data.frame(name=c(as.character(b$X), as.character(b$Cluster)) %>% unique())
b$IDsource <- match(b$Cluster, nodes$name)-1 
b$IDtarget <- match(b$X, nodes$name)-1
nodes$color<-c('red','blue','#D9D9D9',"#F29530","#F29530","#F29530","#4FAAC8","#4FAAC8")
sankeyNetwork(Links = b, Nodes = nodes,Source = "IDsource",
              Target = "IDtarget",Value = "weight",
              NodeID = "name", units = "TWh",
              fontSize= 12, nodeWidth = 30,NodeColor = "color")
p <- sankeyNetwork(Links = b, Nodes = nodes,Source = "IDsource",
                   Target = "IDtarget",Value = "weight",
                   NodeID = "name", units = "TWh",
                   fontSize= 12, nodeWidth = 30,NodeColor = "color")
saveNetwork(p,"result/Figure/AI_plot_new/fig2/v2/sankey.html",selfcontained = T)

webshot(url = "result/Figure/AI_plot_new/fig2/v2/sankey.html" , file = "result/Figure/AI_plot_new/fig2/v2/sankey.pdf")
?saveNetwork

##ggplot2画sankey图
library("ggplot2")
library("ggalluvial")
colnames(b) <- c('pathway','cancer_type','pathway_name','weight')
b$cohort <- 1:nrow(b)
b <- pivot_longer(data = b[,c(1,2,5)],cols = 1:2,
                  names_to = "feature",##这一个参数是将列名命名为sample_size
                  values_to = "nodes")##col
b$nodes <- factor(b$nodes,levels = c(unique(b$nodes)[c(3,2,4,6,7,1,5,8)]))
mycol <- c("#F29530","#F29530","#F29530","#4FAAC8","#4FAAC8",'red','#245BAA','#D9D9D9')
ggplot(b,aes(x = feature, stratum = nodes, alluvium = cohort,
             fill = nodes, label = nodes)) +
  scale_x_discrete(expand = c(0, 0)) + 
  geom_flow(width = 1/8) + #线跟方块间空隙的宽窄 
  geom_stratum(alpha = .9,width = 2/10) + #方块的透明度、宽度
  geom_text(stat = "stratum", size = 3,color="white") + #文字大小、颜色
  #不喜欢默认的配色方案，用前面自己写的配色方案
  scale_fill_manual(values = mycol) +
  xlab("") + ylab("") +
  theme_bw() + #去除背景色
  theme(panel.grid =element_blank()) + #去除网格线
  theme(panel.border = element_blank()) + #去除外层边框
  theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text = element_blank()) + #去掉坐标轴
  ggtitle("")+
  guides(fill = FALSE) #5cm*7cm
##画网络图
library(tidyverse)
library(igraph)
library(ggraph)
library(tidygraph)

colors <-c("#E41A1C","#1E90FF","#FF8C00","#4DAF4A","#984EA3",
           "#40E0D0","#FFC0CB","#00BFFF","#FFDEAD","#90EE90",
           "#EE82EE","#00FFFF","#F0A3FF", "#0075DC", 
           "#993F00","#4C005C","#2BCE48","#FFCC99",
           "#808080","#94FFB5","#8F7C00","#9DCC00",
           "#426600","#FF0010","#5EF1F2","#00998F",
           "#740AFF","#990000","#FFFF00")

##网络图教程
# us417 <- read.csv("result/Figure/AI_plot_new/fig2/v2/US417.csv", header=T)
# exports <- us417
# exports <- distinct(exports,source)
# exports <- rename(exports,label = source)
# 
# imports <- us417 %>%
#   distinct(target) %>%
#   rename(label = target)
# 
# exports <- us417 %>%
#   distinct(source) %>%
#   rename(label = source)
# 
# nodes <- full_join(exports, imports,
#                    by = "label")
# 
# nodes <-  nodes %>% 
#   mutate(id = 1:nrow(nodes)) %>%
#   select(id, everything())
# 
# edges <- us417 %>% 
#   left_join(nodes, by = c("source" = "label")) %>% 
#   rename(from = id)
# 
# edges <- edges %>% 
#   left_join(nodes, by = c("target" = "label")) %>% 
#   rename(to = id)
# 
# imports <- us417 %>%
#   distinct(target) %>%
#   rename(label = target)
# 
# exports <- us417 %>%
#   distinct(source) %>%
#   rename(label = source)
# 
# nodes <- full_join(exports, imports,
#                    by = "label")
# nodes <-  nodes %>% 
#   mutate(id = 1:nrow(nodes)) %>%
#   select(id, everything())
# 
# 
# edges <- us417 %>% 
#   left_join(nodes, by = c("source" = "label")) %>% 
#   rename(from = id)
# 
# edges <- edges %>% 
#   left_join(nodes, by = c("target" = "label")) %>% 
#   rename(to = id)
# 
# 
# edges <- select(edges, from, to, weight)
# 
# 
# net.tidy <- tbl_graph(
#   nodes = nodes, edges = edges, directed = TRUE
# )
# 
# 
# ggraph(net.tidy, layout = "star") + 
#   geom_node_point(size=4,aes(color=label),
#                   show.legend = F) +
#   geom_edge_link(aes(width = weight,
#                      color=weight),show.legend = F) + 
#   scale_edge_width(range = c(0.5, 2)) +
#   geom_node_text(aes(label = label),repel = TRUE) +
#   scale_color_manual(values = colors)+
#   theme_graph()
# 
# ####ggraph
# nodes <- c(surv_sig_inter[[8]][,1],surv_sig_inter[[8]][,3])
# nodes <- nodes[!duplicated(nodes)]
# 
# nodes <- as.data.frame(nodes)
# nodes <- cbind(rownames(nodes),nodes)
# colnames(nodes) <- c('id','label')
# 
# nodes <- cbind(rownames(nodes),nodes)
# colnames(nodes) <- c('id','label')
# edges <- surv_sig_inter[[8]][,c(1,3,2)]
# colnames(edges) <- c('from','to','weight')
# for (i in 1:nrow(nodes)) {
#   edges[edges[,1]%in%nodes[i,2],1] <- nodes[i,1]
#   edges[edges[,2]%in%nodes[i,2],2] <- nodes[i,1]
# }
# net.tidy <- tbl_graph(
#   nodes = nodes, edges = edges, directed = TRUE
# )
# ggraph(net.tidy, layout = "star") + 
#   geom_node_point(size=4,aes(color=label),
#                   show.legend = F) +
#   geom_edge_link(aes(width = weight,
#                      color=weight),show.legend = F) + 
#   scale_edge_width(range = c(0.5, 2)) +
#   geom_node_text(aes(label = label),repel = TRUE) +
#   #scale_color_manual(values = colors)+
#   theme_graph()

####网络图文件
immune_system <- read.table('/database/Gene Ontology/homo_sapiens/immune_system/immune_system.txt',sep = '\t')
immune_system <- distinct(immune_system,V2)
ref_path_mitotic
a <- read.csv('result/Figure/network/节点属性表.csv')
a[a[,1]%in%immune_system[,1],2] <- '1'
a[!a[,1]%in%immune_system[,1],2] <- '0'
a[a[,3]%in%immune_system[,1],4] <- '1'
a[!a[,3]%in%immune_system[,1],4] <- '0'
a[a[,5]%in%ref_path_mitotic,6] <- '1'
a[!a[,5]%in%ref_path_mitotic,6] <- '0'
a[a[,7]%in%ref_path_mitotic,8] <- '1'
a[!a[,7]%in%ref_path_mitotic,8] <- '0'
a[a[,9]%in%ref_path_mitotic,10] <- '1'
a[!a[,9]%in%ref_path_mitotic,10] <- '0'
write.csv(a,'result/Figure/network/节点属性表_v.csv',row.names = F)

####fig3A
##对网络top10进行富集（dotplot）
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- surv_sig_dgree[[i]][1:10,1]
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}

names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
##提取指定层次的通路进行绘制通路图
sig_pathway_plot_top10 <- surv_sig_pathway
sig_pathway_plot_top10@compareClusterResult <- sig_pathway_plot_top10@compareClusterResult[sig_pathway_plot_top10@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_top10,showCategory=5,includeAll=TRUE,label_format = 70)
a <- sig_pathway_plot_top10@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(2,15,7,8,6)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_top10
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(2,15,7,8,6)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(2,15,7,8,6,11,5,3,9,1)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 35)

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]

# write.csv(annotation_col,'result/Figure/AI_plot_new/fig2/v2/pathway_annotation_top10.csv',row.names = F)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/pathway_annotation_top10.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='others',3] <- 'black'
y_color[y_color[,2]=='mitotic',3] <- 'red'
y_color[y_color[,2]=='immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

a <- as.vector(y_color$type)
a <-as.vector(y_color$pathway)[c(which(a=='others'),
                                 which(a=='mitotic'),
                                 which(a=='immune'))]
plot$data$Description <- factor(plot$data$Description,levels = a)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='others'),
                                                           which(y_color$type=='mitotic'),
                                                           which(y_color$type=='immune'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=y_color$color[!duplicated(y_color$color)])#6cm*8cm

##ggplot2画sankey图
####top10sankey plot
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/annotation_top10.csv')
b <- annotation_col[,c(1,2,4)]
b <- b[c(which(b$X=='mitotic'),which(b$X=='immune'),which(b$X=='others')),]
b$weight <- 1
library("ggplot2")
library("ggalluvial")
colnames(b) <- c('pathway','cancer_type','pathway_name','weight')
b$cohort <- 1:nrow(b)
b <- pivot_longer(data = b[,c(1,2,5)],cols = 1:2,
                  names_to = "feature",##这一个参数是将列名命名为sample_size
                  values_to = "nodes")##col
b$nodes <- factor(b$nodes,levels = c(unique(b$nodes)[c(3,2,4,6,7,1,5,8)]))
mycol <- c("#F29530","#F29530","#F29530","#4FAAC8","#4FAAC8",'red','#245BAA','#D9D9D9')
ggplot(b,aes(x = feature, stratum = nodes, alluvium = cohort,
             fill = nodes, label = nodes)) +
  scale_x_discrete(expand = c(0, 0)) + 
  geom_flow(width = 1/8) + #线跟方块间空隙的宽窄 
  geom_stratum(alpha = .9,width = 2/10) + #方块的透明度、宽度
  geom_text(stat = "stratum", size = 3,color="white") + #文字大小、颜色
  #不喜欢默认的配色方案，用前面自己写的配色方案
  scale_fill_manual(values = mycol) +
  xlab("") + ylab("") +
  theme_bw() + #去除背景色
  theme(panel.grid =element_blank()) + #去除网格线
  theme(panel.border = element_blank()) + #去除外层边框
  theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text = element_blank()) + #去掉坐标轴
  ggtitle("")+
  guides(fill = FALSE) #5cm*7cm



####fig4_V2
####使用显著基因对LUAD进行分类，并与TCGA三种亚型进行分类
subtype <- read.csv('/database/文献/肺癌的分子分型/肺腺癌/luad_subtype.csv')
subtype <- subtype[,c('Tumor.ID','expression_subtype')]
subtype[,2] <- subtype[,2]
subtype[,2][subtype[,2]=='prox.-inflam'] <- 'PI'
subtype[,2][subtype[,2]=='prox.-prolif.'] <- 'PP'
luad_subtype <- lifetime[[8]]
colnames(subtype)[1] <- 'case_id'
luad_subtype <- merge(luad_subtype,subtype,by = 'case_id',all=F)

####LUAD层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- luad_subtype
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'ML'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'MH'

##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,8]=='PI',6],],data[rownames(data)%in%b[b[,8]=='PP',6],],data[rownames(data)%in%b[b[,8]=='TRU',6],])
hotmap <- rbind(hotmap[rownames(hotmap)%in%b[b[,7]=='ML',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MM',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MH',6],])
annotation_col <- rbind(b[b[,7]=='ML',7:8],b[b[,7]=='MM',7:8],b[b[,7]=='MH',7:8])
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster','subtype')
rownames(annotation_col) <- c(b[b[,7]=='ML',6],b[b[,7]=='MM',6],b[b[,7]=='MH',6])
ann_colors = list(subtype = c(PI="blue", PP="#F2CA20",TRU="#E24A0E"), #连续数值型分组可设置成渐变  
                  cluster = c(ML="#89C890",MM="#4498F2", MH="#ED5163")) 
hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                   annotation_colors = ann_colors)#4cm*8cm

##画柱状图看统计情况堆叠柱状图
library(tidyr)
subtype_sum <- data.frame()
for (i in 1:3) {
  subtype_sum[1,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='PI'))
  subtype_sum[2,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='PP'))
  subtype_sum[3,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='TRU'))
}
colnames(subtype_sum) <- c('MM','ML','MH')
rownames(subtype_sum) <- c('PI','PP','TRU')
subtype_sum <- apply(subtype_sum, 2, function(x){x/sum(x)})
subtype_sum <- as.data.frame(subtype_sum)
subtype_sum[1:3,4] <- rownames(subtype_sum)
colnames(subtype_sum)[4] <- 'subtype'
subtype_sum <- pivot_longer(data = subtype_sum,cols = 1:(ncol(subtype_sum)-1),
                            names_to = "cluster",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$subtype <- factor(subtype_sum$subtype)
subtype_sum$cluster <- factor(subtype_sum$cluster,levels = c('ML','MM','MH'))

p <- ggplot(subtype_sum, aes(x=cluster, y=percents,fill=subtype)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack",color="black", width=0.6,size=0.25)+
  scale_fill_manual(values=c("blue","#F2CA20","#E24A0E"))+
  labs(x = "",y = "Percent")+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()#6cm*5cm
p#6cm*5cm

##生存分析分组状况
#聚类分组
library('survival')
library('survminer')
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#ED5163", "#4498F2","#89C890"),
                        breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        labels = c("ML","MM","MH"))##对齐坐标轴原点#4cm*5cm



#TCGA分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,8], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,8], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#E24A0E","blue","#F4BD0B"),
                        breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
                        labels = c("PI","PP","TRU"))##对齐坐标轴原点#4cm*5cm

##常用函数
library(maftools)
LUAD_mut <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = '/database/TCGA/LUAD/mutation/information/clinical.tsv')
plotmafSummary(maf=LUAD_mut, rmOutlier=TRUE, addStat="median", dashboard=TRUE, titvRaw = FALSE)
oncoplot(maf=LUAD_mut, top=10, borderCol=NULL)
lollipopPlot(maf=LUAD_mut, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
luad.mutload <- tcgaCompare(maf=LUAD_mut, cohortName="Download_LUAD")

####比较ML/MMH的突变情况
LUAD_mut <- LUAD_mut_raw
LUAD_mut$Tumor_Sample_Barcode <- substring(text = LUAD_mut$Tumor_Sample_Barcode,first = 1,last = 12)
LUAD_mut$Tumor_Sample_Barcode <- gsub(LUAD_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

ML_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster=='ML',5],]
# MMH_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[c(which(mutation_load$cluster=='MM'),which(mutation_load$cluster=='MH')),5],]
MMH_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[c(which(mutation_load$cluster%in%c('MM','MH'))),5],]
MM_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[which(mutation_load$cluster=='MM'),5],]
MH_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[which(mutation_load$cluster=='MH'),5],]
write.table(ML_mut,'result/LUAD/mutation/ML_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(MMH_mut,'result/LUAD/mutation/MMH_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(MM_mut,'result/LUAD/mutation/MM_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(MH_mut,'result/LUAD/mutation/MH_mut.maf',sep = '\t',quote = F,row.names = F)
ML_mut <- read.maf(maf ='result/LUAD/mutation/ML_mut.maf')
MMH_mut <- read.maf(maf ='result/LUAD/mutation/MMH_mut.maf')
MM_mut <- read.maf(maf ='result/LUAD/mutation/MM_mut.maf')
MH_mut <- read.maf(maf ='result/LUAD/mutation/MH_mut.maf')
########ML/MMH的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = ML_mut)
TMB[[2]] <- tmb(maf = MMH_mut)
TMB[[2]] <- tmb(maf = MM_mut)
TMB[[3]] <- tmb(maf = MH_mut)
names(TMB) <- c('ML_mut','MM_mut','MH_mut')
write.csv(TMB[[1]],'result/LUAD/mutation/ML_mut_TMB.csv')
write.csv(TMB[[2]],'result/LUAD/mutation/MMH_mut_TMB.csv')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('ML',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('MM',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('MH',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('ML','MM','MH'))

library(ggplot2)
library(ggpubr)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test" )#5cm*4cm

a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  scale_fill_manual(values=c("#89C890","#4498F2","#ED5163"))+
  theme_classic()+
  geom_signif(comparisons = list(c("ML","MM"),c("ML","MH")), 
              map_signif_level = TRUE, test = t.test, y_position = c(28,32),
              tip_length = c(0.05,0.05))#5cm*4cm

ML_mut_vs_MMH_mut <- mafCompare(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', minMut = 2, useCNV =FALSE)
ML_mut_vs_MH_mut <- mafCompare(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
MM_mut_vs_MH_mut <- mafCompare(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
ML_mut_vs_MM_mut <- mafCompare(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = ML_mut_vs_MMH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = ML_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MMH_mut$results
g0<-r1[which(r1$pval<0.005),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', genes = g, removeNonMutated = F)
coBarplot(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut')

r1<-ML_mut_vs_MH_mut$results
r1<-MM_mut_vs_MH_mut$results
r1<-ML_mut_vs_MM_mut$results
g0<-r1[which(r1$pval<0.003),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', genes = g, removeNonMutated = T)
coOncoplot(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', genes = g, removeNonMutated = T)
coOncoplot(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', genes = g, removeNonMutated = T)

coBarplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut')

a <- ML_mut_vs_MMH_mut$results[which(ML_mut_vs_MMH_mut$results$MMH_mut>0&ML_mut_vs_MMH_mut$results$ML_mut==0),1]
a <- bitr(a$Hugo_Symbol,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

####比较ML_PPI/MMH_PPI中的区别
# ML_PPI <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster=='ML',5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('PI','PP'),5],]
# MMH_PPI <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster%in%c('MM','MH'),5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('PI','PP'),5],]
# 
# write.table(ML_PPI,'result/LUAD/mutation/ML_PPI.maf',sep = '\t',quote = F,row.names = F)
# write.table(MMH_PPI,'result/LUAD/mutation/MMH_PPI.maf',sep = '\t',quote = F,row.names = F)
ML_PPI <- read.maf(maf ='result/LUAD/mutation/ML_PPI.maf')
MMH_PPI <- read.maf(maf ='result/LUAD/mutation/MMH_PPI.maf')
ML_mut_vs_MMH_mut <- mafCompare(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI', minMut = 1, useCNV =FALSE)
forestPlot(mafCompareRes = ML_mut_vs_MMH_mut, pVal = 0.039765877, 
           color = c('royalblue', 'maroon'), geneFontSize = 0.8)#8cm*6cm

r1<-ML_mut_vs_MMH_mut$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI', genes = g, removeNonMutated = F)
coBarplot(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI')



a <- ML_mut_vs_MMH_mut$results[which(ML_mut_vs_MMH_mut$results$MMH_PPI>8&ML_mut_vs_MMH_mut$results$ML_PPI==0),1]
a <- bitr(a$Hugo_Symbol,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

####比较ML_TRU/MMH_TRU中的区别
# ML_TRU <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster=='ML',5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('TRU'),5],]
# MMH_TRU <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster%in%c('MM','MH'),5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('TRU'),5],]
# MMH_TRU <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster%in%c('MM','MH'),5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('TRU'),5],]
# write.table(ML_TRU,'result/LUAD/mutation/ML_TRU.maf',sep = '\t',quote = F,row.names = F)
# write.table(MMH_TRU,'result/LUAD/mutation/MMH_TRU.maf',sep = '\t',quote = F,row.names = F)
ML_TRU <- read.maf(maf ='result/LUAD/mutation/ML_TRU.maf')
MMH_TRU <- read.maf(maf ='result/LUAD/mutation/MMH_TRU.maf')
ML_mut_vs_MMH_mut <- mafCompare(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU', minMut = 1, useCNV =FALSE)
forestPlot(mafCompareRes = ML_mut_vs_MMH_mut, pVal = 0.004, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MMH_mut$results
g0<-r1[which(r1$pval<0.005),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU', genes = g, removeNonMutated = T)
coBarplot(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU')

a <- ML_mut_vs_MMH_mut$results[ML_mut_vs_MMH_mut$results$pval<0.005,1]
a <- bitr(a$Hugo_Symbol,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
##单独可视化有丝分裂突变基因
#a <- a[which(a$SYMBOL%in%ref_path_mitotic),1]
b <- ML_mut_vs_MMH_mut
b$results <- ML_mut_vs_MMH_mut$results[ML_mut_vs_MMH_mut$results$Hugo_Symbol%in%ref_path_mitotic,]
forestPlot(mafCompareRes = b, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
r1<-b$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', genes = g, removeNonMutated = F)

####比较ML_PPI/MMH_PPI中的区别
# ML_PPI <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster=='ML',5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('PI','PP'),5],]
# MMH_PPI <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster%in%c('MM','MH'),5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('PI','PP'),5],]
# 
# write.table(ML_PPI,'result/LUAD/mutation/ML_PPI.maf',sep = '\t',quote = F,row.names = F)
# write.table(MMH_PPI,'result/LUAD/mutation/MMH_PPI.maf',sep = '\t',quote = F,row.names = F)
ML_PPI <- read.maf(maf ='result/LUAD/mutation/ML_PPI.maf')
MMH_PPI <- read.maf(maf ='result/LUAD/mutation/MMH_PPI.maf')
ML_mut_vs_MMH_mut <- mafCompare(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI', minMut = 1, useCNV =FALSE)
forestPlot(mafCompareRes = ML_mut_vs_MMH_mut, pVal = 0.039765877, 
           color = c('royalblue', 'maroon'), geneFontSize = 0.8)#8cm*6cm

r1<-ML_mut_vs_MMH_mut$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI', genes = g, removeNonMutated = F)
coBarplot(m1 = ML_PPI, m2 = MMH_PPI, m1Name = 'ML_PPI', m2Name = 'MMH_PPI')



a <- ML_mut_vs_MMH_mut$results[which(ML_mut_vs_MMH_mut$results$MMH_PPI>8&ML_mut_vs_MMH_mut$results$ML_PPI==0),1]
a <- bitr(a$Hugo_Symbol,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

####比较ML_TRU/MMH_TRU中的区别,可能放在supplymental比较好
# ML_TRU <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster=='ML',5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('TRU'),5],]
# MMH_TRU <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$cluster%in%c('MM','MH'),5]&LUAD_mut$Tumor_Sample_Barcode%in%mutation_load[mutation_load$subtype%in%c('TRU'),5],]
# 
# write.table(ML_TRU,'result/LUAD/mutation/ML_TRU.maf',sep = '\t',quote = F,row.names = F)
# write.table(MMH_TRU,'result/LUAD/mutation/MMH_TRU.maf',sep = '\t',quote = F,row.names = F)
ML_TRU <- read.maf(maf ='result/LUAD/mutation/ML_TRU.maf')
MMH_TRU <- read.maf(maf ='result/LUAD/mutation/MMH_TRU.maf')
ML_mut_vs_MMH_mut <- mafCompare(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU', minMut = 1, useCNV =FALSE)
forestPlot(mafCompareRes = ML_mut_vs_MMH_mut, pVal = 0.004, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MMH_mut$results
g0<-r1[which(r1$pval<0.005),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU', genes = g, removeNonMutated = T)
coBarplot(m1 = ML_TRU, m2 = MMH_TRU, m1Name = 'ML_TRU', m2Name = 'MMH_TRU')

a <- ML_mut_vs_MMH_mut$results[ML_mut_vs_MMH_mut$results$pval<0.005,1]
a <- bitr(a$Hugo_Symbol,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
##单独可视化有丝分裂突变基因
#a <- a[which(a$SYMBOL%in%ref_path_mitotic),1]
b <- ML_mut_vs_MMH_mut
b$results <- ML_mut_vs_MMH_mut$results[ML_mut_vs_MMH_mut$results$Hugo_Symbol%in%ref_path_mitotic,]
forestPlot(mafCompareRes = b, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
r1<-b$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MMH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', genes = g, removeNonMutated = F)

####研究差异突变基因的重要性
####Depmap数据分析突变基因
##read database
# cell_line_crispr <- read.csv('/database/depmap/CRISPR_(DepMap_21Q4_Public+Score,_Chronos).csv')
# RNAi_raw <- read.csv('/database/depmap/RNAi_(Achilles+DRIVE+Marcotte,_DEMETER2).csv')
# crispr_raw <- read.csv('/database/depmap/CRISPR_gene_effect_after_process.csv',header = T,row.names = 1)
#从此处接着运行
cell_line <- cell_line_crispr
cell_line <- cell_line[,1:6]
crispr <- crispr_raw
cell_line <- RNAi_raw[,1:6]
RNAi <- RNAi_raw
rownames(RNAi) <- RNAi[,1]
RNAi <- RNAi[,-1:-6]
##提取相关crispr数据
luad_cell_crispr_ML_MM <- crispr[rownames(crispr)%in%cell_line[cell_line[,5]=='NSCLC Adenocarcinoma',1],
                                 colnames(crispr)%in%ML_mut_vs_MM_mut[[1]]$Hugo_Symbol[ML_mut_vs_MM_mut[[1]]$pval<0.003]]
luad_cell_crispr_MM_MH <- crispr[rownames(crispr)%in%cell_line[cell_line[,5]=='NSCLC Adenocarcinoma',1],
                                 colnames(crispr)%in%MM_mut_vs_MH_mut[[1]]$Hugo_Symbol[MM_mut_vs_MH_mut[[1]]$pval<0.0005]]
luad_cell_RNAi_ML_MM <- RNAi[rownames(RNAi)%in%cell_line[cell_line[,5]=='NSCLC Adenocarcinoma',1],
                             colnames(RNAi)%in%ML_mut_vs_MM_mut[[1]]$Hugo_Symbol[ML_mut_vs_MM_mut[[1]]$pval<0.003]]
luad_cell_RNAi_MM_MH <- RNAi[rownames(RNAi)%in%cell_line[cell_line[,5]=='NSCLC Adenocarcinoma',1],
                             colnames(RNAi)%in%MM_mut_vs_MH_mut[[1]]$Hugo_Symbol[MM_mut_vs_MH_mut[[1]]$pval<0.05]]

bk = unique(c(seq(-2,2, length=100)))
pheatmap::pheatmap(luad_cell_crispr_ML_MM,breaks = bk,color = c(colorRampPalette(c("navy", "white"))(50),
                                                                colorRampPalette(c("white","red"))(50)),cluster_cols = F)
bk = unique(c(seq(-2,2, length=100)))
pheatmap::pheatmap(luad_cell_RNAi_ML_MM,breaks = bk,color = c(colorRampPalette(c("navy", "white"))(50),
                                                              colorRampPalette(c("white","red"))(50)),cluster_cols = F)
bk = unique(c(seq(-2,2, length=100)))
pheatmap::pheatmap(luad_cell_crispr_MM_MH,breaks = bk,color = c(colorRampPalette(c("navy", "white"))(50),
                                                                colorRampPalette(c("white","red"))(50)),cluster_cols = T)
bk = unique(c(seq(-2,2, length=100)))
pheatmap::pheatmap(luad_cell_RNAi_MM_MH,breaks = bk,color = c(colorRampPalette(c("navy", "white"))(50),
                                                              colorRampPalette(c("white","red"))(50)),cluster_cols = F)
a <- ML_mut_vs_MM_mut[[1]]$Hugo_Symbol[ML_mut_vs_MM_mut[[1]]$pval<0.05]
a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

bk = unique(c(seq(-1.5,0, length=100)))
ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,
                   color = c(colorRampPalette(c("navy", "white"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                   cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                   annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm
pheatmap::pheatmap(luad_cell_crispr_MM_MH)
#Depmap分析有丝分裂通路中的基因对细胞生存的影响
mitotic_gene_expr_plot <- list()
mitotic_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  tryCatch({
    # a <- surv_sig_dgree[[j]][1:10,1][surv_sig_dgree[[j]][1:10,1]%in%ref_path_mitotic]
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    colnames(b) == cancer_cell_line[,1]
    colnames(b) <- cancer_cell_line[,2]
    bk = unique(c(seq(-1.5,0, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("navy", "white"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    mitotic_gene_expr_plot[[j]] <- a
    mitotic_gene_expr_crispr[[j]] <- b
    names(mitotic_gene_expr_plot)[j] <- cancer_name[j]
    names(mitotic_gene_expr_crispr)[j] <- cancer_name[j]
  }, error = function(e) {print(cancer_name[[j]])})
}

a <- mitotic_gene_expr_crispr[[6]]##LGG
b <- apply(a, 1, mean)
a <- a[order(b,decreasing = T),]
annotation_row <- as.data.frame(rownames(a))
rownames(annotation_row) <- annotation_row[,1]
annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
colnames(annotation_row) <- 'function'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
bk = unique(c(seq(-1.5,0, length=100)))
ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,
                   color = c(colorRampPalette(c("navy", "white"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                   cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                   annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm

a <- mitotic_gene_expr_crispr[[7]]##LIHC
b <- apply(a, 1, mean)
a <- a[order(b,decreasing = T),]
annotation_row <- as.data.frame(rownames(a))
rownames(annotation_row) <- annotation_row[,1]
annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
colnames(annotation_row) <- 'function'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
bk = unique(c(seq(-1.5,0, length=100)))
ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,
                   color = c(colorRampPalette(c("navy", "white"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                   cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                   annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm

a <- mitotic_gene_expr_crispr[[8]]##LUAD
b <- apply(a, 1, mean)
a <- a[order(b,decreasing = T),]
annotation_row <- as.data.frame(rownames(a))
rownames(annotation_row) <- annotation_row[,1]
annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
colnames(annotation_row) <- 'function'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
bk = unique(c(seq(-1.5,0, length=100)))
ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,
                   color = c(colorRampPalette(c("navy", "white"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                   cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                   annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm


# ####对所有样本进行分组
# subtype <- read.csv('/database/文献/肺癌的分子分型/肺腺癌/luad_subtype.csv')
# subtype <- subtype[,c('Tumor.ID','expression_subtype')]
# subtype[,2] <- subtype[,2]
# subtype[,2][subtype[,2]=='prox.-inflam'] <- 'PI'
# subtype[,2][subtype[,2]=='prox.-prolif.'] <- 'PP'
# luad_subtype <- lifetime[[8]]
# colnames(subtype)[1] <- 'case_id'
# luad_subtype <- merge(luad_subtype,subtype,by = 'case_id',all=F)

######FIG5
####LUAD层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,1]=='ML',2],],data[rownames(data)%in%b[b[,1]=='MM',2],],data[rownames(data)%in%b[b[,1]=='MH',2],])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                   annotation_colors = ann_colors)#4cm*8cm
##
##常用函数
library(maftools)
LUAD_mut_raw <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = '/database/TCGA/LUAD/mutation/information/clinical.tsv')
plotmafSummary(maf=LUAD_mut_raw, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
               titvRaw = FALSE,log_scale = F,showBarcodes = F)
oncoplot(maf=LUAD_mut_raw, top=10, borderCol=NULL)
lollipopPlot(maf=LUAD_mut_raw, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
luad.mutload <- tcgaCompare(maf=LUAD_mut_raw, cohortName="Download_LUAD")

####比较ML/MMH的突变情况
LUAD_mut <- LUAD_mut_raw@data
LUAD_mut$Tumor_Sample_Barcode <- substring(text = LUAD_mut$Tumor_Sample_Barcode,first = 1,last = 12)
LUAD_mut$Tumor_Sample_Barcode <- gsub(LUAD_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
ML_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$result=='ML',3],]
MM_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$result=='MM',3],]
MH_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$result=='MH',3],]
# write.table(ML_mut,'result/LUAD/mutation/ML_mut.maf',sep = '\t',quote = F,row.names = F)
# write.table(MM_mut,'result/LUAD/mutation/MM_mut.maf',sep = '\t',quote = F,row.names = F)
# write.table(MH_mut,'result/LUAD/mutation/MH_mut.maf',sep = '\t',quote = F,row.names = F)
ML_mut <- read.maf(maf ='result/LUAD/mutation/ML_mut.maf')
MM_mut <- read.maf(maf ='result/LUAD/mutation/MM_mut.maf')
MH_mut <- read.maf(maf ='result/LUAD/mutation/MH_mut.maf')
########ML/MMH的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = ML_mut)
TMB[[2]] <- tmb(maf = MM_mut)
TMB[[3]] <- tmb(maf = MH_mut)
names(TMB) <- c('ML_mut','MM_mut','MH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('ML',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('MM',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('MH',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('ML','MM','MH'))

library(ggplot2)
library(ggpubr)
# a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
#   geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
#   geom_jitter(shape=16, position = position_jitter(0.2))+
#   theme_classic()+
#   stat_compare_means(method = "t.test" )#5cm*4cm

a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("ML","MM"),c("ML","MH"),c('MM','MH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(28,32,28),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a

ML_mut_vs_MH_mut <- mafCompare(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
MM_mut_vs_MH_mut <- mafCompare(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
ML_mut_vs_MM_mut <- mafCompare(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = ML_mut_vs_MM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = ML_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = MM_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MH_mut$results
g0<-r1[which(r1$pval<0.001),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', genes = g, removeNonMutated = F)
coBarplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut')

####读取细胞系突变
library(stringr)
CCLE_mut <- read.csv('/database/depmap/突变信息/CCLE_mutations.csv')
CCLE_cell_line <- read.csv('/database/depmap/突变信息/sample_info.csv')
luad_cell_line <- CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1:3]
luad_cell_line_mut <- CCLE_mut[CCLE_mut$DepMap_ID%in%luad_cell_line$DepMap_ID,]

luad_cell_line_expr <- read.csv('/database/depmap/CRISPR_gene_dependency.csv',row.names = 1)
#luad_cell_line_expr <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%unique(luad_cell_line_mut$DepMap_ID),]

# luad_cell_line_expr <- crispr
# luad_cell_line_expr <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%unique(luad_cell_line_mut$DepMap_ID),]

a <- colnames(luad_cell_line_expr)
a <- str_split(a,'[..]',simplify = T)
colnames(luad_cell_line_expr) <- a[,1]
#ML_MM
ML_MM_mut_ddc <- data.frame()
sig_mut_list <- ML_mut_vs_MM_mut$results$Hugo_Symbol[ML_mut_vs_MM_mut$results$pval<0.05]
for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  ML_MM_mut_ddc[i,1] <- A
  a <- unique(luad_cell_line_mut$DepMap_ID[luad_cell_line_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  
  ML_MM_mut_ddc[i,2] <- e$estimate[1]
  ML_MM_mut_ddc[i,3] <- e$estimate[2]
  ML_MM_mut_ddc[i,4] <- e$p.value
}, error = function(e) {print('error')})
}
colnames(ML_MM_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value')
#ML_MH
ML_MH_mut_ddc <- data.frame()
sig_mut_list <- ML_mut_vs_MH_mut$results$Hugo_Symbol[ML_mut_vs_MH_mut$results$pval<0.05]
for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  ML_MH_mut_ddc[i,1] <- A
  a <- unique(luad_cell_line_mut$DepMap_ID[luad_cell_line_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  
  ML_MH_mut_ddc[i,2] <- e$estimate[1]
  ML_MH_mut_ddc[i,3] <- e$estimate[2]
  ML_MH_mut_ddc[i,4] <- e$p.value
}, error = function(e) {print('error')})
}
colnames(ML_MH_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value')
#MM_MH
MM_MH_mut_ddc <- data.frame()
sig_mut_list <- MM_mut_vs_MH_mut$results$Hugo_Symbol[MM_mut_vs_MH_mut$results$pval<0.05]
for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  MM_MH_mut_ddc[i,1] <- A
  a <- unique(luad_cell_line_mut$DepMap_ID[luad_cell_line_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  
  MM_MH_mut_ddc[i,2] <- e$estimate[1]
  MM_MH_mut_ddc[i,3] <- e$estimate[2]
  MM_MH_mut_ddc[i,4] <- e$p.value
}, error = function(e) {print('error')})
}
colnames(MM_MH_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value')

##对所有突变进行筛选
#all_mut
# LUAD_mut
# all_mut_ddc <- data.frame()
# sig_mut_list <- unique(LUAD_mut$Hugo_Symbol)
# for (i in 1:length(sig_mut_list)) {tryCatch({
#   A=sig_mut_list[i]
#   all_mut_ddc[i,1] <- A
#   a <- unique(luad_cell_line_mut$DepMap_ID[luad_cell_line_mut$Hugo_Symbol==A])
#   c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
#   d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
#   e <- t.test(c,d)
#   all_mut_ddc[i,2] <- e$estimate[1]
#   all_mut_ddc[i,3] <- e$estimate[2]
#   all_mut_ddc[i,4] <- e$p.value
# }, error = function(e) {print('error')})
# }
# colnames(all_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value')
# all_mut_ddc$diff_ddc <- all_mut_ddc$mut_cell_line-all_mut_ddc$wt_cell_line
# colnames(all_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value','diff_ddc')
##对所有突变进行筛选(全细胞系)
#all_mut
all_mut_ddc <- data.frame()
sig_mut_list <- unique(LUAD_mut$Hugo_Symbol)
all_mut_table <- data.frame()
for (i in 1:length(sig_mut_list)) {
  all_mut_table[i,1] <- sig_mut_list[i]
  all_mut_table[i,2] <- length(unique(LUAD_mut$Tumor_Sample_Barcode[which(LUAD_mut$Hugo_Symbol==sig_mut_list[i])]))
}
names(all_mut_table) <- c('gene','num')
all_mut_table$percent <- all_mut_table$num/length(unique(LUAD_mut$Tumor_Sample_Barcode))
all_mut_table$type[all_mut_table$percent>=0.05] <- 'high'
all_mut_table$type[all_mut_table$percent<0.05] <- 'low'


for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  all_mut_ddc[i,1] <- A
  a <- unique(CCLE_mut$DepMap_ID[CCLE_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  all_mut_ddc[i,2] <- e$estimate[1]
  all_mut_ddc[i,3] <- e$estimate[2]
  all_mut_ddc[i,4] <- e$p.value
  all_mut_ddc[i,5] <- all_mut_ddc[i,2]-all_mut_ddc[i,3]
  all_mut_ddc[i,6] <- length(c)
  all_mut_ddc[i,7] <- length(d)
}, error = function(e) {print('error')})
}
colnames(all_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value','diff_ddc','mut_num','wt_num')
all_mut_ddc$p_adj <- p.adjust(all_mut_ddc$p_value)
all_mut_ddc$ddc_rate <- 2*all_mut_ddc$diff_ddc/(all_mut_ddc$mut_cell_line+all_mut_ddc$wt_cell_line)
effect_mut <- all_mut_ddc[!is.na(all_mut_ddc$p_value)&all_mut_ddc$p_value<0.05&abs(all_mut_ddc$diff_ddc)>0.01&abs(all_mut_ddc$ddc_rate)>0.10,]

####对每个病人进行定义,画出每个病人的高频低频突变的堆叠柱状图
##画柱状图看统计情况堆叠柱状图
library(ggplot2)
library(tidyr)
patient_mut <- data.frame(patient_id)
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  patient_mut[i,2] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='high']])
  patient_mut[i,3] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='low']])
}
colnames(patient_mut) <- c('patient_id','high','low')
a <- patient_id[order(apply(patient_mut[,2:3], 1, sum),decreasing = T)]
#rownames(patient_mut) <- patient_id

patient_mut <- pivot_longer(data = patient_mut,cols = 2:3,
                            names_to = "mut_frequency",##这一个参数是将列名命名为sample_size
                            values_to = "mut_frequency_value")##col

patient_mut$patient_id <- factor(patient_mut$patient_id,levels = a)
patient_mut$mut_frequency <- factor(patient_mut$mut_frequency,levels = c('high','low'))

p <- ggplot(border=0,patient_mut, aes(x=patient_id, y=mut_frequency_value,fill=mut_frequency)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack", width=1,size=0.25)+
  scale_fill_manual(values=c("red","#399938"))+
  labs(x = "patient(n=557)",y = "",title='mutation per patient')+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()+
  theme(axis.ticks.x = element_blank(),axis.text.x = element_blank())#6cm*5cm

p#6cm*5cm

##计算病人突变评分
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
patient_mut_score <- data.frame()
for (i in 1:length(patient_id)) {
  patient_mut_score[i,1] <- patient_id[i]
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  a <- all_mut_ddc[all_mut_ddc$Gene%in%a&all_mut_ddc$p_value<0.05&!is.na(all_mut_ddc$p_value),]
  patient_mut_score[i,2] <- nrow(a)
  patient_mut_score[i,3] <- sum(abs(a$diff_ddc))
}


patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
patient_mut_score <- data.frame()
for (i in 1:length(patient_id)) {
  patient_mut_score[i,1] <- patient_id[i]
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  a <- effect_mut[effect_mut$Gene%in%a&effect_mut$p_value<0.05&!is.na(effect_mut$p_value),]
  patient_mut_score[i,2] <- nrow(a)
  patient_mut_score[i,3] <- sum(abs(a$mut_cell_line))
}

########与TMB结合分析
TMB <- list()
TMB[[1]] <- tmb(maf = ML_mut)
TMB[[1]] <- as.data.frame(TMB[[1]])
for (i in 1:nrow(TMB[[1]])) {
  TMB[[1]][i,5] <- patient_mut_score[patient_mut_score$V1%in%TMB[[1]][i,1],3]
}
TMB[[2]] <- tmb(maf = MM_mut)
TMB[[2]] <- as.data.frame(TMB[[2]])
for (i in 1:nrow(TMB[[2]])) {
  TMB[[2]][i,5] <- patient_mut_score[patient_mut_score$V1%in%TMB[[2]][i,1],3]
}
TMB[[3]] <- tmb(maf = MH_mut)
TMB[[3]] <- as.data.frame(TMB[[3]])
for (i in 1:nrow(TMB[[3]])) {
  TMB[[3]][i,5] <- patient_mut_score[patient_mut_score$V1%in%TMB[[3]][i,1],3]
}
names(TMB) <- c('ML_mut','MM_mut','MH_mut')
##画箱线图
cbind(TMB[[1]],rep('ML',nrow(TMB[[1]])))
cbind(TMB[[2]],rep('MM',nrow(TMB[[2]])))
cbind(TMB[[3]],rep('MH',nrow(TMB[[3]])))
TMB_plot <- rbind(cbind(TMB[[1]]),
                  cbind(TMB[[2]]),
                  cbind(TMB[[3]]))
TMB_plot$cluster <- c(rep('ML',nrow(TMB[[1]])),rep('MM',nrow(TMB[[2]])),rep('MH',nrow(TMB[[3]])))
colnames(TMB_plot)[5] <- 'mut_score'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('ML','MM','MH'))

library(ggplot2)
library(ggpubr)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  scale_fill_manual(values = c(ML = "#89C890",MM = "#4498F2", MH = "#ED5163"))+
  theme_classic()+
  geom_signif(comparisons = list(c("ML","MM"),c("ML","MH"),c('MM','MH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(30,32,30),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=mut_score,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  scale_fill_manual(values = c(ML = "#89C890",MM = "#4498F2", MH = "#ED5163"))+
  theme_classic()+
  geom_signif(comparisons = list(c("ML","MM"),c("ML","MH"),c('MM','MH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(11,12,11),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
a
##画整体突变基因图

library(maftools)
LUAD_mut_raw <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = '/database/TCGA/LUAD/mutation/information/clinical.tsv')
luad.pfam <- pfamDomains(maf=LUAD_mut_raw, AACol="HGVSp_Short", top=10)
plotmafSummary(maf=LUAD_mut_raw, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
               titvRaw = FALSE,log_scale = F,showBarcodes = F)
oncoplot(maf=LUAD_mut_raw, top=20, borderCol=NULL)
lollipopPlot(maf=LUAD_mut_raw, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
luad.mutload <- tcgaCompare(maf=LUAD_mut_raw, cohortName="Download_LUAD")

ML_mut_vs_MH_mut <- mafCompare(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
MM_mut_vs_MH_mut <- mafCompare(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
ML_mut_vs_MM_mut <- mafCompare(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = ML_mut_vs_MM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = ML_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = MM_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MM_mut$results
r1<-MM_mut_vs_MH_mut$results
r1<-ML_mut_vs_MH_mut$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML', m2Name = 'MM', genes = g1, removeNonMutated = T)
coOncoplot(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM', m2Name = 'MH', genes = g1, removeNonMutated = F)
coOncoplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML', m2Name = 'MH', genes = g1, removeNonMutated = T)
#3cm*15cm
coBarplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut')

####Nest定义每个病人
nest_pathway <- read.csv('/database/IAS/NeST Map - Main Model default node.csv')
nest_pathway_list <- list()
for (i in 1:nrow(nest_pathway)) {
  a <- nest_pathway[i,4]
  nest_pathway_list[[i]] <- str_split(a,' ',simplify = F)[[1]]
}
names(nest_pathway_list) <- nest_pathway$Annotation

path_num_cal <- function(x){
  x=nest_pathway_list[[x]]
  length(which(a%in%x))
}
patient_pathway <- list()
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  a <- a[a%in%ref_all_mut_ddc$Gene]
  b <- as.data.frame(names(nest_pathway_list))
  b[,2] <- apply(b, 1, path_num_cal)
  colnames(b) <- c('pathway_name','map_mut_num')
  patient_pathway[[i]] <- b
}
names(patient_pathway) <- patient_id

patient_pathway_table <- data.frame(names(nest_pathway_list))
rownames(patient_pathway_table) <- patient_pathway_table[,1]
for (i in 1:length(patient_pathway)) {
  patient_pathway_table[,i] <- patient_pathway[[i]][,2]
  patient_pathway_table[patient_pathway_table[,i]>0,i] <- 1
  patient_pathway_table[patient_pathway_table[,i]==0,i] <- 0
}
colnames(patient_pathway_table) <- names(patient_pathway)

patient_pathway_table <- patient_pathway_table[apply(patient_pathway_table, 1, sum)>0,]

result
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
##画热图比较这两组样本的基因
hotmap <- cbind(patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='ML',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MM',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
##画瀑布图
diff_pathway_list <- data.frame(rownames(hotmap))
for (i in 1:nrow(diff_pathway_list)) {
  c <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='ML',3]]
  d <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='MM',3]]
  e <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='MH',3]]
  diff_pathway_list[i,2] <- sum(c)
  diff_pathway_list[i,3] <- sum(d)
  diff_pathway_list[i,4] <- sum(e)
  diff_pathway_list[i,5] <- t.test(c,d)$p.value
  diff_pathway_list[i,6] <- t.test(c,e)$p.value
  diff_pathway_list[i,7] <- t.test(d,e)$p.value
}
colnames(diff_pathway_list) <- c('pathway','ML','MM','MH','ML_MM','ML_MH','MM_MH')
c <- apply(hotmap, 1, sum)
c <- cbind(rownames(hotmap),c)
c <- as.data.frame(c)
colnames(c) <- c('nest','num')
c <- c[order(as.numeric(c[,2]),decreasing = F),]
for (i in 1:nrow(c)) {
  a <- as.data.frame(hotmap[i,])
  hotmap <- cbind(hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==1]],
                  hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==0]])
}
hotmap <- hotmap[rownames(c)[nrow(c):1],]
a <- pheatmap::pheatmap(hotmap,cluster_col = T,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- as.data.frame(cutree(a$tree_col,k=2))
hotmap <- cbind(hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==1]],
                hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==2]])

hotmap <- cbind(hotmap[,colnames(hotmap)%in%b[b[,1]=='ML',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MM',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MH',3]])
hotmap <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[!(diff_pathway_list$ML_MM>0.05&diff_pathway_list$ML_MH>0.05&diff_pathway_list$MM_MH>0.05)],]


a <- pheatmap::pheatmap(hotmap,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$ML_MM<0.05],]
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$MM_MH<0.05],]
a <- pheatmap::pheatmap(a,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm



diff_pathway_list$ML_specific[(diff_pathway_list$ML/179)>(diff_pathway_list$MM/258)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$ML/179)>(diff_pathway_list$MH/67)&diff_pathway_list$ML_MH<0.05] <- '1'
diff_pathway_list$MM_specific[(diff_pathway_list$MM/258)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$MM/258)>(diff_pathway_list$MH/67)&diff_pathway_list$MM_MH<0.05] <- '1'
diff_pathway_list$MH_specific[(diff_pathway_list$MH/67)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MH<0.05&
                                (diff_pathway_list$MH/67)>(diff_pathway_list$MM/258)&diff_pathway_list$MM_MH<0.05] <- '1'
#write.csv(diff_pathway_list,'result/Figure/AI_plot_new/fig4/v2/样本差异突变通路.csv',row.names = F)
####验证结果
a <- patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]]
colnames(a)[a["Proximal RTK signaling",]==1]



####火山图展示有效突变基因
library(ggpubr)
library(ggplot2)
library(ggthemes)
library(ggrepel)
mut_gene_plot <- all_mut_ddc[!is.na(all_mut_ddc$p_value),]
mut_gene_plot$'-lg(pvalue)' <- -1*log10(mut_gene_plot$p_value)
mut_gene_plot$label <- NA
mut_gene_plot$label[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05]
mut_gene_plot$label[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05]
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05] <- 'effective'
mut_gene_plot$group[!(abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05)] <- 'invalid'


# DEG_data$Group <- "not-siginficant"
# DEG_data$Group[which((DEG_data$FDR < 0.05) & DEG_data$IncLevelDifference > 0.5)] <- "up-regulated"
# DEG_data$Group[which((DEG_data$FDR < 0.05) & DEG_data$IncLevelDifference < -0.5)] <- "down-regulated"
# DEG_data$FDR <- -log10(DEG_data$FDR) # 对差异基因矫正后p-value进行log10()转换
# DEG_data$FDR[!is.finite(DEG_data$FDR)] <- 15
# table(DEG_data$Group)
mut_gene_plot <- mut_gene_plot[order(mut_gene_plot$`-lg(pvalue)`),]#对差异表达基因调整后的p值进行排序
mut_gene_plot$`-lg(pvalue)`[mut_gene_plot$`-lg(pvalue)`>25] <- 25
#火山图中添加点(数据构建)
# up_label <- DEG_data[DEG_data$Group == "up-regulated",]
# down_label <- DEG_data[DEG_data$Group == "down-regulated",]
# deg_label_gene <- data.frame(gene = c(up_label$GeneID,down_label$GeneID),
#                              label = c(up_label$GeneID,down_label$GeneID))
# DEG_data$gene <- DEG_data$GeneID
# DEG_data <- merge(DEG_data,deg_label_gene,by = 'gene',all = T)

#添加特定基因label
ggscatter(mut_gene_plot,x = "ddc_rate",y = "-lg(pvalue)",color = "group",
          palette = c('#399938','gray'), label = mut_gene_plot$label,
          repel = T, ylab = "-lg(pvalue)", size = 1) + 
  theme_base()+
  theme(element_line(size = 0),element_rect(size = 1.5))+ #坐标轴线条大小设置
  scale_y_continuous(limits = c(0,26))+
  scale_x_continuous(limits = c(-2,2))+
  geom_point(aes(size=abs(diff_ddc),color=group))+
  geom_hline(yintercept = -log10(0.05),linetype = "dashed")+
  geom_vline(xintercept = c(-0.1,0.1),linetype = "dashed")#7cm*6cm

##画差异通路气泡图
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
diff_pathway_plot <- diff_pathway_list
diff_pathway_plot$ML <- diff_pathway_plot$ML/sum(b$result=='ML')
diff_pathway_plot$MM <- diff_pathway_plot$MM/sum(b$result=='MM')
diff_pathway_plot$MH <- diff_pathway_plot$MH/sum(b$result=='MH')
diff_pathway_plot$ML_MM_log2FC <- log2(diff_pathway_plot$ML/diff_pathway_plot$MM)
diff_pathway_plot$ML_MH_log2FC <- log2(diff_pathway_plot$ML/diff_pathway_plot$MH)
diff_pathway_plot$MM_MH_log2FC <- log2(diff_pathway_plot$MM/diff_pathway_plot$MH)

diff_pathway_plot$ML_MH[is.nan(diff_pathway_plot$ML_MH)] <- 1
diff_pathway_plot$MM_MH[is.nan(diff_pathway_plot$MM_MH)] <- 1
diff_pathway_plot$ML_MM_log2FC[diff_pathway_plot$ML_MM_log2FC==Inf] <- 4
diff_pathway_plot$ML_MM_log2FC[diff_pathway_plot$ML_MM_log2FC==-Inf] <- -4
diff_pathway_plot$ML_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==Inf] <- 4
diff_pathway_plot$ML_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==-Inf] <- -4
diff_pathway_plot$MM_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==Inf] <- 4
diff_pathway_plot$MM_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==-Inf] <- -4


diff_pathway_plot <- diff_pathway_plot[!(diff_pathway_plot$ML_MM>0.05&
                                           diff_pathway_plot$ML_MH>0.05&
                                           diff_pathway_plot$MM_MH>0.05),]
diff_pathway_plot <- diff_pathway_plot[!(abs(diff_pathway_plot$ML_MM_log2FC)<1&
                                           abs(diff_pathway_plot$ML_MH_log2FC)<1&
                                           abs(diff_pathway_plot$MM_MH_log2FC)<1),]
colnames(diff_pathway_plot)[1] <- 'Annotation'
diff_pathway_plot <- merge(diff_pathway_plot,nest_pathway[,c('Annotation','Size')],all=F,by='Annotation')
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Size<50,]
a <- c(diff_pathway_plot[order(diff_pathway_plot$ML_MM,decreasing = F)[1:10],1],
       diff_pathway_plot[order(diff_pathway_plot$ML_MH,decreasing = F)[1:10],1],
       diff_pathway_plot[order(diff_pathway_plot$MM_MH,decreasing = F)[1:10],1])
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Annotation%in%a,]

a <- pivot_longer(diff_pathway_plot[,c('Annotation','ML_MM','ML_MH','MM_MH')],cols = 2:4,
                  names_to = 'compare_object',values_to = 'p_value')
b <- pivot_longer(diff_pathway_plot[,c('Annotation','ML_MM_log2FC','ML_MH_log2FC','MM_MH_log2FC')],cols = 2:4,
                  names_to = 'compare_object',values_to = 'log2FC')
diff_pathway_plot <- cbind(a,b[,3])
diff_pathway_plot$p_value <- round(as.numeric(diff_pathway_plot$p_value),2)
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$p_value<0.05,]
diff_pathway_plot$compare_object <- factor(diff_pathway_plot$compare_object,
                                           levels = c('ML_MM','ML_MH','MM_MH'))
a <- as.data.frame(unique(diff_pathway_plot$Annotation))
#write.csv(a,'result/Figure/AI_plot_new/fig4/v2/annotation.csv')
a <- read.csv('result/Figure/AI_plot_new/fig4/v2/annotation.csv',row.names = 1)
a <- a[c(which(a$function.=='other process'),
         which(a$function.=='signaling process'),
         which(a$function.=='cell cycle')),]
diff_pathway_plot$Annotation <- factor(diff_pathway_plot$Annotation,levels = a$pathway)

y_color <- as.data.frame(a)
colnames(y_color)[2] <- 'fuction'
y_color[y_color[,2]=='other process',3] <- 'black'
y_color[y_color[,2]=='cell cycle',3] <- 'red'
y_color[y_color[,2]=='signaling process',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$type <- factor(y_color$type,levels = c('cell cycle','signaling process','other process'))
y_color$xmin <- -Inf
y_color$xmax <- Inf
y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

plot <- ggplot(diff_pathway_plot,aes(x=compare_object,y=Annotation))+
  geom_point(aes(size=abs(`log2FC`),color=`p_value`))+
  scale_color_gradient(high="#1E08F7",low="#F20808")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=0,hjust = 0.5,vjust=0.5),
        axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='other process'),
                                                           which(y_color$type=='signaling process'),
                                                           which(y_color$type=='cell cycle'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=c('red','blue','black'))+
  labs(x=NULL,y=NULL,title = 'the pathway of different cluster')#6cm*7cm

####基因与药物互作分析
MM_mut_gene <- MM_mut@data
a <- as.data.frame(unique(MM_mut_gene$Hugo_Symbol))
for (i in 1:nrow(a)) {
  a[i,2] <- sum(MM_mut_gene$Hugo_Symbol==a[i,1])
}
colnames(a) <- c('gene','num')
MM_mut_gene <- a
MM_mut_gene <- MM_mut_gene[MM_mut_gene$gene%in%ref_all_mut_ddc$Gene,]
# MM_mut_gene <- MM_mut_gene[MM_mut_gene$gene%in%nest_pathway_list[['Cell cycle']],]
a <- list()
for (i in 1:nrow(MM_mut_gene)) {
  tryCatch({
    a[[i]] <- drugInteractions(genes=MM_mut_gene$gene[i], drugs=TRUE)
  }, error = function(e) {print('error')})
}
names(a) <- MM_mut_gene$gene
b <- a[[1]]
for (i in 2:length(a)) {
  tryCatch({
    b <- rbind(b,a[[i]])
  }, error = function(e) {print('error')})
}

A549_mut <- CCLE_mut[CCLE_mut$DepMap_ID==CCLE_cell_line$DepMap_ID[CCLE_cell_line$cell_line_name=='A549'],]
A549_mut <- A549_mut[A549_mut$Hugo_Symbol%in%ref_all_mut_ddc$Gene,]
A549_mut$Hugo_Symbol%in%b$Gene

c <- ref_all_mut_ddc[ref_all_mut_ddc$Gene%in%A549_mut$Hugo_Symbol,]

####先不关心突变，直接筛选药效好的药物，然后看这些药物的通路是否与周期蛋白和PIK3CA相关
####drug effection significance
####药物筛选
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA

##画韦恩图
venn.plot <- venn.diagram(x = list(cMAP_A549=All_drug,GDSC_A549=gdsc_A549_drug),
                          category.names = c('cMAP_A549','GDSC_A549'),
                          filename = NULL,
                          scaled = F,
                          height = 1500, width = 1500, resolution =600,
                          alpha=c(0.6, 0.6),
                          fill=c(colors()[616], colors()[38]), 
                          lwd=rep(1,2), cex=0.45, 
                          fontfamily = "serif", fontface = "bold",
                          cat.dist=c(-0.07, -0.07),
                          output=TRUE,
                          area.vector = 0,
                          cat.pos=c(280, 80), #位置
                          cat.cex=0.45)##画韦恩图

pdf("result/Figure/luad_drug_screen_5.pdf")
grid.draw(venn.plot)
dev.off()
##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
pheatmap::pheatmap(luad_overlap[,2:10],clustering_method = 'ward.D2')
bk = unique(c(seq(-4,4, length=200)))
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:10]),breaks = bk,show_rownames = T,treeheight_row = 0,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = F,cluster_rows = T,cluster_cols = T)
cluster <- hotmap$tree_col
plot(cluster,hang = -1,cex=0.6,axes=FALSE,ann=FALSE)
cut <- as.data.frame(cutree(cluster,2))
annotation_row <- cut
colnames(annotation_row) <- 'cluster'
annotation_row[annotation_row[,1]==1,1] <- 'mitotic_i'
annotation_row[annotation_row[,1]==2,1] <- 'con'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
ann_colors = list(cluster = c(con="#ED5163", mitotic_i="#4498F2")) 
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:10]),breaks = bk,show_rownames = T,treeheight_row = 0,annotation_col = annotation_row,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = F,cluster_rows = T,cluster_cols = T,
                             annotation_colors = ann_colors)#6cm*8cm

drug_effection <- list()
drug_effection[[1]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==1],]
drug_effection[[2]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==2],]
names(drug_effection) <- c('mitotic_i','mitotic_con')
for (i in 1:2) {
  a <- aggregate(drug_effection[[i]]$V11,by=list(drug_effection[[i]][,1]),FUN=mean)
  drug_effection[[i]] <- a
}
for (i in 1:2) {
  drug_effection[[i]] <- cbind(drug_effection[[i]],rep(c('mitotic_i','con')[i],nrow(drug_effection[[i]])))
  colnames(drug_effection[[i]]) <- c('drug_name','cell_viability','cluster')
}
#drug_effection[[1]] <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
a <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
b <- drug_effection[[2]][!drug_effection[[2]]$drug_name%in%drug_effection[[1]]$drug_name,]
drug_effection_plot <- rbind(a,b)

#drug_effection_plot <- rbind(drug_effection[[1]],
#                            drug_effection[[2]])
drug_effection_plot$cluster <- as.factor(drug_effection_plot$cluster)

library(ggplot2)
library(ggpubr)
p = ggplot(drug_effection_plot, aes(x=cluster, y=cell_viability,fill=cluster)) + 
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)
p+geom_jitter(shape=16, position = position_jitter(0.2))+
  stat_compare_means(method = "t.test" )

ggplot(drug_effection_plot, aes(x=cluster, y=cell_viability,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test" )#5cm*4cm

##
drug_info <- read.csv('/database/GDSC/drug_IC50/screened_compunds_rel_8.2.csv')
drug_info$name <- tolower(drug_info$DRUG_NAME)
effect_drug_info <- drug_info[drug_info$name%in%drug_effection_plot$drug_name[drug_effection_plot$cluster=='mitotic_i'],]

##查看是否有相应的细胞系数据
#获取PIK3CA，KRAS突变细胞系名称
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='KRAS'])
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='PIK3CA'&
                                                      LUAD_cell_mut$DepMap_ID%in%P_K_mut_cell_line])
CCLE_cell_line$stripped_cell_line_name[CCLE_cell_line$DepMap_ID%in%P_K_mut_cell_line]

gdsc_SW1573 <- gdsc[gdsc$CELL_LINE_NAME=='SW1573',]
gdsc_SW1573 <- gdsc_SW1573[gdsc_SW1573$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_SW1573 <- gdsc_SW1573[gdsc_SW1573$DATASET=='GDSC2',]
gdsc_A549 <- gdsc[gdsc$CELL_LINE_NAME=='A549',]
gdsc_A549 <- gdsc_A549[gdsc_A549$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_A549 <- gdsc_A549[gdsc_A549$DATASET=='GDSC2',]

c <- gdsc_A549[-8,c(5,9,19)]
d <- gdsc_SW1573[-8,c(5,9,19)]
t.test(c[,3], d[,3], paired = TRUE)
a <- rbind(c,d)
ggplot(a, aes(x=CELL_LINE_NAME, y=Z_SCORE,fill=CELL_LINE_NAME)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test",paired = T )#5cm*4cm

####联合用药预测(这部分可能还是得实验)
drug_combine_raw <- read.csv('/database/DrugComb/summary_v_1_5.csv')
drug_combine <- drug_combine_raw
drug_combine$drug_row <- tolower(drug_combine$drug_row)
drug_combine$drug_col <- tolower(drug_combine$drug_col)
drug_combine <- drug_combine[c(which(drug_combine$drug_row%in%effect_drug_info$name),
                               which(drug_combine$drug_col%in%effect_drug_info$name),]

####BUB1B的解释
#BUB1B的基因依赖性
luad_cell_line_expr[a[a%in%rownames(luad_cell_line_expr)],'BUB1B']
luad_cell_line_expr['ACH-002157','BUB1B']

a <- CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1]
a <- CCLE_mut[CCLE_mut$DepMap_ID%in%a,]

#计算在药物作用下与BUB1B相关性最强的基因群
luad <- cell_line_expr_drug[[8]][[7]]
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA

##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
write.csv(luad_overlap,'result/A549_effect_drug_list.csv')

####读取A549细胞系有效药物的基因表达数据
A549_drug_gene_res <- read.csv('/database/cMAP/A549_cell_drug_expr_data.csv')
library(clusterProfiler)
a <- bitr(A549_drug_gene_res[,1],fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
          toType = c('SYMBOL'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
colnames(A549_drug_gene_res)[1] <- 'ENTREZID'
A549_drug_gene_res <- merge(a,A549_drug_gene_res,by='ENTREZID',all=F)
rownames(A549_drug_gene_res) <- A549_drug_gene_res[,2]
A549_drug_gene_res <- A549_drug_gene_res[,-1:-2]

cor_p_value <- function(x){cor.test(BUB1B_expr,as.numeric(x),method = 'spearman')$p.value}
cor_estimate <- function(x){cor.test(BUB1B_expr,as.numeric(x),method = 'spearman')$estimate}

BUB1B_expr <- as.numeric(A549_drug_gene_res['BUB1B',])##药物作用下的BUB1B表达
BUB1B_cor <- data.frame(rownames(A549_drug_gene_res))##
BUB1B_cor$drug_cor <- apply(A549_drug_gene_res,1,cor_estimate)
BUB1B_cor$drug_p_value <- apply(A549_drug_gene_res,1,cor_p_value)
BUB1B_cor$drug_p_adj <- p.adjust(BUB1B_cor$drug_p_value)

LUAD_TCGA_expr <- expr_data_raw[[8]]
LUAD_TCGA_expr <- LUAD_TCGA_expr[rownames(LUAD_TCGA_expr)%in%rownames(A549_drug_gene_res),]
LUAD_TCGA_expr <- LUAD_TCGA_expr[rownames(A549_drug_gene_res),]
rownames(LUAD_TCGA_expr) <- rownames(A549_drug_gene_res)
LUAD_TCGA_expr <- as.matrix(LUAD_TCGA_expr)
LUAD_TCGA_expr[is.na(LUAD_TCGA_expr)] <- 0
BUB1B_expr <- as.numeric(LUAD_TCGA_expr['BUB1B',])


BUB1B_cor$TCGA_cor <- apply(LUAD_TCGA_expr,1,cor_estimate)
BUB1B_cor$TCGA_p_value <- apply(LUAD_TCGA_expr,1,cor_p_value)
BUB1B_cor$TCGA_p_adj <- p.adjust(BUB1B_cor$TCGA_p_value)

a <- BUB1B_cor[which(BUB1B_cor$drug_cor>0.5&BUB1B_cor$TCGA_cor>0.5),1]
b <- BUB1B_cor[BUB1B_cor[,1]%in%a,]
a <- bitr(a,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
barplot(a,label_format = 60)

#可以看到，在正常状态下与药物作用下与BUB1B都高度相关的基因（>0.5），它富集到的普遍是DNA复制检查点和G2/M检查点，以此可以解释为什么BUB1B在药物作用下会升高

####开始进行免疫的分析
##逻辑，通路富集到很多免疫通路，然后通过hub gene将免疫表型分为三组，
##发现可以比较好的预测预后，生存分析和相关性发现CD8细胞浸润程度差异比较大
##然后分析发现CD8高低浸润样本的差异基因中包含IRF1，这个基因与感染相关。接下来
##分析三组样本中这个基因的表达情况是否有差异，然后分析肿瘤中细菌含量与是否与
##这个基因的表达相关。
##此外也分析一下肿瘤突变负荷与免疫浸润是否有相关性

####读取TCGA微生物组数据并处理
# BRCA_count <- read.csv('/database/TCGA/BRCA/TCGA_BRCA_counts.csv',row.names = 1)
# BRCA_count <- BRCA_count[,colnames(BRCA_count)%in%colnames(expr_data_raw[[2]])]
# microbio <- read.csv('/database/TCGA/TCGA_microbio_analysis/Kraken_pipeline/Kraken-TCGA-Raw-Data-All-18116-Samples.csv',row.names = 1)
# sample_info <- read.csv('/database/TCGA/TCGA_microbio_analysis/bam_microbio_ID_align/clinical.csv',header = T)
# # sample_info_2 <- read.table('/database/TCGA/TCGA_microbio_analysis/bam_microbio_ID_align/gdc_sample_sheet.2022-05-29.tsv',sep = '\t',header = T)
# microbio_ID <- read.csv('/database/TCGA/TCGA_microbio_analysis/SHOGUN_pipeline/Metadata-TCGA-SHOGUN-13517-Samples.csv')
# microbio_ID <- microbio_ID[microbio_ID$sample_type=='Primary Tumor'&
#                              microbio_ID$experimental_strategy=='RNA-Seq',]
# microbio_ID <- microbio_ID[!microbio_ID$radiation_therapy_site_label%in%c('Distant Recurrence','Distant site','Local Recurrence'),]
# 
# microbio_ID <- microbio_ID[!microbio_ID$X%in%microbio_ID$X[duplicated(microbio_ID$X)],]
# sample_info <- sample_info[!duplicated(sample_info[,1]),]
# sample_info <- sample_info[,1:2]
# microbio_ID <- microbio_ID[,c(6,1)]
# colnames(microbio_ID)[1] <- 'case_id'
# microbio_ID <- merge(microbio_ID,sample_info,by='case_id',all=F)
# microbio_ID <- microbio_ID[!microbio_ID[,3]%in%microbio_ID[,3][duplicated(microbio_ID[,3])],]
# microbio <- microbio[rownames(microbio)%in%microbio_ID[,2],]
# TCGA_microbio <- cbind(rownames(microbio),apply(microbio, 1, sum))
# colnames(TCGA_microbio) <- c('id','microbio_content')
# colnames(microbio_ID)[2] <- c('id')
# BRCA_microbio <- merge(microbio_ID[,2:3],TCGA_microbio,by='id',all=F)
# a <- colnames(BRCA_count)
# a <- substring(a,1,12)
# b <- apply(BRCA_count, 2, sum)
# a <- cbind(a,b)
# a <- a[!a[,1]%in%a[,1][duplicated(a[,1])],]
# BRCA_microbio$case_submitter_id <- gsub(BRCA_microbio$case_submitter_id,pattern = '-',replacement = '.')
# colnames(a) <- c('case_submitter_id','human_count')
# BRCA_microbio <- merge(BRCA_microbio,a,by='case_submitter_id',all=F)
# BRCA_microbio$normalized <- scale(as.numeric(BRCA_microbio$microbio_content)/as.numeric(BRCA_microbio$human_count))
# a <- expr_data_raw[[2]]
# a <- a['IRF1',]
# a <- cbind(colnames(a),as.numeric(a))
# a[,1] <- substring(a[,1],1,12)
# colnames(a) <- c('case_submitter_id','IRF1')
# BRCA_microbio <- merge(BRCA_microbio,a,by='case_submitter_id',all=F)
# cor(as.numeric(BRCA_microbio$normalized),as.numeric(BRCA_microbio$IRF1),method = 'spearman')
# cor(as.numeric(BRCA_microbio$microbio_content),as.numeric(BRCA_microbio$IRF1),method = 'spearman')

##分析失败，没有结果

####还是从突变进行分析
#BRCA突变分析
##maftools走流程
#maf数据整合单样本整合多样本
# text <- dir('/database/TCGA/BRCA/mutation/raw_data/')
# read.maf(paste('/database/TCGA/BRCA/mutation/raw_data/',text[i],sep = ''))
# library(stringr)
# a <- read.maf(paste('/database/TCGA/BRCA/mutation/raw_data/',text[1],sep = ''))
# BRCA_mut_raw <- a@data
# for (i in 988:length(text)) {
#   tryCatch({
#     a <- read.maf(paste('/database/TCGA/BRCA/mutation/raw_data/',text[i],sep = ''))
#     BRCA_mut_raw <- rbind(BRCA_mut_raw,a@data)
#   }, error = function(e) {print('error')})
# }
# BRCA_mut <- BRCA_mut_raw
# BRCA_mut$Tumor_Sample_Barcode <- substring(text = BRCA_mut$Tumor_Sample_Barcode,first = 1,last = 12)
#write.table(BRCA_mut,'/database/TCGA/BRCA/mutation/TCGA_BRCA_mutation.maf',sep = '\t',quote = F,row.names = F)
BRCA_mut_raw <- read.maf(maf = '/database/TCGA/BRCA/mutation/TCGA_BRCA_mutation.maf')
BRCA_mut <- BRCA_mut_raw
brca.pfam <- pfamDomains(maf=BRCA_mut, AACol="HGVSp_Short", top=10)
plotmafSummary(maf=BRCA_mut, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
               titvRaw = FALSE,log_scale = F,showBarcodes = F)
oncoplot(maf=BRCA_mut, top=20, borderCol=NULL)
lollipopPlot(maf=BRCA_mut, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
brca.mutload <- tcgaCompare(maf=BRCA_mut, cohortName="Download_LUAD")

####比较BRCA亚型的突变情况
####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:9,1]),]))
#data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
annotation_col[annotation_col[,1]==2,1] <- 'IM'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm


a <- log2(t(a)+1)
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E")) 
pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(60),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(140)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col)
b <- annotation_col
b$sample_id <- rownames(b)
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
IL_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IL',4],]
IM_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IM',4],]
IH_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IH',4],]
write.table(IL_mut,'result/BRCA/mutation/IL_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(IM_mut,'result/BRCA/mutation/IM_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(IH_mut,'result/BRCA/mutation/IH_mut.maf',sep = '\t',quote = F,row.names = F)
IL_mut <- read.maf(maf ='result/BRCA/mutation/IL_mut.maf')
IM_mut <- read.maf(maf ='result/BRCA/mutation/IM_mut.maf')
IH_mut <- read.maf(maf ='result/BRCA/mutation/IH_mut.maf')
########ML/MMH的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = IL_mut)
TMB[[2]] <- tmb(maf = IM_mut)
TMB[[3]] <- tmb(maf = IH_mut)
names(TMB) <- c('IL_mut','IM_mut','IH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL','IM','IH'))

library(ggplot2)
library(ggpubr)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test" )#5cm*4cm

library(scales)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8,9,8),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm

####
library(maftools)
IL_mut_vs_IH_mut <- mafCompare(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
IM_mut_vs_IH_mut <- mafCompare(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
IL_mut_vs_IM_mut <- mafCompare(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL_mut', m2Name = 'IM_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = IL_mut_vs_IM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = IL_mut_vs_IH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = IM_mut_vs_IH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-IL_mut_vs_IM_mut$results
r1<-IM_mut_vs_IH_mut$results
r1<-IL_mut_vs_IH_mut$results
g0<-r1[which(r1$pval<0.005),Hugo_Symbol]
g1<-r1[1:40,Hugo_Symbol]
l<-length(g0)
ifelse(l<5,g<-g0,g<-g1)
coOncoplot(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL', m2Name = 'IM', genes = g1, removeNonMutated = T)
coOncoplot(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM', m2Name = 'IH', genes = g1, removeNonMutated = T)
coOncoplot(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL', m2Name = 'IH', genes = g1, removeNonMutated = T)

#3cm*15cm
coBarplot(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL_mut', m2Name = 'IH_mut')

#########分析IL组特异性突变的功能类型
a <- r1[r1$pval<0.05&r1$IL_mut>r1$IM_mut,]
a <- bitr(a$Hugo_Symbol,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

####关注三阴性乳腺癌不同群的突变情况
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')
# IL_basal_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IL',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='Basal',4],]
# IM_basal_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IM',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='Basal',4],]
# IH_basal_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IH',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='Basal',4],]
# write.table(IL_basal_mut,'result/BRCA/mutation/IL_basal_mut.maf',sep = '\t',quote = F,row.names = F)
# write.table(IM_basal_mut,'result/BRCA/mutation/IM_basal_mut.maf',sep = '\t',quote = F,row.names = F)
# write.table(IH_basal_mut,'result/BRCA/mutation/IH_basal_mut.maf',sep = '\t',quote = F,row.names = F)
IL_basal_mut <- read.maf(maf ='result/BRCA/mutation/IL_basal_mut.maf')
IM_basal_mut <- read.maf(maf ='result/BRCA/mutation/IM_basal_mut.maf')
IH_basal_mut <- read.maf(maf ='result/BRCA/mutation/IH_basal_mut.maf')
#差异突变
Basal_IL_mut_vs_IH_mut <- mafCompare(m1 = IL_basal_mut, m2 = IH_basal_mut, m1Name = 'IL_basal_mut', m2Name = 'IH_basal_mut', minMut = 2, useCNV =FALSE)
Basal_IM_mut_vs_IH_mut <- mafCompare(m1 = IM_basal_mut, m2 = IH_basal_mut, m1Name = 'IM_basal_mut', m2Name = 'IH_basal_mut', minMut = 2, useCNV =FALSE)
Basal_IL_mut_vs_IM_mut <- mafCompare(m1 = IL_basal_mut, m2 = IM_basal_mut, m1Name = 'IL_basal_mut', m2Name = 'IM_basal_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = Basal_IL_mut_vs_IM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = Basal_IL_mut_vs_IM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = Basal_IM_mut_vs_IH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-Basal_IL_mut_vs_IM_mut$results
r1<-Basal_IL_mut_vs_IH_mut$results
r1<-Basal_IM_mut_vs_IH_mut$results
g0 <- r1[order(r1$IL_basal_mut,decreasing = T)[1:10],Hugo_Symbol]
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = IL_basal_mut, m2 = IM_basal_mut, m1Name = 'IL', m2Name = 'IM', genes = g, removeNonMutated = F)
coOncoplot(m1 = IM_basal_mut, m2 = IH_basal_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = F)
coOncoplot(m1 = IL_basal_mut, m2 = IH_basal_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = F)
#3cm*15cm

#########分析basal_ML组特异性突变的功能类型
a <- r1[r1$pval<0.05&r1$IL_basal_mut>r1$IM_basal_mut,]
a <- bitr(a$Hugo_Symbol,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
########basal的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = IL_basal_mut)
TMB[[2]] <- tmb(maf = IM_basal_mut)
TMB[[3]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL','IM','IH'))

library(ggplot2)
library(ggpubr)
library(scales)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8,9,8),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a
#再看看NK和CD8的比例如何
data <- as.data.frame(t(expr_data_raw[[2]][1:10,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
rownames(data) <- a
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`NK cell`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.1,0.11,0.1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2),
              tip_length = c(0.01,0.01,0.01))#5cm*4cm
a

####关注LumA乳腺癌不同群的突变情况与basal的区别
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')
IL_LumA_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IL',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='LumA',4],]
IM_LumA_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IM',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='LumA',4],]
IH_LumA_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IH',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='LumA',4],]
IL_LumB_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IL',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='LumB',4],]
IM_LumB_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IM',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='LumB',4],]
IH_LumB_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IH',4]&BRCA_mut$Tumor_Sample_Barcode%in%b[b$subtype=='LumB',4],]

# write.table(IL_LumA_mut,'result/BRCA/mutation/IL_LumA_mut.maf',sep = '\t',quote = F,row.names = F)
# write.table(IM_LumA_mut,'result/BRCA/mutation/IM_LumA_mut.maf',sep = '\t',quote = F,row.names = F)
# write.table(IH_LumA_mut,'result/BRCA/mutation/IH_LumA_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(IL_LumB_mut,'result/BRCA/mutation/IL_LumB_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(IM_LumB_mut,'result/BRCA/mutation/IM_LumB_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(IH_LumB_mut,'result/BRCA/mutation/IH_LumB_mut.maf',sep = '\t',quote = F,row.names = F)
IL_LumA_mut <- read.maf(maf ='result/BRCA/mutation/IL_LumA_mut.maf')
IM_LumA_mut <- read.maf(maf ='result/BRCA/mutation/IM_LumA_mut.maf')
IH_LumA_mut <- read.maf(maf ='result/BRCA/mutation/IH_LumA_mut.maf')
IL_LumB_mut <- read.maf(maf ='result/BRCA/mutation/IL_LumB_mut.maf')
IM_LumB_mut <- read.maf(maf ='result/BRCA/mutation/IM_LumB_mut.maf')
IH_LumB_mut <- read.maf(maf ='result/BRCA/mutation/IH_LumB_mut.maf')


#差异突变
LumA_IL_mut_vs_IH_mut <- mafCompare(m1 = IL_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IL_LumA_mut', m2Name = 'IH_LumA_mut', minMut = 2, useCNV =FALSE)
LumA_IM_mut_vs_IH_mut <- mafCompare(m1 = IM_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IM_LumA_mut', m2Name = 'IH_LumA_mut', minMut = 2, useCNV =FALSE)
LumA_IL_mut_vs_IM_mut <- mafCompare(m1 = IL_LumA_mut, m2 = IM_LumA_mut, m1Name = 'IL_LumA_mut', m2Name = 'IM_LumA_mut', minMut = 2, useCNV =FALSE)

# a <- mafCompare(m1 = IL_LumA_mut, m2 = IL_basal_mut, m1Name = 'IL_LumA_mut', m2Name = 'IL_basal_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = LumA_IL_mut_vs_IM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = LumA_IL_mut_vs_IM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = LumA_IM_mut_vs_IH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-LumA_IL_mut_vs_IM_mut$results
r1<-LumA_IL_mut_vs_IH_mut$results
r1<-LumA_IM_mut_vs_IH_mut$results
g0 <- r1[order(r1$IL_LumA_mut,decreasing = T)[1:10],Hugo_Symbol]
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = IL_LumA_mut, m2 = IM_LumA_mut, m1Name = 'IL', m2Name = 'IM', genes = g, removeNonMutated = F)
coOncoplot(m1 = IM_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = F)
coOncoplot(m1 = IL_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = F)
#3cm*15cm

#########分析LumA_ML组特异性突变的功能类型
a <- r1[r1$pval<0.05&r1$IL_LumA_mut<r1$IM_LumA_mut,]
a <- bitr(a$Hugo_Symbol,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
########LumA的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL','IM','IH'))

library(ggplot2)
library(ggpubr)
library(scales)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8,9,8),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a
#再看看NK和CD8的比例如何
data <- as.data.frame(t(expr_data_raw[[2]][1:10,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`NK cell`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.1,0.11,0.1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2),
              tip_length = c(0.01,0.01,0.01))#5cm*4cm
a

####生存分析看看basal乳腺癌的免疫高中低生存差异如何
####乳腺癌层次聚类与生存分析
####BRCA层次聚类
library('survival')
library('survminer')
##亚型生存曲线
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

IL_basal_mut <- read.maf(maf ='result/BRCA/mutation/IL_basal_mut.maf')
IM_basal_mut <- read.maf(maf ='result/BRCA/mutation/IM_basal_mut.maf')
IH_basal_mut <- read.maf(maf ='result/BRCA/mutation/IH_basal_mut.maf')
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%unique(IL_basal_mut@data$Tumor_Sample_Barcode)] <- 'IL_basal'
b$cluster_subtype[b$case_id%in%unique(IM_basal_mut@data$Tumor_Sample_Barcode)] <- 'IM_basal'
b$cluster_subtype[b$case_id%in%unique(IH_basal_mut@data$Tumor_Sample_Barcode)] <- 'IH_basal'
b_basal <- b[!is.na(b$cluster_subtype),]

b_basal$vital_status[which(b_basal$V5 > 3650)] <- 0
b_basal$V5[which(b_basal$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_basal[,5],as.numeric(b_basal[,2]))~b_basal[,8], data = b_basal)
c <- survfit(Surv(b_basal[,5],as.numeric(b_basal[,2]))~b_basal[,8], data = b_basal)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#950599","blue","red","#12D658"),
                        labels = c('IL_basal','IM_basal','IH_basal'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%unique(IL_LumA_mut@data$Tumor_Sample_Barcode)] <- 'IL_LumA'
b$cluster_subtype[b$case_id%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode)] <- 'IM_LumA'
b$cluster_subtype[b$case_id%in%unique(IH_LumA_mut@data$Tumor_Sample_Barcode)] <- 'IH_LumA'
b_LumA <- b[!is.na(b$cluster_subtype),]

b_LumA$vital_status[which(b_LumA$V5 > 3650)] <- 0
b_LumA$V5[which(b_LumA$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_LumA[,5],as.numeric(b_LumA[,2]))~b_LumA[,8], data = b_LumA)
c <- survfit(Surv(b_LumA[,5],as.numeric(b_LumA[,2]))~b_LumA[,8], data = b_LumA)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#950599","blue","red","#12D658"),
                        labels = c('IL_LumA','IM_LumA','IH_LumA'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode)] <- 'IM_LumA'
b$cluster_subtype[b$case_id%in%unique(IM_basal_mut@data$Tumor_Sample_Barcode)] <- 'IM_basal'
b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                        type = c("#950599","blue","red","#12D658"),
                        labels = c('IM_LumA','IM_Basal'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%unique(IL_LumA_mut@data$Tumor_Sample_Barcode)] <- 'IL_LumA'
b$cluster_subtype[b$case_id%in%unique(IL_basal_mut@data$Tumor_Sample_Barcode)] <- 'IL_basal'
b_IL <- b[!is.na(b$cluster_subtype),]

b_IL$vital_status[which(b_IL$V5 > 3650)] <- 0
b_IL$V5[which(b_IL$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IL[,5],as.numeric(b_IL[,2]))~b_IL[,8], data = b_IL)
c <- survfit(Surv(b_IL[,5],as.numeric(b_IL[,2]))~b_IL[,8], data = b_IL)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                        type = c("#950599","blue","red","#12D658"),
                        labels = c('IM_LumA','IM_Basal'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%unique(IL_LumA_mut@data$Tumor_Sample_Barcode)] <- 'IL_LumA'
b$cluster_subtype[b$case_id%in%unique(IL_basal_mut@data$Tumor_Sample_Barcode)] <- 'IL_basal'
b$cluster_subtype[b$case_id%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode)] <- 'IM_LumA'
b$cluster_subtype[b$case_id%in%unique(IM_basal_mut@data$Tumor_Sample_Barcode)] <- 'IM_basal'

b_IL_IM <- b[!is.na(b$cluster_subtype),]

b_IL_IM$vital_status[which(b_IL_IM$V5 > 3650)] <- 0
b_IL_IM$V5[which(b_IL_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IL_IM[,5],as.numeric(b_IL_IM[,2]))~b_IL_IM[,8], data = b_IL_IM)
c <- survfit(Surv(b_IL_IM[,5],as.numeric(b_IL_IM[,2]))~b_IL_IM[,8], data = b_IL_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                        type = c("#950599","blue","red","#12D658"),
                        labels = c('IM_LumA','IM_Basal'))##对齐坐标轴原点#4cm*5cm
#分析LumA中PIK3CA突变的预后好坏
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode[IM_LumA_mut@data$Hugo_Symbol=='PIK3CA'])] <- 'IM_LumA_PIK3CA'
b$cluster_subtype[b$case_id%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode[!IM_LumA_mut@data$Tumor_Sample_Barcode%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode[IM_LumA_mut@data$Hugo_Symbol=='PIK3CA'])])] <- 'IM_LumA_WT'

b_IL_IM <- b[!is.na(b$cluster_subtype),]

b_IL_IM$vital_status[which(b_IL_IM$V5 > 3650)] <- 0
b_IL_IM$V5[which(b_IL_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IL_IM[,5],as.numeric(b_IL_IM[,2]))~b_IL_IM[,8], data = b_IL_IM)
c <- survfit(Surv(b_IL_IM[,5],as.numeric(b_IL_IM[,2]))~b_IL_IM[,8], data = b_IL_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                        type = c("#950599","blue","red","#12D658"),
                        labels = c('IM_LumA','IM_Basal'))##对齐坐标轴原点#4cm*5cm

#分析LumA中PIK3CA突变的预后好坏
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode[IM_LumA_mut@data$Hugo_Symbol=='CDH1'])] <- 'IM_LumA_PIK3CA'
b$cluster_subtype[b$case_id%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode[!IM_LumA_mut@data$Tumor_Sample_Barcode%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode[IM_LumA_mut@data$Hugo_Symbol=='CDH1'])])] <- 'IM_LumA_WT'

b_IL_IM <- b[!is.na(b$cluster_subtype),]

b_IL_IM$vital_status[which(b_IL_IM$V5 > 3650)] <- 0
b_IL_IM$V5[which(b_IL_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IL_IM[,5],as.numeric(b_IL_IM[,2]))~b_IL_IM[,8], data = b_IL_IM)
c <- survfit(Surv(b_IL_IM[,5],as.numeric(b_IL_IM[,2]))~b_IL_IM[,8], data = b_IL_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                        type = c("#950599","blue","red","#12D658"),
                        labels = c('IM_LumA','IM_Basal'))##对齐坐标轴原点#4cm*5cm
##比较basal中有骨架基因突变组和没有骨架基因突变组的生存差异
#分析发现LumA中免疫浸润的增加对预后是有效的，而basal是无效的，所以要看看basal_IM组中是什么使免疫浸润无效
#########分析basal_IM组和LumA_IM特异性突变的功能类型
Basal_IM_mut_vs_LumA_IM_mut <- mafCompare(m1 = IM_basal_mut, m2 = IM_LumA_mut, m1Name = 'IM_basal_mut', m2Name = 'IM_LumA_mut', minMut = 2, useCNV =FALSE)
unique(IM_basal_mut@data$Tumor_Sample_Barcode)

a <- Basal_IM_mut_vs_LumA_IM_mut$results

Basal_IM_mut_vs_LumA_IM_mut <- mafCompare(m1 = IM_basal_mut, m2 = IM_LumA_mut, m1Name = 'IM_basal_mut', m2Name = 'IM_LumA_mut', minMut = 2, useCNV =FALSE)
unique(IM_basal_mut@data$Tumor_Sample_Barcode)


a <- a$Hugo_Symbol[a$pval<0.05&a$IL_basal_mut<a$IM_basal_mut]
a <- bitr(a$Hugo_Symbol,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

####分析
#再看看LumA和basal的NK和CD8的比例如何
########LumA的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IL_basal_mut)
TMB[[3]] <- tmb(maf = IM_LumA_mut)
TMB[[4]] <- tmb(maf = IM_basal_mut)
names(TMB) <- c('IL_LumA_mut','IL_basal_mut','IM_LumA_mut','IM_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IL_Basal',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IM_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IM_Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IL_Basal','IM_LumA','IM_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:10,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`NK cell`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.1,0.11,0.1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.2),
              tip_length = c(0.01,0.01))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=`B cell`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.2),
              tip_length = c(0.01,0.01))#5cm*4cm
a

##分析PD1,PDL1的水平LumA和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IL_basal_mut)
TMB[[3]] <- tmb(maf = IM_LumA_mut)
TMB[[4]] <- tmb(maf = IM_basal_mut)

names(TMB) <- c('IL_LumA_mut','IL_basal_mut','IM_LumA_mut','IM_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IL_Basal',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IM_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IM_Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IL_Basal','IM_LumA','IM_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('PDCD1','CD274','CTLA4'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=PDCD1,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(33,33),
              tip_length = c(0.05,0.05))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=CD274,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(6,6),
              tip_length = c(0.02,0.02))#5cm*4cm
a

a <-ggplot(TMB_plot, aes(x=cluster, y=CTLA4,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(33,33),
              tip_length = c(0.02,0.02))#5cm*4cm
a
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%unique(IM_basal_mut@data$Tumor_Sample_Barcode)] <- 'IM_basal'
data <- data[data$Tumor_Sample_Barcode%in%b$case_id[b$cluster_subtype=='IM_basal'],]
b$PDCD1[b$case_id%in%data$Tumor_Sample_Barcode[data$PDCD1>median(data$PDCD1)]] <- 'high'
b$PDCD1[b$case_id%in%data$Tumor_Sample_Barcode[data$PDCD1<=median(data$PDCD1)]] <- 'low'

b_PDCD1 <- b[!is.na(b$PDCD1),]

b_PDCD1$vital_status[which(b_PDCD1$V5 > 3650)] <- 0
b_PDCD1$V5[which(b_PDCD1$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_PDCD1[,5],as.numeric(b_PDCD1[,2]))~b_PDCD1[,9], data = b_PDCD1)
c <- survfit(Surv(b_PDCD1[,5],as.numeric(b_PDCD1[,2]))~b_PDCD1[,9], data = b_PDCD1)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                        type = c("blue","red"),
                        labels = c('IM_LumA','IM_Basal'))##对齐坐标轴原点#4cm*5cm

data <- as.data.frame(t(expr_data_raw[[2]][c('PDCD1','CD274'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%c(unique(IM_LumA_mut@data$Tumor_Sample_Barcode))] <- 'IM_LumA'
data <- data[data$Tumor_Sample_Barcode%in%b$case_id[b$cluster_subtype=='IM_LumA'&!is.na(b$cluster_subtype)],]
b$PDCD1[b$case_id%in%data$Tumor_Sample_Barcode[data$PDCD1>median(data$PDCD1)]] <- 'high'
b$PDCD1[b$case_id%in%data$Tumor_Sample_Barcode[data$PDCD1<=median(data$PDCD1)]] <- 'low'

b_PDCD1 <- b[!is.na(b$PDCD1),]

b_PDCD1$vital_status[which(b_PDCD1$V5 > 3650)] <- 0
b_PDCD1$V5[which(b_PDCD1$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_PDCD1[,5],as.numeric(b_PDCD1[,2]))~b_PDCD1[,9], data = b_PDCD1)
c <- survfit(Surv(b_PDCD1[,5],as.numeric(b_PDCD1[,2]))~b_PDCD1[,9], data = b_PDCD1)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                        type = c("blue","red"),
                        labels = c('IM_LumA','IM_Basal'))##对齐坐标轴原点#4cm*5cm
####探究PIK3CA突变与PD1表达量之间的关系
TMB <- list()
TMB[[1]] <- tmb(maf = IM_LumA_mut)
names(TMB) <- c('IL_LumA_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA'))
data <- as.data.frame(t(expr_data_raw[[2]][c('PDCD1','CD274'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[data$Tumor_Sample_Barcode%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode),]
data$PIK3CA[data$Tumor_Sample_Barcode%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode[IM_LumA_mut@data$Hugo_Symbol%in%c('AKT1',"CDH1",'TP53','MAP3K1')])] <- 'mut'

#data$PIK3CA[data$Tumor_Sample_Barcode%in%unique(IM_LumA_mut@data$Tumor_Sample_Barcode[IM_LumA_mut@data$Hugo_Symbol=='MAP3K1'])] <- 'mut'
data$PIK3CA[is.na(data$PIK3CA)] <- 'wt'
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=PIK3CA, y=`PDCD1`,fill=PIK3CA)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("mut","wt")), 
              map_signif_level = TRUE, test = t.test, y_position = c(30),
              tip_length = c(0.05))#5cm*4cm
a

a <-ggplot(TMB_plot, aes(x=PIK3CA, y=`CD274`,fill=PIK3CA)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("mut","wt")), 
              map_signif_level = TRUE, test = t.test, y_position = c(30),
              tip_length = c(0.05))#5cm*4cm
a

oncostrip(maf=IM_LumA_mut, genes=c('PIK3CA','TP53',"CDH1",'MAP3K1'), border=NULL)
a <- oncodrive(maf=IM_LumA_mut, minMut=5, AACol="HGVSp_Short", pvalMethod="zscore")
plotOncodrive(res = a, fdrCutOff = 0.1, useFraction = TRUE,labelSize = 1)

OncogenicPathways(maf=IM_LumA_mut)
OncogenicPathways(maf=IM_basal_mut)
PlotOncogenicPathways(maf = IM_basal_mut,pathways = 'PI3K')

################################BRCA正式分析
#标记代码
#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:9,1]),]))
# for (i in 1:ncol(data)) {
#   data[,i] <- scale(as.numeric(data[,i]))
# }
data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
annotation_col[annotation_col[,1]==2,1] <- 'IM'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm


a <- t(a)
bk = unique(c(seq(-1,1, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
# a <- t(data)
pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col,
                   breaks = bk)#5*8

paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
#亚型与不同聚类的生存曲线
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
b[b[,6]%in%rownames(result)[result[,1]%in%2:3],7] <- 'IH'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#E24A0E","blue","#F2CA20"),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##亚型生存曲线
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#4498F2","gray","#ED5163","#72FCA0"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm

####查看不同亚型下免疫low与median的区别
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IL']] <- 'IL_LumA'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IM']] <- 'IM_LumA'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IH']] <- 'IH_LumA'
b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_LumA'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_LumA','IM_LumA','IH_LumA'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'

b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_Basal'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_Basal','IM_Basal','IH_Basal'))##对齐坐标轴原点#4cm*5cm

####分析主要是哪种免疫细胞在起作用
####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 2) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:10,])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:9,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name

bk = unique(c(seq(-1,1, length=200)))
pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                   color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T,
                   treeheight_row = 8,treeheight_col = 8)#8cm*8cm

########分析LumA和Basal种CD8 T和Treg的含量差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)

names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IL_Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('IM_Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('IH_Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IM_LumA','IH_LumA','IL_Basal','IM_Basal','IH_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IM_LumA"),c("IM_LumA","IH_LumA"),c("IL_Basal","IM_Basal"),c("IM_Basal","IH_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2,0.21),
              tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
a

####分析T细胞激活marker
##分析PD1,PDL1的水平LumA和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('IGLC7','IGHV3-43','CD79A','IGAN2','IGAN1','FCGR2A','FCGR3A','GSDME','GSDMD','BCL2L1','CASP3','XIAP','TRAF1','HTRA2','BIRC7','BIRC5','BIRC2','BIRC3','TGIF1','HIF1A','IL10','TNFRSF9','IL21','CD8A','PDCD1','CD274','CTLA4','GZMA','GZMB','PRF1','PRF2'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

# plot <- TMB_plot[,c('Tumor_Sample_Barcode','cluster','GZMA','GZMB','PRF1')]
# plot <- pivot_longer(plot,cols = 3:5,names_to = 'gene',values_to = 'expr')
# plot$cluster <- factor(plot$cluster)
# plot$gene <- factor(plot$gene)
TMB_plot$IGLC7 <- TMB_plot$IGLC7+1
ggplot(TMB_plot, aes(x=cluster, y=`IGLC7`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
a <-ggplot(TMB_plot, aes(x=cluster, y=`IGLC7`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
b <-ggplot(TMB_plot, aes(x=cluster, y=GZMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
c <-ggplot(TMB_plot, aes(x=cluster, y=PRF1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

##分析免疫检查点
TMB_plot$PDCD1 <- TMB_plot$PDCD1+1
TMB_plot$CD274 <- TMB_plot$CD274+1
TMB_plot$CTLA4 <- TMB_plot$CTLA4+1
a <-ggplot(TMB_plot, aes(x=cluster, y=PDCD1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

b <-ggplot(TMB_plot, aes(x=cluster, y=CD274,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

c <-ggplot(TMB_plot, aes(x=cluster, y=CTLA4,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

####GSEA分析
TMB <- list()
TMB[[1]] <- tmb(maf = IM_LumA_mut)
TMB[[2]] <- tmb(maf = IH_LumA_mut)
TMB[[3]] <- tmb(maf = IM_basal_mut)
TMB[[4]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IM_LumA_mut','IH_LumA_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('Basal',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
# TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
# TMB <- list()
# TMB[[1]] <- tmb(maf = IL_LumA_mut)
# TMB[[2]] <- tmb(maf = IM_LumA_mut)
# TMB[[3]] <- tmb(maf = IH_LumA_mut)
# TMB[[4]] <- tmb(maf = IL_basal_mut)
# TMB[[5]] <- tmb(maf = IM_basal_mut)
# TMB[[6]] <- tmb(maf = IH_basal_mut)
# names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
# ##画箱线图
# TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
#                   cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
#                   cbind(TMB[[3]],rep('LumA',nrow(TMB[[3]]))),
#                   cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
#                   cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
#                   cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
# colnames(TMB_plot)[5] <- 'cluster'
# TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)
group_list <- TMB_plot[,c(1,5)]
TMB_plot <- TMB_plot[,17:ncol(TMB_plot)]
TMB_plot <- as.data.frame(t(TMB_plot))
colnames(TMB_plot) <- group_list$Tumor_Sample_Barcode
library(GSEABase)
library(limma) 
library(clusterProfiler)
library(enrichplot)
dat <- TMB_plot
group_list <- factor(group_list$cluster,ordered = F)
design <- model.matrix(~factor( group_list ))
fit=lmFit(dat,design)
fit=eBayes(fit)
options(digits = 4)
topTable(fit,coef=2,adjust='BH')
deg=topTable(fit,coef=2,adjust='BH',number = Inf)
a <- TMB_plot[rownames(deg),group_list=='LumA']
deg$LumA_mean <- apply(a,1,mean)
a <- TMB_plot[rownames(deg),group_list=='Basal']
deg$Basal_mean <- apply(a,1,mean)
deg$gene <- rownames(deg)
head(deg)
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c5.go.v7.5.1.symbols.gmt")
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c7.immunesigdb.v7.5.1.symbols.gmt")
geneList <- deg$logFC
names(geneList) <- toupper(rownames(deg))
geneList <- sort(geneList,decreasing = T)
gsea_results <- GSEA(geneList = geneList,
                     TERM2GENE = geneset,
                     verbose = F,minGSSize = 0,maxGSSize = 500,
                     eps=0,pvalueCutoff = 1)

gsea_results_immune <- GSEA(geneList = geneList,
                            TERM2GENE = geneset,
                            verbose = F,minGSSize = 0,maxGSSize = 500,
                            eps=0,pvalueCutoff = 1)
class(gsea_results)
gseaplot2(x=gsea_results,geneSetID=c('GOBP_B_CELL_MEDIATED_IMMUNITY')) #3*5cm

# for (i in 1:length(list)) {
#   p <- gseaplot2(x=gsea_results,geneSetID=paste("HALLMARK_",list[i],sep="")) 
#   d <- paste("./",list[i],".pdf",sep="")
#   pdf(file=d,
#       family = "Times",width=10,height = 6)
#   print(p)
#   dev.off()
# }
gsea_results@result$core_enrichment[1]


#####LumB与basal的分析
#亚型与不同聚类的生存曲线
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#E24A0E","blue","#F2CA20"),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##亚型生存曲线
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#4498F2","gray","#ED5163","#72FCA0"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm

####查看不同亚型下免疫low与median的区别
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumB'&annotation_col$cluster=='IL']] <- 'IL_LumB'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumB'&annotation_col$cluster=='IM']] <- 'IM_LumB'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumB'&annotation_col$cluster=='IH']] <- 'IH_LumB'
b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_LumA'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_LumA','IM_LumA','IH_LumA'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'

b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_Basal'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_Basal','IM_Basal','IH_Basal'))##对齐坐标轴原点#4cm*5cm

####观察hub基因在basal中还有没有效果
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'
b_basal <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
surv_sig_dgree[[2]][1:10]
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_Basal'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)


####分析主要是哪种免疫细胞在起作用
####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 2) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:10,])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:9,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name

bk = unique(c(seq(-1,1, length=200)))
pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                   color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T,
                   treeheight_row = 8,treeheight_col = 8)#8cm*8cm

########分析LumB和Basal种CD8 T和Treg的含量差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumB_mut)
TMB[[2]] <- tmb(maf = IM_LumB_mut)
TMB[[3]] <- tmb(maf = IH_LumB_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)

names(TMB) <- c('IL_LumB_mut','IM_LumB_mut','IH_LumB_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumB',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_LumB',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_LumB',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IL_Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('IM_Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('IH_Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumB','IM_LumB','IH_LumB','IL_Basal','IM_Basal','IH_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IM_LumA"),c("IM_LumA","IH_LumA"),c("IL_Basal","IM_Basal"),c("IM_Basal","IH_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2,0.21),
              tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
a

####分析T细胞激活marker
##分析PD1,PDL1的水平LumB和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumB_mut)
TMB[[2]] <- tmb(maf = IM_LumB_mut)
TMB[[3]] <- tmb(maf = IH_LumB_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumB',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumB',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('LumB',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumB','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('IGLC7','IGHV3-43','CD79A','IGAN2','IGAN1','FCGR2A','FCGR3A','GSDME','GSDMD','BCL2L1','CASP3','XIAP','TRAF1','HTRA2','BIRC7','BIRC5','BIRC2','BIRC3','TGIF1','HIF1A','IL10','TNFRSF9','IL21','CD8A','PDCD1','CD274','CTLA4','GZMA','GZMB','PRF1','PRF2'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)


a <-ggplot(TMB_plot, aes(x=cluster, y=`PDCD1`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
b <-ggplot(TMB_plot, aes(x=cluster, y=GZMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
c <-ggplot(TMB_plot, aes(x=cluster, y=PRF1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

##分析免疫检查点
TMB_plot$PDCD1 <- TMB_plot$PDCD1+1
TMB_plot$CD274 <- TMB_plot$CD274+1
TMB_plot$CTLA4 <- TMB_plot$CTLA4+1
a <-ggplot(TMB_plot, aes(x=cluster, y=PDCD1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

b <-ggplot(TMB_plot, aes(x=cluster, y=CD274,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

c <-ggplot(TMB_plot, aes(x=cluster, y=CTLA4,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

####GSEA分析
TMB <- list()
TMB[[1]] <- tmb(maf = IM_LumB_mut)
TMB[[2]] <- tmb(maf = IH_LumB_mut)
TMB[[3]] <- tmb(maf = IM_basal_mut)
TMB[[4]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IM_LumB_mut','IH_LumB_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumB',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumB',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('Basal',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'

data <- as.data.frame(t(expr_data_raw[[2]]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)
group_list <- TMB_plot[,c(1,5)]
TMB_plot <- TMB_plot[,17:ncol(TMB_plot)]
TMB_plot <- as.data.frame(t(TMB_plot))
colnames(TMB_plot) <- group_list$Tumor_Sample_Barcode
library(GSEABase)
library(limma) 
library(clusterProfiler)
library(enrichplot)
dat <- TMB_plot
group_list <- factor(group_list$cluster,ordered = F)
design <- model.matrix(~factor( group_list ))
fit=lmFit(dat,design)
fit=eBayes(fit)
options(digits = 4)
topTable(fit,coef=2,adjust='BH')
deg=topTable(fit,coef=2,adjust='BH',number = Inf)
a <- TMB_plot[rownames(deg),group_list=='LumB']
deg$LumB_mean <- apply(a,1,mean)
a <- TMB_plot[rownames(deg),group_list=='Basal']
deg$Basal_mean <- apply(a,1,mean)
deg$gene <- rownames(deg)
head(deg)
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c5.go.v7.5.1.symbols.gmt")
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c7.immunesigdb.v7.5.1.symbols.gmt")
geneList <- deg$logFC
names(geneList) <- toupper(rownames(deg))
geneList <- sort(geneList,decreasing = T)
gsea_results <- GSEA(geneList = geneList,
                     TERM2GENE = geneset,
                     verbose = F,minGSSize = 0,maxGSSize = 500,
                     eps=0,pvalueCutoff = 1)

gsea_results_immune <- GSEA(geneList = geneList,
                            TERM2GENE = geneset,
                            verbose = F,minGSSize = 0,maxGSSize = 500,
                            eps=0,pvalueCutoff = 1)
class(gsea_results)
d <- gseaplot2(x=gsea_results,geneSetID=c('GOBP_POSITIVE_REGULATION_OF_B_CELL_ACTIVATION',
                                          'GOBP_B_CELL_MEDIATED_IMMUNITY')) 

pdf(file='GSEA.pdf',
    family = "Times",width=10,height = 6)
print(d)
dev.off()

for (i in 1:length(list)) {
  p <- gseaplot2(x=gsea_results,geneSetID=paste("HALLMARK_",list[i],sep="")) 
  d <- paste("./",list[i],".pdf",sep="")
  pdf(file=d,
      family = "Times",width=10,height = 6)
  print(p)
  dev.off()
}
gsea_results@result$core_enrichment[1]

####接下来分析Basal浸润高低之间的突变差异
#差异突变
LumA_IL_mut_vs_IH_mut <- mafCompare(m1 = IL_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IL_LumA_mut', m2Name = 'IH_LumA_mut', minMut = 2, useCNV =FALSE)
LumA_IM_mut_vs_IH_mut <- mafCompare(m1 = IM_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IM_LumA_mut', m2Name = 'IH_LumA_mut', minMut = 2, useCNV =FALSE)
LumA_IL_mut_vs_IM_mut <- mafCompare(m1 = IL_LumA_mut, m2 = IM_LumA_mut, m1Name = 'IL_LumA_mut', m2Name = 'IM_LumA_mut', minMut = 2, useCNV =FALSE)

Basal_IL_mut_vs_IH_mut <- mafCompare(m1 = IL_basal_mut, m2 = IH_basal_mut, m1Name = 'IL_Basal_mut', m2Name = 'IH_Basal_mut', minMut = 2, useCNV =FALSE)
Basal_IM_mut_vs_IH_mut <- mafCompare(m1 = IM_basal_mut, m2 = IH_basal_mut, m1Name = 'IM_Basal_mut', m2Name = 'IH_Basal_mut', minMut = 2, useCNV =FALSE)
Basal_IL_mut_vs_IM_mut <- mafCompare(m1 = IL_basal_mut, m2 = IM_basal_mut, m1Name = 'IL_Basal_mut', m2Name = 'IM_Basal_mut', minMut = 2, useCNV =FALSE)

# a <- mafCompare(m1 = IL_LumA_mut, m2 = IL_basal_mut, m1Name = 'IL_LumA_mut', m2Name = 'IL_basal_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = LumA_IL_mut_vs_IM_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = LumA_IL_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = LumA_IM_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = Basal_IL_mut_vs_IM_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = Basal_IM_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = Basal_IL_mut_vs_IM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)




r1<-LumA_IL_mut_vs_IM_mut$results
r1<-LumA_IL_mut_vs_IH_mut$results
r1<-LumA_IM_mut_vs_IH_mut$results
r1<-Basal_IL_mut_vs_IM_mut$results
g0 <- r1[order(r1$pval,decreasing = F)[1:40],Hugo_Symbol]
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = IL_basal_mut, m2 = IM_basal_mut, m1Name = 'IL', m2Name = 'IM', genes = g, removeNonMutated = F)
coOncoplot(m1 = IM_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = F)
coOncoplot(m1 = IL_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = F)
#3cm*10cm

#########分析LumA_ML组特异性突变的功能类型
a <- r1[r1$pval<0.05&r1$IL_Basal_mut>r1$IM_Basal_mut,]
a <- bitr(a$Hugo_Symbol,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名















# a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell regulatory (Tregs)`,fill=cluster)) +
#   # scale_y_continuous(trans = log2_trans(),
#   #                    breaks = trans_breaks("log2", function(x) 2^x),
#   #                    labels = trans_format("log2", math_format(2^.x))) +
#   geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
#   geom_jitter(shape=16, position = position_jitter(0.2))+
#   theme_classic()+
#   geom_signif(comparisons = list(c("IL_LumA","IM_LumA"),c("IM_LumA","IH_LumA"),c("IL_Basal","IM_Basal"),c("IM_Basal","IH_Basal")), 
#               map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.22,0.2,0.22),
#               tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
# a
# #画柱状图
# library(ggplot2)
# library(forcats)
# library(tidyr)
# library(tidyverse)
# plot <- TMB_plot[,c(1,5,13:14)]
# plot <- pivot_longer(data = plot,cols = 3:4,names_to = 'cell_type',values_to = 'percent')
# plot$cluster <- factor(plot$cluster)
# plot$cell_type <- factor(plot$cell_type)
# ggplot(plot, aes(fill=cluster, y=percent, x=cell_type))+
#   geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
#   theme_classic(base_size = 12)+
#   theme(legend.direction = "horizontal", legend.position = "top")+
#   labs(title = "", y="Surv-sig rate ", x = "Sample Size")+
#   stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
#                width = 0.5,position = position_dodge(0.9))+
#   scale_y_continuous(limits = c(0,0.05),expand = c(0,0))+
#   theme(axis.text.x = element_text(size = 12))+
#   theme(axis.text.y = element_text(size = 12))+
#   theme(axis.title = element_text(size = 14))+
#   geom_signif(data = plot,aes(xmin=0.75, xmax=1.25, annotations="*", y_position=5.25),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.2),
#               manual=TRUE)
#   
#   
#   
# Genotype = c("Wildtype", "APOE4", "Wildtype", "APOE4", "Wildtype", "APOE4", "Wildtype", "APOE4")
# Material = c("Shredded paper","Shredded paper","Square","Square","Bedding","Bedding","Twist", "Twist")
# Mean = c(4.77,3.52, 2.57, 1.39, 2.73, 1.73, 2.63, 1.30)
# se = c(0.16, 0.24, 0.36, 0.06, 0.25, 0.26, 0.29, 0.05) 
# df = data.frame(Genotype, Material, Mean, se)
# df$Genotype<- factor(df$Genotype, levels=(c("Wildtype", "APOE4")))
# df$Material<- factor(df$Material, levels=(c("Shredded paper","Square", "Bedding", "Twist")))
# ggplot(df, aes(x=Material, y = Mean, fill=Genotype))+
#   geom_bar(position=position_dodge(), stat="identity")+
#   scale_fill_manual(values=c("#CCCCCC", "#666666", "#CCCCCC", "#666666", "#CCCCCC", "#666666", "#CCCCCC", "#666666"))+
#   geom_errorbar(aes(ymin=Mean-se, ymax=Mean+se), 
#                 width=0.2,
#                 position=position_dodge(0.9))+  #this line of code makes the bar that extends across the 3-nonsig materials
#   scale_y_continuous(name="Average score\n", expand=c(0,0))+
#   geom_text(aes(x=1, y=5.9, label="Stretch It"), vjust=-1)+
#   scale_x_discrete(name="\nProvided materials")+
#   ggtitle("          Averaged scores of nests constructed by wildtype or APOE4 mice\n")+ #added chunk of space to center title in jpeg file
#   theme(plot.title=element_text(lineheight=0.8, face="bold", hjust=0.5))+
#   theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
#         panel.background=element_blank(), axis.line=element_line(color="black")) -> p1
# p1+
#   geom_signif(data=df,
#               aes(xmin=0.75, xmax=1.25, annotations="*", y_position=5.25),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.2),
#               manual=TRUE)+
#   geom_signif(data=df,
#               aes(xmin=1.75, xmax=2.25, annotations="*", y_position=3.30),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.3),
#               manual=TRUE) +
#   geom_signif(data=df,
#               aes(xmin=2.75, xmax=3.25, annotations="*", y_position=3.30),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.2),
#               manual=TRUE)+
#   geom_signif(data=df,
#               aes(xmin=3.75, xmax=4.25, annotations="*", y_position=3.30),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.3),
#               manual=TRUE)














#再看看LumA和basal的NK和CD8的比例如何
########Basal的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = IL_basal_mut)
TMB[[2]] <- tmb(maf = IM_basal_mut)
TMB[[3]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_basal',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_basal',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_basal',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_basal','IM_basal','IH_basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:10,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)


a <-ggplot(TMB_plot, aes(x=cluster, y=`total_perMB`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_basal","IM_basal"),c("IM_basal","IH_basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.1,0.11,0.1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a

########LumA的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IL_basal_mut)
TMB[[3]] <- tmb(maf = IM_LumA_mut)
TMB[[4]] <- tmb(maf = IM_basal_mut)
names(TMB) <- c('IL_LumA_mut','IL_basal_mut','IM_LumA_mut','IM_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IL_Basal',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IM_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IM_Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IL_Basal','IM_LumA','IM_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:10,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`NK cell`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.1,0.11,0.1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.2),
              tip_length = c(0.01,0.01))#5cm*4cm
a

a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell regulatory (Tregs)`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.2),
              tip_length = c(0.01,0.01))#5cm*4cm
a

a <-ggplot(TMB_plot, aes(x=cluster, y=`B cell`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.2),
              tip_length = c(0.01,0.01))#5cm*4cm
a
##分析PD1,PDL1的水平LumA和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IL_basal_mut)
TMB[[3]] <- tmb(maf = IM_LumA_mut)
TMB[[4]] <- tmb(maf = IM_basal_mut)

names(TMB) <- c('IL_LumA_mut','IL_basal_mut','IM_LumA_mut','IM_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IL_Basal',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IM_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IM_Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IL_Basal','IM_LumA','IM_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('GSDME','GSDMD','BCL2L1','CASP3','XIAP','TRAF1','HTRA2','BIRC7','BIRC5','BIRC2','BIRC3','TGIF1','HIF1A','IL10','TNFRSF9','IL21','CD8A','PDCD1','CD274','CTLA4','GZMA','GZMB','PRF1','PRF2'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=TGIF1,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(33,33),
              tip_length = c(0.05,0.05))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=CD274,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(6,6),
              tip_length = c(0.02,0.02))#5cm*4cm
a

a <-ggplot(TMB_plot, aes(x=cluster, y=CTLA4,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(33,33),
              tip_length = c(0.02,0.02))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=CD8A,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(33,33),
              tip_length = c(0.02,0.02))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=HIF1A,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1,1),
              tip_length = c(0.02,0.02))#5cm*4cm
a






##免疫浸润的程度比较
#整体浸润比较
a <- expression_raw[[2]][1:11,]
a <- as.data.frame(t(a))
a$all_immune <- 1-a$`uncharacterized cell`
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)

b$cluster <- factor(b$cluster,levels = c('IL','IM','IH'))
a <-ggplot(b, aes(x=cluster, y=all_immune,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1,1.1,1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm

a <-ggplot(b, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_dotplot(dotsize = 0.1)
geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.3,0.4,0.3),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
####通路
nest_pathway <- read.csv('/database/IAS/NeST Map - Main Model default node.csv')
nest_pathway_list <- list()
for (i in 1:nrow(nest_pathway)) {
  a <- nest_pathway[i,4]
  nest_pathway_list[[i]] <- str_split(a,' ',simplify = F)[[1]]
}
names(nest_pathway_list) <- nest_pathway$Annotation

path_num_cal <- function(x){
  x=nest_pathway_list[[x]]
  length(which(a%in%x))
}
patient_pathway <- list()
patient_id <- unique(BRCA_mut$Tumor_Sample_Barcode)
for (i in 1:length(patient_id)) {
  a <- unique(BRCA_mut$Hugo_Symbol[BRCA_mut$Tumor_Sample_Barcode==patient_id[i]])
  b <- as.data.frame(names(nest_pathway_list))
  b[,2] <- apply(b, 1, path_num_cal)
  colnames(b) <- c('pathway_name','map_mut_num')
  patient_pathway[[i]] <- b
}
names(patient_pathway) <- patient_id

patient_pathway_table <- data.frame(names(nest_pathway_list))
rownames(patient_pathway_table) <- patient_pathway_table[,1]
for (i in 1:length(patient_pathway)) {
  patient_pathway_table[,i] <- patient_pathway[[i]][,2]
  patient_pathway_table[patient_pathway_table[,i]>0,i] <- 1
  patient_pathway_table[patient_pathway_table[,i]==0,i] <- 0
}
colnames(patient_pathway_table) <- names(patient_pathway)

patient_pathway_table <- patient_pathway_table[apply(patient_pathway_table, 1, sum)>0,]

##画热图比较这两组样本的基因
hotmap <- cbind(patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='IL',4]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='IM',4]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='IH',4]])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,3]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(IL = "#72FCA0",IM = "#4498F2", IH = "#ED5163")) #连续数值型分组可设置成渐变  
##画瀑布图
diff_pathway_list <- data.frame(rownames(hotmap))
for (i in 1:nrow(diff_pathway_list)) {
  tryCatch({
    c <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='IL',4]]
    d <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='IM',4]]
    e <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='IH',4]]
    diff_pathway_list[i,2] <- sum(c)
    diff_pathway_list[i,3] <- sum(d)
    diff_pathway_list[i,4] <- sum(e)
    diff_pathway_list[i,5] <- t.test(c,d)$p.value
    diff_pathway_list[i,6] <- t.test(c,e)$p.value
    diff_pathway_list[i,7] <- t.test(d,e)$p.value
  }, error = function(e) {print('error')})
}
diff_pathway_list[1,5:7] <- 1
colnames(diff_pathway_list) <- c('pathway','IL','IM','IH','IL_IM','IL_IH','IM_IH')
c <- apply(hotmap, 1, sum)
c <- cbind(rownames(hotmap),c)
c <- as.data.frame(c)
colnames(c) <- c('nest','num')
c <- c[order(as.numeric(c[,2]),decreasing = F),]
for (i in 1:nrow(c)) {
  a <- as.data.frame(hotmap[i,])
  hotmap <- cbind(hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==1]],
                  hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==0]])
}
hotmap <- hotmap[rownames(c)[nrow(c):1],]
a <- pheatmap::pheatmap(hotmap,cluster_col = T,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- as.data.frame(cutree(a$tree_col,k=2))
hotmap <- cbind(hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==1]],
                hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==2]])

hotmap <- cbind(hotmap[,colnames(hotmap)%in%b[b[,1]=='IL',4]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='IM',4]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='IH',4]])
hotmap <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[!(diff_pathway_list$IL_IM>0.05&diff_pathway_list$IL_IH>0.05&diff_pathway_list$IM_IH>0.05)],]


a <- pheatmap::pheatmap(hotmap,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$IL_IM<0.05],]
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$IM_IH<0.05],]
a <- pheatmap::pheatmap(a,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm



diff_pathway_list$ML_specific[(diff_pathway_list$ML/179)>(diff_pathway_list$MM/258)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$ML/179)>(diff_pathway_list$MH/67)&diff_pathway_list$ML_MH<0.05] <- '1'
diff_pathway_list$MM_specific[(diff_pathway_list$MM/258)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$MM/258)>(diff_pathway_list$MH/67)&diff_pathway_list$MM_MH<0.05] <- '1'
diff_pathway_list$MH_specific[(diff_pathway_list$MH/67)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MH<0.05&
                                (diff_pathway_list$MH/67)>(diff_pathway_list$MM/258)&diff_pathway_list$MM_MH<0.05] <- '1'



####用肺腺癌细胞系计算突变，看看有没有EGFR
##对所有突变进行筛选
#all_mut
# LUAD_mut
# all_mut_ddc <- data.frame()
# sig_mut_list <- unique(LUAD_mut$Hugo_Symbol)
# for (i in 1:length(sig_mut_list)) {tryCatch({
#   A=sig_mut_list[i]
#   all_mut_ddc[i,1] <- A
#   a <- unique(luad_cell_line_mut$DepMap_ID[luad_cell_line_mut$Hugo_Symbol==A])
#   c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
#   d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
#   e <- t.test(c,d)
#   all_mut_ddc[i,2] <- e$estimate[1]
#   all_mut_ddc[i,3] <- e$estimate[2]
#   all_mut_ddc[i,4] <- e$p.value
# }, error = function(e) {print('error')})
# }
# colnames(all_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value')
# all_mut_ddc$diff_ddc <- all_mut_ddc$mut_cell_line-all_mut_ddc$wt_cell_line
# colnames(all_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value','diff_ddc')
##对所有突变进行筛选(全细胞系)
#all_mut
luad_cell_line_expr <- read.csv('/database/depmap/CRISPR_gene_dependency.csv',row.names = 1)
# luad_cell_line_expr <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%unique(luad_cell_line_mut$DepMap_ID),]
a <- colnames(luad_cell_line_expr)
a <- str_split(a,'[..]',simplify = T)
colnames(luad_cell_line_expr) <- a[,1]

luad_mut_ddc <- data.frame()
sig_mut_list <- unique(LUAD_mut$Hugo_Symbol)
luad_mut_table <- data.frame()
for (i in 1:length(sig_mut_list)) {
  luad_mut_table[i,1] <- sig_mut_list[i]
  luad_mut_table[i,2] <- length(unique(LUAD_mut$Tumor_Sample_Barcode[which(LUAD_mut$Hugo_Symbol==sig_mut_list[i])]))
}
names(luad_mut_table) <- c('gene','num')
luad_mut_table$percent <- luad_mut_table$num/length(unique(LUAD_mut$Tumor_Sample_Barcode))
luad_mut_table$type[luad_mut_table$percent>=0.05] <- 'high'
luad_mut_table$type[luad_mut_table$percent<0.05] <- 'low'


for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  luad_mut_ddc[i,1] <- A
  a <- unique(CCLE_mut$DepMap_ID[CCLE_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  luad_mut_ddc[i,2] <- e$estimate[1]
  luad_mut_ddc[i,3] <- e$estimate[2]
  luad_mut_ddc[i,4] <- e$p.value
  luad_mut_ddc[i,5] <- luad_mut_ddc[i,2]-luad_mut_ddc[i,3]
  luad_mut_ddc[i,6] <- length(c)
  luad_mut_ddc[i,7] <- length(d)
}, error = function(e) {print('error')})
}
colnames(luad_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value','diff_ddc','mut_num','wt_num')
luad_mut_ddc$p_adj <- p.adjust(luad_mut_ddc$p_value)
luad_mut_ddc$ddc_rate <- 2*luad_mut_ddc$diff_ddc/(luad_mut_ddc$mut_cell_line+luad_mut_ddc$wt_cell_line)
luad_effect_mut <- luad_mut_ddc[!is.na(luad_mut_ddc$p_value)&luad_mut_ddc$p_value<0.05&abs(luad_mut_ddc$diff_ddc)>0.01&abs(luad_mut_ddc$ddc_rate)>0.10,]

luad_effect_mut
oncostrip(maf=LUAD_mut_raw, genes=c('PIP5K1A','AKT','EGFR','KRAS',"GAB1","GRB2","PIK3CA","PIK3CB","PIK3R1"), border=NULL)
oncostrip(maf=MH_mut, genes=nest_pathway_list$`PIK3CA-actomyosin complex II`, border=NULL)
oncostrip(maf=ML_mut, genes=nest_pathway_list$`PIK3CA-actomyosin complex II`, border=NULL)
oncostrip(maf=MM_mut, genes=nest_pathway_list$`PIK3CA-actomyosin complex II`, border=NULL)

oncostrip(maf=MH_mut, genes=nest_pathway_list$`MDM2-p53 pathway`, border=NULL)
oncostrip(maf=ML_mut, genes=nest_pathway_list$`MDM2-p53 pathway`, border=NULL)
oncostrip(maf=MM_mut, genes=nest_pathway_list$`MDM2-p53 pathway`, border=NULL)

oncostrip(maf=MH_mut, genes=c('EGFR','KRAS'), border=NULL)
oncostrip(maf=ML_mut, genes=c('EGFR','KRAS'), border=NULL)
oncostrip(maf=MM_mut, genes=c('EGFR','KRAS'), border=NULL)

#分析EGFR没有差异的原因
A='EGFR'
A='KRAS'

a <- unique (CCLE_mut$DepMap_ID[CCLE_mut$Hugo_Symbol==A])
c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)%in%c('EGFR','KRAS','ILK')]
d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)%in%c('EGFR','KRAS','ILK')]
c <- as.data.frame(c)
d <- as.data.frame(d)
##从结果上可以看出，敲除EGFR对细胞生存的影响似乎与EGFR突变本身不相关，而是与其他突变相关。
##后面继续探究可以从细胞系的其他突变角度出发。猜测主要应该是上下游关系的问题。比如，当有KRAS突变
##的时候，敲除EGFR就没有意义

##细胞系表达分析，分析细胞系能不能分为三种，并得出相同的结论
# library(stringr)
# CCLE_expr <- read.csv('/database/depmap/CCLE_expression.csv',row.names = 1)
# a <- colnames(CCLE_expr)
# a <- str_split(a,'[..]',simplify = T)
# colnames(CCLE_expr) <- a[,1]
# CCLE_expr <- as.data.frame(t(CCLE_expr))
# CCLE_expr <- 2**CCLE_expr
# normalized_func <- function(x){x/sum(x)*1000000}
# a <- as.data.frame(apply(CCLE_expr, 2, normalized_func))
# CCLE_expr <- a
# 
# LUAD_cell_expr <- CCLE_expr[,colnames(CCLE_expr)%in%CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1]]
# a <- as.data.frame(t(LUAD_cell_expr[surv_sig_dgree[[8]][1:10,1],]))
# dist.e <- dist(a,method='euclidean')
# model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
# result <- cutree(model1,k=3)#分类
# result <- as.data.frame(result)
# paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
# b <- result
# b[b[,1]=='2',1] <- 'MM'
# b[b[,1]=='1',1] <- 'ML'
# b[b[,1]=='3',1] <- 'MH'
# b$sample_id <- rownames(b)
# 
# hotmap <- rbind(a[rownames(a)%in%b[b[,1]=='ML',2],],a[rownames(a)%in%b[b[,1]=='MM',2],],a[rownames(a)%in%b[b[,1]=='MH',2],])
# annotation_col <- as.data.frame(b[,1])
# rownames(annotation_col) <- b[,2]
# colnames(annotation_col) <- 'cluster'
# annotation_col[,1] <- factor(annotation_col[,1])
# colnames(annotation_col) <- c('cluster')
# ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
# hotmap <- log2(hotmap+1)
# hotmap <- t(hotmap)
# pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
#                    annotation_colors = ann_colors)#4cm*8cm
# pheatmap::pheatmap(a)
# ####分析差异突变
# library(maftools)
# CCLE_cell_mut <- read.csv('/database/depmap/突变信息/CCLE_mutations.csv')
# LUAD_cell_mut <- CCLE_cell_mut[CCLE_cell_mut$DepMap_ID%in%colnames(LUAD_cell_expr),]
# LUAD_cell_mut_sig <- data.frame(1:76)
# LUAD_cell_mut_sig <- as.data.frame(t(LUAD_cell_mut_sig))
# colnames(LUAD_cell_mut_sig) <- colnames(hotmap)
# a <- unique(LUAD_cell_mut[,1])
# # for (i in 1:length(a)) {
# #   LUAD_cell_mut_sig[i,colnames(LUAD_cell_mut_sig)%in%unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol==a[i]])] <- 1
# #   LUAD_cell_mut_sig[i,!colnames(LUAD_cell_mut_sig)%in%unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol==a[i]])] <- 0
# # }
# # rownames(LUAD_cell_mut_sig) <- a
# # 
# # CCLE_diff_mut <- data.frame(a)
# # c <- LUAD_cell_mut_sig[colnames(LUAD_cell_mut_sig)%in%rownames(b)[b[,1]=='ML'],]
# # d <- LUAD_cell_mut_sig[colnames(LUAD_cell_mut_sig)%in%rownames(b)[b[,1]=='MM'],]
# # e <- LUAD_cell_mut_sig[colnames(LUAD_cell_mut_sig)%in%rownames(b)[b[,1]=='MH'],]
# # ML <- colnames(LUAD_cell_mut_sig)%in%rownames(b)[b[,1]=='ML']
# # MM <- colnames(LUAD_cell_mut_sig)%in%rownames(b)[b[,1]=='MM']
# # MH <- colnames(LUAD_cell_mut_sig)%in%rownames(b)[b[,1]=='MH']
# # ML_MM <- function(x){
# #   c <- x[ML]
# #   d <- x[MM]
# #   t.test(c,d)$p.value
# # }
# # ML_MH <- function(x){
# #   c <- x[ML]
# #   d <- x[MH]
# #   t.test(c,d)$p.value
# # }
# # MM_MH <- function(x){
# #   c <- x[MM]
# #   d <- x[MH]
# #   t.test(c,d)$p.value
# # }
# # 
# # CCLE_diff_mut[,2] <- apply(LUAD_cell_mut_sig, 1, ML_MM)
# # CCLE_diff_mut[,3] <- apply(LUAD_cell_mut_sig, 1, ML_MH)
# # CCLE_diff_mut[,4] <- apply(LUAD_cell_mut_sig, 1, MM_MH)
# # 
# # 
# # for (i in 1:length(a)) {
# #   c <- LUAD_cell_mut_sig[ML,]
# #   d <- LUAD_cell_mut_sig[MM,]
# #   e <- LUAD_cell_mut_sig[MH,]
# #   CCLE_diff_mut[i,2] <- t.test(c,d)$p.value
# #   CCLE_diff_mut[i,3] <- t.test(c,e)$p.value
# #   CCLE_diff_mut[i,4] <- t.test(d,e)$p.value
# # }
# 
# CCLE_maf <- read.maf(maf = '/database/depmap/突变信息/CCLE_mutations.maf')
# luad.pfam <- pfamDomains(maf=LUAD_mut_raw, AACol="HGVSp_Short", top=10)
# plotmafSummary(maf=LUAD_mut_raw, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
#                titvRaw = FALSE,log_scale = F,showBarcodes = F)
# oncoplot(maf=LUAD_mut_raw, top=20, borderCol=NULL)
# lollipopPlot(maf=LUAD_mut_raw, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
# luad.mutload <- tcgaCompare(maf=LUAD_mut_raw, cohortName="Download_LUAD")

####我们用A549筛出来了一些药，那这些药用于PIK3CA突变的肿瘤中有没有效呢？
#获取PIK3CA，KRAS突变细胞系名称
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='KRAS'])
# P_K_mut_cell_line <- LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$DepMap_ID%in%P_K_mut_cell_line&
#                                                LUAD_cell_mut$Hugo_Symbol%in%nest_pathway_list[['Proximal RTK signaling']]]
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='PIK3CA'&
                                                      LUAD_cell_mut$DepMap_ID%in%P_K_mut_cell_line])



#获取cMAP这类细胞系的表达数据
#与A549相比较

####看看LGG和LIHC有没有这个特点

####药物筛选分析
#流程：分析两种背景的细胞系，有PIK3CA突变的细胞系和没有PIK3CA的细胞系。A549细胞系背景是




####
######FIG5 v2
####LUAD层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,1]=='ML',2],],data[rownames(data)%in%b[b[,1]=='MM',2],],data[rownames(data)%in%b[b[,1]=='MH',2],])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                   annotation_colors = ann_colors)#4cm*8cm
# ##
# ##常用函数
# library(maftools)
# LUAD_mut_raw <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = '/database/TCGA/LUAD/mutation/information/clinical.tsv')
# plotmafSummary(maf=LUAD_mut_raw, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
#                titvRaw = FALSE,log_scale = F,showBarcodes = F)
# oncoplot(maf=LUAD_mut_raw, top=10, borderCol=NULL)
# lollipopPlot(maf=LUAD_mut_raw, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
# luad.mutload <- tcgaCompare(maf=LUAD_mut_raw, cohortName="Download_LUAD")
# 
# ####比较ML/MM/MH的突变情况
# LUAD_mut <- LUAD_mut_raw@data
# LUAD_mut$Tumor_Sample_Barcode <- substring(text = LUAD_mut$Tumor_Sample_Barcode,first = 1,last = 12)
# LUAD_mut$Tumor_Sample_Barcode <- gsub(LUAD_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')
# b$patient <- substring(text = b$sample_id,first = 1,last = 12)
# ML_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$result=='ML',3],]
# MM_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$result=='MM',3],]
# MH_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$result=='MH',3],]
# # write.table(ML_mut,'result/LUAD/mutation/ML_mut.maf',sep = '\t',quote = F,row.names = F)
# # write.table(MM_mut,'result/LUAD/mutation/MM_mut.maf',sep = '\t',quote = F,row.names = F)
# # write.table(MH_mut,'result/LUAD/mutation/MH_mut.maf',sep = '\t',quote = F,row.names = F)
# ML_mut <- read.maf(maf ='result/LUAD/mutation/ML_mut.maf')
# MM_mut <- read.maf(maf ='result/LUAD/mutation/MM_mut.maf')
# MH_mut <- read.maf(maf ='result/LUAD/mutation/MH_mut.maf')
# 
# ML_mut_vs_MH_mut <- mafCompare(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
# MM_mut_vs_MH_mut <- mafCompare(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
# ML_mut_vs_MM_mut <- mafCompare(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', minMut = 2, useCNV =FALSE)
# 
# forestPlot(mafCompareRes = ML_mut_vs_MM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
# forestPlot(mafCompareRes = ML_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
# forestPlot(mafCompareRes = MM_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
# 
# r1<-ML_mut_vs_MH_mut$results
# g0<-r1[which(r1$pval<0.001),Hugo_Symbol]
# g1<-r1[1:5,Hugo_Symbol]
# l<-length(g0)
# ifelse(l>5,g<-g0,g<-g1)
# coOncoplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MMH_mut', genes = g, removeNonMutated = F)
# coBarplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut')

#############FIG5A
########与TMB结合分析
TMB <- list()
TMB[[1]] <- tmb(maf = ML_mut)
TMB[[1]] <- as.data.frame(TMB[[1]])
# for (i in 1:nrow(TMB[[1]])) {
#   TMB[[1]][i,5] <- patient_mut_score[patient_mut_score$V1%in%TMB[[1]][i,1],3]
# }
TMB[[2]] <- tmb(maf = MM_mut)
TMB[[2]] <- as.data.frame(TMB[[2]])
# for (i in 1:nrow(TMB[[2]])) {
#   TMB[[2]][i,5] <- patient_mut_score[patient_mut_score$V1%in%TMB[[2]][i,1],3]
# }
TMB[[3]] <- tmb(maf = MH_mut)
TMB[[3]] <- as.data.frame(TMB[[3]])
# for (i in 1:nrow(TMB[[3]])) {
#   TMB[[3]][i,5] <- patient_mut_score[patient_mut_score$V1%in%TMB[[3]][i,1],3]
# }
names(TMB) <- c('ML_mut','MM_mut','MH_mut')
##画箱线图
cbind(TMB[[1]],rep('ML',nrow(TMB[[1]])))
cbind(TMB[[2]],rep('MM',nrow(TMB[[2]])))
cbind(TMB[[3]],rep('MH',nrow(TMB[[3]])))
TMB_plot <- rbind(cbind(TMB[[1]]),
                  cbind(TMB[[2]]),
                  cbind(TMB[[3]]))
TMB_plot$cluster <- c(rep('ML',nrow(TMB[[1]])),rep('MM',nrow(TMB[[2]])),rep('MH',nrow(TMB[[3]])))
# colnames(TMB_plot)[5] <- 'mut_score'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('ML','MM','MH'))

library(ggplot2)
library(ggpubr)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  scale_fill_manual(values = c(ML = "#89C890",MM = "#4498F2", MH = "#ED5163"))+
  theme_classic()+
  geom_signif(comparisons = list(c("ML","MM"),c("ML","MH"),c('MM','MH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(30,32,30),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
a
####读取细胞系突变
library(stringr)
CCLE_mut <- read.csv('/database/depmap/突变信息/CCLE_mutations.csv')
CCLE_cell_line <- read.csv('/database/depmap/突变信息/sample_info.csv')
luad_cell_line <- CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1:3]
luad_cell_line_mut <- CCLE_mut[CCLE_mut$DepMap_ID%in%luad_cell_line$DepMap_ID,]

luad_cell_line_expr <- read.csv('/database/depmap/CRISPR_gene_dependency.csv',row.names = 1)
#luad_cell_line_expr <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%unique(luad_cell_line_mut$DepMap_ID),]

# luad_cell_line_expr <- crispr
# luad_cell_line_expr <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%unique(luad_cell_line_mut$DepMap_ID),]

a <- colnames(luad_cell_line_expr)
a <- str_split(a,'[..]',simplify = T)
colnames(luad_cell_line_expr) <- a[,1]
#ML_MM
ML_MM_mut_ddc <- data.frame()
sig_mut_list <- ML_mut_vs_MM_mut$results$Hugo_Symbol[ML_mut_vs_MM_mut$results$pval<0.05]
for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  ML_MM_mut_ddc[i,1] <- A
  a <- unique(luad_cell_line_mut$DepMap_ID[luad_cell_line_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  
  ML_MM_mut_ddc[i,2] <- e$estimate[1]
  ML_MM_mut_ddc[i,3] <- e$estimate[2]
  ML_MM_mut_ddc[i,4] <- e$p.value
}, error = function(e) {print('error')})
}
colnames(ML_MM_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value')
#ML_MH
ML_MH_mut_ddc <- data.frame()
sig_mut_list <- ML_mut_vs_MH_mut$results$Hugo_Symbol[ML_mut_vs_MH_mut$results$pval<0.05]
for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  ML_MH_mut_ddc[i,1] <- A
  a <- unique(luad_cell_line_mut$DepMap_ID[luad_cell_line_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  
  ML_MH_mut_ddc[i,2] <- e$estimate[1]
  ML_MH_mut_ddc[i,3] <- e$estimate[2]
  ML_MH_mut_ddc[i,4] <- e$p.value
}, error = function(e) {print('error')})
}
colnames(ML_MH_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value')
#MM_MH
MM_MH_mut_ddc <- data.frame()
sig_mut_list <- MM_mut_vs_MH_mut$results$Hugo_Symbol[MM_mut_vs_MH_mut$results$pval<0.05]
for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  MM_MH_mut_ddc[i,1] <- A
  a <- unique(luad_cell_line_mut$DepMap_ID[luad_cell_line_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  
  MM_MH_mut_ddc[i,2] <- e$estimate[1]
  MM_MH_mut_ddc[i,3] <- e$estimate[2]
  MM_MH_mut_ddc[i,4] <- e$p.value
}, error = function(e) {print('error')})
}
colnames(MM_MH_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value')

##对所有突变进行筛选(全细胞系)
#all_mut
all_mut_ddc <- data.frame()
sig_mut_list <- unique(LUAD_mut$Hugo_Symbol)
all_mut_table <- data.frame()
for (i in 1:length(sig_mut_list)) {
  all_mut_table[i,1] <- sig_mut_list[i]
  all_mut_table[i,2] <- length(unique(LUAD_mut$Tumor_Sample_Barcode[which(LUAD_mut$Hugo_Symbol==sig_mut_list[i])]))
}
names(all_mut_table) <- c('gene','num')
all_mut_table$percent <- all_mut_table$num/length(unique(LUAD_mut$Tumor_Sample_Barcode))
all_mut_table$type[all_mut_table$percent>=0.05] <- 'high'
all_mut_table$type[all_mut_table$percent<0.05] <- 'low'


for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  all_mut_ddc[i,1] <- A
  a <- unique(CCLE_mut$DepMap_ID[CCLE_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  all_mut_ddc[i,2] <- e$estimate[1]
  all_mut_ddc[i,3] <- e$estimate[2]
  all_mut_ddc[i,4] <- e$p.value
  all_mut_ddc[i,5] <- all_mut_ddc[i,2]-all_mut_ddc[i,3]
  all_mut_ddc[i,6] <- length(c)
  all_mut_ddc[i,7] <- length(d)
}, error = function(e) {print('error')})
}
A='KRAS'
colnames(all_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value','diff_ddc','mut_num','wt_num')
all_mut_ddc$p_adj <- p.adjust(all_mut_ddc$p_value)
all_mut_ddc$ddc_rate <- 2*all_mut_ddc$diff_ddc/(all_mut_ddc$mut_cell_line+all_mut_ddc$wt_cell_line)
effect_mut <- all_mut_ddc[!is.na(all_mut_ddc$p_value)&all_mut_ddc$p_value<0.05&abs(all_mut_ddc$diff_ddc)>0.01&abs(all_mut_ddc$ddc_rate)>0.10,]

####对每个病人进行定义,画出每个病人的高频低频突变的堆叠柱状图
##画柱状图看统计情况堆叠柱状图
library(ggplot2)
library(tidyr)
library(tidyverse)
library(ggtree)
library(aplot)
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
patient_mut <- data.frame(patient_id)
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  patient_mut[i,2] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='high']])
  patient_mut[i,3] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='low']])
}
colnames(patient_mut) <- c('patient_id','high','low')
a <- patient_id[order(apply(patient_mut[,2:3], 1, sum),decreasing = T)]
a <- c(a[a%in%b$patient[b$result=='ML']],a[a%in%b$patient[b$result=='MM']],a[a%in%b$patient[b$result=='MH']])

#rownames(patient_mut) <- patient_id
patient_mut <- patient_mut[patient_mut$patient_id%in%a,]
rownames(patient_mut) <- patient_mut$patient_id
patient_mut <- patient_mut[a,]
patient_mut$cluster[patient_mut$patient_id%in%b[b$result=='ML',3]] <- 'ML'
patient_mut$cluster[patient_mut$patient_id%in%b[b$result=='MM',3]] <- 'MM'
patient_mut$cluster[patient_mut$patient_id%in%b[b$result=='MH',3]] <- 'MH'
group <- patient_mut[,c(1,4)]
patient_mut <- pivot_longer(data = patient_mut,cols = 2:3,
                            names_to = "mut_frequency",##这一个参数是将列名命名为sample_size
                            values_to = "mut_frequency_value")##col
patient_mut$cluster <- factor(patient_mut$cluster,levels = c('ML','MM','MH'))
patient_mut$patient_id <- factor(patient_mut$patient_id,levels = a)
patient_mut$mut_frequency <- factor(patient_mut$mut_frequency,levels = c('high','low'))

p <- ggplot(border=0,patient_mut, aes(x=patient_id, y=mut_frequency_value,fill=mut_frequency)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack", width=1,size=0.25)+
  scale_fill_manual(values=c("red","#399938"))+
  labs(x = element_blank(),y = "",title='mutation per patient')+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()+
  theme(axis.ticks.x = element_blank(),axis.text.x = element_blank())#6cm*5cm
#绘制分组色条
group$patient_id <- factor(group$patient_id,levels = a)
group$cluster <- factor(group$cluster,levels = c('ML','MM','MH'))
q <- ggplot(group,aes(patient_id,y=1,fill=cluster))+
  geom_tile()+
  scale_fill_manual(values=c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163"))+
  scale_x_discrete(expand=c(0,0)) +
  scale_y_discrete(expand=c(0,0))+
  labs(x = "patient(n=493)")+
  theme(axis.text = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks = element_blank())

#拼图
insert_bottom(p,q,height=0.03)
#6cm*8cm

#另一个版本的图
library(ggplot2)
library(tidyr)
library(tidyverse)
library(ggtree)
library(aplot)
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
patient_mut <- data.frame(patient_id)
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  patient_mut[i,2] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='high']])
  patient_mut[i,3] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='low']])
}
colnames(patient_mut) <- c('patient_id','high','low')
a <- patient_id[order(apply(patient_mut[,2:3], 1, sum),decreasing = T)]
# a <- c(a[a%in%b$patient[b$result=='ML']],a[a%in%b$patient[b$result=='MM']],a[a%in%b$patient[b$result=='MH']])

#rownames(patient_mut) <- patient_id
patient_mut <- patient_mut[patient_mut$patient_id%in%a,]
rownames(patient_mut) <- patient_mut$patient_id
patient_mut <- patient_mut[a,]
patient_mut$cluster[patient_mut$patient_id%in%b[b$result=='ML',3]] <- 'ML'
patient_mut$cluster[patient_mut$patient_id%in%b[b$result=='MM',3]] <- 'MM'
patient_mut$cluster[patient_mut$patient_id%in%b[b$result=='MH',3]] <- 'MH'
group <- patient_mut[,c(1,4)]
patient_mut <- pivot_longer(data = patient_mut,cols = 2:3,
                            names_to = "mut_frequency",##这一个参数是将列名命名为sample_size
                            values_to = "mut_frequency_value")##col
patient_mut$cluster <- factor(patient_mut$cluster,levels = c('ML','MM','MH'))
patient_mut$patient_id <- factor(patient_mut$patient_id,levels = a)
patient_mut$mut_frequency <- factor(patient_mut$mut_frequency,levels = c('high','low'))

p <- ggplot(border=0,patient_mut, aes(x=patient_id, y=mut_frequency_value,fill=mut_frequency)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack", width=1,size=0.25)+
  scale_fill_manual(values=c("red","#399938"))+
  labs(x = element_blank(),y = "",title='mutation per patient')+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()+
  theme(axis.ticks.x = element_blank(),axis.text.x = element_blank())#6cm*5cm
#绘制分组色条
group$patient_id <- factor(group$patient_id,levels = a)
group$cluster <- factor(group$cluster,levels = c('ML','MM','MH'))
q <- ggplot(group,aes(patient_id,y=1,fill=cluster))+
  geom_tile()+
  scale_fill_manual(values=c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163"))+
  scale_x_discrete(expand=c(0,0)) +
  scale_y_discrete(expand=c(0,0))+
  labs(x = "patient(n=493)")+
  theme(axis.text = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks = element_blank())

#拼图
insert_bottom(p,q,height=0.03)#6*8




##画整体突变基因图
library(maftools)
LUAD_mut_raw <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = '/database/TCGA/LUAD/mutation/information/clinical.tsv')
luad.pfam <- pfamDomains(maf=LUAD_mut_raw, AACol="HGVSp_Short", top=10)
plotmafSummary(maf=LUAD_mut_raw, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
               titvRaw = FALSE,log_scale = F,showBarcodes = F)
oncoplot(maf=LUAD_mut_raw, top=20, borderCol=NULL)
lollipopPlot(maf=LUAD_mut_raw, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
luad.mutload <- tcgaCompare(maf=LUAD_mut_raw, cohortName="Download_LUAD")

ML_mut_vs_MH_mut <- mafCompare(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
MM_mut_vs_MH_mut <- mafCompare(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
ML_mut_vs_MM_mut <- mafCompare(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = ML_mut_vs_MM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = ML_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = MM_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MM_mut$results
r1<-MM_mut_vs_MH_mut$results
r1<-ML_mut_vs_MH_mut$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML', m2Name = 'MM', genes = g1, removeNonMutated = T)
coOncoplot(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM', m2Name = 'MH', genes = g1, removeNonMutated = F)
coOncoplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML', m2Name = 'MH', genes = g1, removeNonMutated = T)
#3cm*15cm
coBarplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut')

####Nest定义每个病人
nest_pathway <- read.csv('/database/IAS/NeST Map - Main Model default node.csv')
nest_pathway_list <- list()
for (i in 1:nrow(nest_pathway)) {
  a <- nest_pathway[i,4]
  nest_pathway_list[[i]] <- str_split(a,' ',simplify = F)[[1]]
}
names(nest_pathway_list) <- nest_pathway$Annotation

path_num_cal <- function(x){
  x=nest_pathway_list[[x]]
  length(which(a%in%x))
}
patient_pathway <- list()
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  a <- a[a%in%ref_all_mut_ddc$Gene]
  b <- as.data.frame(names(nest_pathway_list))
  b[,2] <- apply(b, 1, path_num_cal)
  colnames(b) <- c('pathway_name','map_mut_num')
  patient_pathway[[i]] <- b
}
names(patient_pathway) <- patient_id

patient_pathway_table <- data.frame(names(nest_pathway_list))
rownames(patient_pathway_table) <- patient_pathway_table[,1]
for (i in 1:length(patient_pathway)) {
  patient_pathway_table[,i] <- patient_pathway[[i]][,2]
  patient_pathway_table[patient_pathway_table[,i]>0,i] <- 1
  patient_pathway_table[patient_pathway_table[,i]==0,i] <- 0
}
colnames(patient_pathway_table) <- names(patient_pathway)

patient_pathway_table <- patient_pathway_table[apply(patient_pathway_table, 1, sum)>0,]

result
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
##画热图比较这两组样本的基因
hotmap <- cbind(patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='ML',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MM',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
##画瀑布图
diff_pathway_list <- data.frame(rownames(hotmap))
for (i in 1:nrow(diff_pathway_list)) {
  c <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='ML',3]]
  d <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='MM',3]]
  e <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='MH',3]]
  diff_pathway_list[i,2] <- sum(c)
  diff_pathway_list[i,3] <- sum(d)
  diff_pathway_list[i,4] <- sum(e)
  diff_pathway_list[i,5] <- t.test(c,d)$p.value
  diff_pathway_list[i,6] <- t.test(c,e)$p.value
  diff_pathway_list[i,7] <- t.test(d,e)$p.value
}
colnames(diff_pathway_list) <- c('pathway','ML','MM','MH','ML_MM','ML_MH','MM_MH')
c <- apply(hotmap, 1, sum)
c <- cbind(rownames(hotmap),c)
c <- as.data.frame(c)
colnames(c) <- c('nest','num')
c <- c[order(as.numeric(c[,2]),decreasing = F),]
for (i in 1:nrow(c)) {
  a <- as.data.frame(hotmap[i,])
  hotmap <- cbind(hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==1]],
                  hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==0]])
}
hotmap <- hotmap[rownames(c)[nrow(c):1],]
a <- pheatmap::pheatmap(hotmap,cluster_col = T,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- as.data.frame(cutree(a$tree_col,k=2))
hotmap <- cbind(hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==1]],
                hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==2]])

hotmap <- cbind(hotmap[,colnames(hotmap)%in%b[b[,1]=='ML',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MM',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MH',3]])
hotmap <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[!(diff_pathway_list$ML_MM>0.05&diff_pathway_list$ML_MH>0.05&diff_pathway_list$MM_MH>0.05)],]


a <- pheatmap::pheatmap(hotmap,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$ML_MM<0.05],]
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$MM_MH<0.05],]
a <- pheatmap::pheatmap(a,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm



diff_pathway_list$ML_specific[(diff_pathway_list$ML/179)>(diff_pathway_list$MM/258)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$ML/179)>(diff_pathway_list$MH/67)&diff_pathway_list$ML_MH<0.05] <- '1'
diff_pathway_list$MM_specific[(diff_pathway_list$MM/258)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$MM/258)>(diff_pathway_list$MH/67)&diff_pathway_list$MM_MH<0.05] <- '1'
diff_pathway_list$MH_specific[(diff_pathway_list$MH/67)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MH<0.05&
                                (diff_pathway_list$MH/67)>(diff_pathway_list$MM/258)&diff_pathway_list$MM_MH<0.05] <- '1'
#write.csv(diff_pathway_list,'result/Figure/AI_plot_new/fig4/v2/样本差异突变通路.csv',row.names = F)
####验证结果
a <- patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]]
colnames(a)[a["Proximal RTK signaling",]==1]

#################替换为伯努利检验（二项检验）
####Nest定义每个病人
library(stats)
nest_pathway <- read.csv('/database/IAS/NeST Map - Main Model default node.csv')
nest_pathway_list <- list()
for (i in 1:nrow(nest_pathway)) {
  a <- nest_pathway[i,4]
  nest_pathway_list[[i]] <- str_split(a,' ',simplify = F)[[1]]
}
names(nest_pathway_list) <- nest_pathway$Annotation

path_num_cal <- function(x){
  x=nest_pathway_list[[x]]
  length(which(a%in%x))
}
patient_pathway <- list()
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  a <- a[a%in%ref_all_mut_ddc$Gene]
  b <- as.data.frame(names(nest_pathway_list))
  b[,2] <- apply(b, 1, path_num_cal)
  colnames(b) <- c('pathway_name','map_mut_num')
  patient_pathway[[i]] <- b
}
names(patient_pathway) <- patient_id

patient_pathway_table <- data.frame(names(nest_pathway_list))
rownames(patient_pathway_table) <- patient_pathway_table[,1]
for (i in 1:length(patient_pathway)) {
  patient_pathway_table[,i] <- patient_pathway[[i]][,2]
  patient_pathway_table[patient_pathway_table[,i]>0,i] <- 1
  patient_pathway_table[patient_pathway_table[,i]==0,i] <- 0
}
colnames(patient_pathway_table) <- names(patient_pathway)

patient_pathway_table <- patient_pathway_table[apply(patient_pathway_table, 1, sum)>0,]

result
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
##画热图比较这两组样本的基因
hotmap <- cbind(patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='ML',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MM',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
##画瀑布图
diff_pathway_list <- data.frame(rownames(hotmap))
for (i in 1:nrow(diff_pathway_list)) {
  c <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='ML',3]])
  d <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='MM',3]])
  e <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='MH',3]])
  diff_pathway_list[i,2] <- sum(c)
  diff_pathway_list[i,3] <- sum(d)
  diff_pathway_list[i,4] <- sum(e)
  diff_pathway_list[i,5] <- binom.test(x = sum(d),n = length(d),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value
  diff_pathway_list[i,6] <- binom.test(x = sum(e),n = length(e),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value
  diff_pathway_list[i,7] <- binom.test(x = sum(e),n = length(e),p = sum(d)/length(d),alternative = "two.sided",conf.level = 0.95)$p.value
}

binom.test(x = sum(d),n = length(d),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value

colnames(diff_pathway_list) <- c('pathway','ML','MM','MH','ML_MM','ML_MH','MM_MH')
c <- apply(hotmap, 1, sum)
c <- cbind(rownames(hotmap),c)
c <- as.data.frame(c)
colnames(c) <- c('nest','num')
c <- c[order(as.numeric(c[,2]),decreasing = F),]
for (i in 1:nrow(c)) {
  a <- as.data.frame(hotmap[i,])
  hotmap <- cbind(hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==1]],
                  hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==0]])
}
hotmap <- hotmap[rownames(c)[nrow(c):1],]
a <- pheatmap::pheatmap(hotmap,cluster_col = T,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- as.data.frame(cutree(a$tree_col,k=2))
hotmap <- cbind(hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==1]],
                hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==2]])

hotmap <- cbind(hotmap[,colnames(hotmap)%in%b[b[,1]=='ML',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MM',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MH',3]])
hotmap <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[!(diff_pathway_list$ML_MM>0.05&diff_pathway_list$ML_MH>0.05&diff_pathway_list$MM_MH>0.05)],]


a <- pheatmap::pheatmap(hotmap,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$ML_MM<0.05],]
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$MM_MH<0.05],]
a <- pheatmap::pheatmap(a,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm



diff_pathway_list$ML_specific[(diff_pathway_list$ML/179)>(diff_pathway_list$MM/258)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$ML/179)>(diff_pathway_list$MH/67)&diff_pathway_list$ML_MH<0.05] <- 1
diff_pathway_list$MM_specific[(diff_pathway_list$MM/258)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MM<0.05] <- 1
diff_pathway_list$MH_specific[(diff_pathway_list$MH/67)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MH<0.05&
                                (diff_pathway_list$MH/67)>(diff_pathway_list$MM/258)&diff_pathway_list$MM_MH<0.05] <- 1
#write.csv(diff_pathway_list,'result/Figure/AI_plot_new/fig4/v2/样本差异突变通路.csv',row.names = F)
####验证结果
a <- patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]]
colnames(a)[a["Proximal RTK signaling",]==1]


####火山图展示有效突变基因
library(ggpubr)
library(ggplot2)
library(ggthemes)
library(ggrepel)
mut_gene_plot <- all_mut_ddc[!is.na(all_mut_ddc$p_value),]
mut_gene_plot$'-lg(pvalue)' <- -1*log10(mut_gene_plot$p_value)
mut_gene_plot$label <- NA
mut_gene_plot$label[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05]
mut_gene_plot$label[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05]
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&mut_gene_plot$Gene%in%all_mut_table[all_mut_table$type=='high',1]] <- 'effective_high'
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&mut_gene_plot$Gene%in%all_mut_table[all_mut_table$type=='low',1]] <- 'effective_low'
mut_gene_plot$group[!(abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05)] <- 'invalid'

mut_gene_plot <- mut_gene_plot[order(mut_gene_plot$`-lg(pvalue)`),]#对差异表达基因调整后的p值进行排序
mut_gene_plot$`-lg(pvalue)`[mut_gene_plot$`-lg(pvalue)`>25] <- 25

#添加特定基因label
ggscatter(mut_gene_plot,x = "ddc_rate",y = "-lg(pvalue)",color = "group",
          palette = c('red','#399938','gray'), label = mut_gene_plot$label,
          repel = T, ylab = "-lg(pvalue)", size = 1,) + 
  theme_base()+
  theme(element_line(size = 0),element_rect(size = 1.5))+ #坐标轴线条大小设置
  scale_y_continuous(limits = c(0,26))+
  scale_x_continuous(limits = c(-2,2))+
  geom_point(aes(size=abs(diff_ddc),color=group))+
  geom_hline(yintercept = -log10(0.05),linetype = "dashed")+
  geom_vline(xintercept = c(-0.1,0.1),linetype = "dashed")#7cm*6cm

##画差异通路气泡图
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
diff_pathway_plot <- diff_pathway_list
diff_pathway_plot$ML <- diff_pathway_plot$ML/sum(b$result=='ML')
diff_pathway_plot$MM <- diff_pathway_plot$MM/sum(b$result=='MM')
diff_pathway_plot$MH <- diff_pathway_plot$MH/sum(b$result=='MH')
diff_pathway_plot$ML_MM_log2FC <- log2(diff_pathway_plot$ML/diff_pathway_plot$MM)
diff_pathway_plot$ML_MH_log2FC <- log2(diff_pathway_plot$ML/diff_pathway_plot$MH)
diff_pathway_plot$MM_MH_log2FC <- log2(diff_pathway_plot$MM/diff_pathway_plot$MH)

diff_pathway_plot$ML_MH[is.nan(diff_pathway_plot$ML_MH)] <- 1
diff_pathway_plot$MM_MH[is.nan(diff_pathway_plot$MM_MH)] <- 1
diff_pathway_plot$ML_MM_log2FC[diff_pathway_plot$ML_MM_log2FC==Inf] <- 4
diff_pathway_plot$ML_MM_log2FC[diff_pathway_plot$ML_MM_log2FC==-Inf] <- -4
diff_pathway_plot$ML_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==Inf] <- 4
diff_pathway_plot$ML_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==-Inf] <- -4
diff_pathway_plot$MM_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==Inf] <- 4
diff_pathway_plot$MM_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==-Inf] <- -4


diff_pathway_plot <- diff_pathway_plot[!(diff_pathway_plot$ML_MM>0.05&
                                           diff_pathway_plot$ML_MH>0.05&
                                           diff_pathway_plot$MM_MH>0.05),]
diff_pathway_plot <- diff_pathway_plot[!(abs(diff_pathway_plot$ML_MM_log2FC)<1&
                                           abs(diff_pathway_plot$ML_MH_log2FC)<1&
                                           abs(diff_pathway_plot$MM_MH_log2FC)<1),]
colnames(diff_pathway_plot)[1] <- 'Annotation'
diff_pathway_plot <- merge(diff_pathway_plot,nest_pathway[,c('Annotation','Size')],all=F,by='Annotation')
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Size<50&
                                         diff_pathway_plot$ML>0.05|
                                         diff_pathway_plot$MM>0.05|
                                         diff_pathway_plot$MH>0.05,]

a <- c(diff_pathway_plot[order(diff_pathway_plot$ML_MM,decreasing = F)[1:10],1],
       diff_pathway_plot[order(diff_pathway_plot$ML_MH,decreasing = F)[1:10],1],
       diff_pathway_plot[order(diff_pathway_plot$MM_MH,decreasing = F)[1:10],1])
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Annotation%in%a,]

a <- pivot_longer(diff_pathway_plot[,c('Annotation','ML_MM','ML_MH','MM_MH')],cols = 2:4,
                  names_to = 'compare_object',values_to = 'p_value')
b <- pivot_longer(diff_pathway_plot[,c('Annotation','ML_MM_log2FC','ML_MH_log2FC','MM_MH_log2FC')],cols = 2:4,
                  names_to = 'compare_object',values_to = 'log2FC')
diff_pathway_plot <- cbind(a,b[,3]) 
diff_pathway_plot$p_value <- round(as.numeric(diff_pathway_plot$p_value),2)
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$p_value<0.05,]
diff_pathway_plot$compare_object <- factor(diff_pathway_plot$compare_object,
                                           levels = c('ML_MM','MM_MH','ML_MH'))
a <- as.data.frame(unique(diff_pathway_plot$Annotation))
#write.csv(a,'result/Figure/AI_plot_new/fig4/v3/annotation_v2.csv')
a <- read.csv('result/Figure/AI_plot_new/fig4/v3/annotation_v2.csv',row.names = 1)
a <- a[c(which(a$function.=='other process'),
         which(a$function.=='signaling process'),
         which(a$function.=='cell cycle')),]
diff_pathway_plot$Annotation <- factor(diff_pathway_plot$Annotation,levels = a$pathway)

y_color <- as.data.frame(a)
colnames(y_color)[2] <- 'fuction'
y_color[y_color[,2]=='other process',3] <- 'black'
y_color[y_color[,2]=='cell cycle',3] <- 'red'
y_color[y_color[,2]=='signaling process',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$type <- factor(y_color$type,levels = c('cell cycle','signaling process','other process'))
y_color$xmin <- -Inf
y_color$xmax <- Inf
y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

plot <- ggplot(diff_pathway_plot,aes(x=compare_object,y=Annotation))+
  geom_point(aes(size=abs(`log2FC`),color=`p_value`))+
  scale_color_gradient(high="#1E08F7",low="#F20808")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=0,hjust = 0.5,vjust=0.5),
        axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='other process'),
                                                           which(y_color$type=='signaling process'),
                                                           which(y_color$type=='cell cycle'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=c('red','blue','black'))+
  labs(x=NULL,y=NULL,title = 'the pathway of different cluster')#6cm*7cm

########FIG5_V2
####先不关心突变，直接筛选药效好的药物，然后看这些药物的通路是否与周期蛋白和PIK3CA相关
####drug effection significance
####药物筛选
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA

##画韦恩图
library(VennDiagram)
venn.plot <- venn.diagram(x = list(cMAP_A549=All_drug,GDSC_A549=gdsc_A549_drug),
                          category.names = c('cMAP_A549','GDSC_A549'),
                          filename = NULL,
                          scaled = F,
                          height = 1500, width = 1500, resolution =600,
                          alpha=c(0.6, 0.6),
                          fill=c(colors()[616], colors()[38]), 
                          lwd=rep(1,2), cex=0.45, 
                          fontfamily = "serif", fontface = "bold",
                          cat.dist=c(-0.07, -0.07),
                          output=TRUE,
                          area.vector = 0,
                          cat.pos=c(280, 80), #位置
                          cat.cex=0.45)##画韦恩图

pdf("result/Figure/luad_drug_screen_5.pdf")
grid.draw(venn.plot)
dev.off()
##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
pheatmap::pheatmap(luad_overlap[,2:10],clustering_method = 'ward.D2')
bk = unique(c(seq(-4,4, length=200)))
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:10]),breaks = bk,show_rownames = T,treeheight_row = 0,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = F,cluster_rows = T,cluster_cols = T)
cluster <- hotmap$tree_col
plot(cluster,hang = -1,cex=0.6,axes=FALSE,ann=FALSE)
cut <- as.data.frame(cutree(cluster,2))
annotation_row <- cut
colnames(annotation_row) <- 'cluster'
annotation_row[annotation_row[,1]==1,1] <- 'mitotic_i'
annotation_row[annotation_row[,1]==2,1] <- 'con'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
ann_colors = list(cluster = c(con="#ED5163", mitotic_i="#4498F2")) 
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:10]),breaks = bk,show_rownames = T,treeheight_row = 0,annotation_col = annotation_row,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = F,cluster_rows = T,cluster_cols = T,
                             annotation_colors = ann_colors)#6cm*8cm

drug_effection <- list()
drug_effection[[1]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==1],]
drug_effection[[2]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==2],]
names(drug_effection) <- c('mitotic_i','mitotic_con')
for (i in 1:2) {
  a <- aggregate(drug_effection[[i]]$V11,by=list(drug_effection[[i]][,1]),FUN=mean)
  drug_effection[[i]] <- a
}
for (i in 1:2) {
  drug_effection[[i]] <- cbind(drug_effection[[i]],rep(c('mitotic_i','con')[i],nrow(drug_effection[[i]])))
  colnames(drug_effection[[i]]) <- c('drug_name','cell_viability','cluster')
}
#drug_effection[[1]] <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
a <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
b <- drug_effection[[2]][!drug_effection[[2]]$drug_name%in%drug_effection[[1]]$drug_name,]
drug_effection_plot <- rbind(a,b)

#drug_effection_plot <- rbind(drug_effection[[1]],
#                            drug_effection[[2]])
drug_effection_plot$cluster <- as.factor(drug_effection_plot$cluster)

library(ggplot2)
library(ggpubr)
p = ggplot(drug_effection_plot, aes(x=cluster, y=cell_viability,fill=cluster)) + 
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)
p+geom_jitter(shape=16, position = position_jitter(0.2))+
  stat_compare_means(method = "t.test" )

ggplot(drug_effection_plot, aes(x=cluster, y=cell_viability,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test" )#5cm*4cm

##
drug_info <- read.csv('/database/GDSC/drug_IC50/screened_compunds_rel_8.2.csv')
drug_info$name <- tolower(drug_info$DRUG_NAME)
effect_drug_info <- drug_info[drug_info$name%in%drug_effection_plot$drug_name[drug_effection_plot$cluster=='mitotic_i'],]

##查看是否有相应的细胞系数据
#获取PIK3CA，KRAS突变细胞系名称
library(maftools)
# CCLE_cell_mut <- read.csv('/database/depmap/突变信息/CCLE_mutations.csv')
LUAD_cell_mut <- CCLE_cell_mut[CCLE_cell_mut$DepMap_ID%in%CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1],]
LUAD_cell_mut_sig <- data.frame(1:76)
LUAD_cell_mut_sig <- as.data.frame(t(LUAD_cell_mut_sig))
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='KRAS'])
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='PIK3CA'&
                                                      LUAD_cell_mut$DepMap_ID%in%P_K_mut_cell_line])
CCLE_cell_line$stripped_cell_line_name[CCLE_cell_line$DepMap_ID%in%P_K_mut_cell_line]

gdsc_SW1573 <- gdsc[gdsc$CELL_LINE_NAME=='SW1573',]
gdsc_SW1573 <- gdsc_SW1573[gdsc_SW1573$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_SW1573 <- gdsc_SW1573[gdsc_SW1573$DATASET=='GDSC2',]
gdsc_A549 <- gdsc[gdsc$CELL_LINE_NAME=='A549',]
gdsc_A549 <- gdsc_A549[gdsc_A549$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_A549 <- gdsc_A549[gdsc_A549$DATASET=='GDSC2',]

c <- gdsc_A549[-8,c(5,9,19)]
d <- gdsc_SW1573[-8,c(5,9,19)]
t.test(c[,3], d[,3], paired = TRUE)
a <- rbind(c,d)
ggplot(a, aes(x=CELL_LINE_NAME, y=Z_SCORE,fill=CELL_LINE_NAME)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test",paired = T )#5cm*4cm

####然后查询文献或临床试验中PI3K抑制剂与其他药物联用的效果
####联合用药预测(这部分可能还是得实验)
drug_combine_raw <- read.csv('/database/DrugComb/summary_v_1_5.csv')
drug_combine <- drug_combine_raw
drug_combine$drug_row <- tolower(drug_combine$drug_row)
drug_combine$drug_col <- tolower(drug_combine$drug_col)
drug_combine <- drug_combine[c(which(drug_combine$drug_row%in%effect_drug_info$name),
                               which(drug_combine$drug_col%in%effect_drug_info$name),]

####






####BUB1B的解释
#BUB1B的基因依赖性
luad_cell_line_expr[a[a%in%rownames(luad_cell_line_expr)],'BUB1B']
luad_cell_line_expr['ACH-002157','BUB1B']

a <- CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1]
a <- CCLE_mut[CCLE_mut$DepMap_ID%in%a,]

#计算在药物作用下与BUB1B相关性最强的基因群
luad <- cell_line_expr_drug[[8]][[7]]
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA

##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
write.csv(luad_overlap,'result/A549_effect_drug_list.csv')

####读取A549细胞系有效药物的基因表达数据
A549_drug_gene_res <- read.csv('/database/cMAP/A549_cell_drug_expr_data.csv')
library(clusterProfiler)
a <- bitr(A549_drug_gene_res[,1],fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
          toType = c('SYMBOL'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
colnames(A549_drug_gene_res)[1] <- 'ENTREZID'
A549_drug_gene_res <- merge(a,A549_drug_gene_res,by='ENTREZID',all=F)
rownames(A549_drug_gene_res) <- A549_drug_gene_res[,2]
A549_drug_gene_res <- A549_drug_gene_res[,-1:-2]

cor_p_value <- function(x){cor.test(BUB1B_expr,as.numeric(x),method = 'spearman')$p.value}
cor_estimate <- function(x){cor.test(BUB1B_expr,as.numeric(x),method = 'spearman')$estimate}

BUB1B_expr <- as.numeric(A549_drug_gene_res['BUB1B',])
BUB1B_cor <- data.frame(rownames(A549_drug_gene_res))
BUB1B_cor$drug_cor <- apply(A549_drug_gene_res,1,cor_estimate)
BUB1B_cor$drug_p_value <- apply(A549_drug_gene_res,1,cor_p_value)
BUB1B_cor$drug_p_adj <- p.adjust(BUB1B_cor$drug_p_value)

LUAD_TCGA_expr <- expr_data_raw[[8]]
LUAD_TCGA_expr <- LUAD_TCGA_expr[rownames(LUAD_TCGA_expr)%in%rownames(A549_drug_gene_res),]
LUAD_TCGA_expr <- LUAD_TCGA_expr[rownames(A549_drug_gene_res),]
rownames(LUAD_TCGA_expr) <- rownames(A549_drug_gene_res)
LUAD_TCGA_expr <- as.matrix(LUAD_TCGA_expr)
LUAD_TCGA_expr[is.na(LUAD_TCGA_expr)] <- 0
BUB1B_expr <- as.numeric(LUAD_TCGA_expr['BUB1B',])


BUB1B_cor$TCGA_cor <- apply(LUAD_TCGA_expr,1,cor_estimate)
BUB1B_cor$TCGA_p_value <- apply(LUAD_TCGA_expr,1,cor_p_value)
BUB1B_cor$TCGA_p_adj <- p.adjust(BUB1B_cor$TCGA_p_value)

a <- BUB1B_cor[BUB1B_cor$drug_cor>0.5&BUB1B_cor$TCGA_cor>0.5,1]
a <- bitr(a,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
#可以看到，在正常状态下与药物作用下与BUB1B都高度相关的基因（>0.5），它富集到的普遍是DNA复制检查点和G2/M检查点，以此可以解释为什么BUB1B在药物作用下会升高




###############BRCA重新分析，转换思路
a <- c('CD40LG','CIRBP','PSMD10','GARS1','POP1','GNPNAT1','PICALM','RABGAP1',
       'SPOCK2','QPRT','TMEM101','CBX7')
a <- surv_sig_dgree[[2]][,1]
data <- as.data.frame(t(expr_data_raw[[2]][gene,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]


b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$Tumor_Sample_Barcode <- gsub(pattern = '-',replacement = '.',x = b$case_id)
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'
# b_basal <- b[!is.na(b$cluster_subtype),]

b <- merge(b,data,by='Tumor_Sample_Barcode',all=F)
b$vital_status[which(b$V5 > 3650)] <- 0 
b$V5[which(b$V5 > 3650)] <- 3650

b_LumA <- b[b$File.Name=='LumA',]
b_LumB <- b[b$File.Name=='LumB',]
b_Her2 <- b[b$File.Name=='Her2',]
b_Basal <- b[b$File.Name=='Basal',]

library(survminer)
library(survival)
a <- c('CD40LG','CIRBP','PSMD10','GARS1','POP1','GNPNAT1','PICALM','RABGAP1',
       'SPOCK2','QPRT','TMEM101','CBX7')
a <- surv_sig_dgree[[2]][,1]
a <- gene
B <- c('LumA','LumB','Her2','Basal')
A <- as.data.frame(t(data.frame(1:4)))

for (j in 1:4) {
  b1 <- b[b$File.Name==B[j],]
  for (i in 1:length(a)) {
    tryCatch({
      b2=b1
      b2$File.Name[b2[,a[i]]>median(b2[,a[i]])] <- 'high'
      b2$File.Name[b2[,a[i]]<=median(b2[,a[i]])] <- 'low'
      c <- survdiff(Surv(b2[,6],as.numeric(b2[,3]))~b2[,8], data = b2)
      A[i,j] <- 1-pchisq(c$chisq,1)
    }, error = function(e) {print('error')})
  }
}
rownames(A) <- a[1:nrow(A)]
colnames(A) <- B

A[A[,1]<0.05&A[,2]<0.05&A[,3]<0.05&A[,4]<0.05,]

c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)






c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
surv_sig_dgree[[2]][1:10]
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_Basal'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)


####BRCA所有网络的hub
a <- surv_sig_inter[[2]]
colnames(a) <- c('gene1','value','gene2')
b <- a[,3:1]
colnames(b) <- c('gene1','value','gene2')
a <- rbind(a,b)
gene <- unique(a$gene1)
b <- data.frame(1:length(gene))
for (i in 1:length(gene)) {
  k1 <- a$gene2[a$gene1%in%gene[i]]
  k2 <- a$gene2[a$gene1%in%k1]
  k3 <- a$gene2[a$gene1%in%k2]
  b[i,2] <- length(unique(c(k1,k2,k3)))
}
b[,1] <- gene
colnames(b) <- c('gene','k3')
b <- b[order(b$k3,decreasing = T),]

a <- surv_sig_dgree[[2]]
for (i in 1:nrow(b)) {
  ifelse(b[i,1]%in%a[,1],b$degree[i] <- a[a[,1]==b[i,1],2],b$degree[i] <- 0)
}
b <- b[1:20,]
b <- b[b[,3]!=0,]
# a <- surv_sig_inter[[2]][surv_sig_inter[[2]][,1]==b[1,1],]
# a <- b[b[,1]%in%a[,3],]
# a <- a[order(a[,2],decreasing = T),]
# a <- a[1:10,]
# a <- a[order(a$degree,decreasing = T),]
# a <- a[1:5,1]
a <- b[,1]

#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
library(clusterProfiler)
# a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
#           toType = c('ENTREZID'), #totype指需要转换成的ID类型
#           OrgDb='org.Hs.eg.db')
# a <- enrichGO(a[,2], #数据源
#                                    pvalueCutoff = 1, #P值阈值
#                                    qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
#                                    OrgDb = org.Hs.eg.db, #人类参考基因组
#                                    ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
#                                    readable = TRUE) #是否将基因ID转换为基因名



data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][surv_sig_dgree[[2]][,2]>=16,1]),]))
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%a),]))

for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}

#data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=4)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
annotation_col[annotation_col[,1]==2,1] <- 'IM'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
annotation_col[annotation_col[,1]%in%c(4,5),1] <- 'IS'
a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IS'],])#4cm*8cm

a <- t(a)
# a <- log2(t(a)+1)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col,
                   breaks = bk)#5*8

paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),sep = '')
#亚型与不同聚类的生存曲线
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
b[b[,6]%in%rownames(result)[result[,1]%in%c(4,5)],7] <- 'IS'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#E24A0E","blue","#F2CA20"),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##亚型生存曲线
library(stringr)
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#4498F2","gray","#ED5163","#72FCA0"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm

####查看不同亚型下免疫low与median的区别
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IL']] <- 'IL_LumA'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IM']] <- 'IM_LumA'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IH']] <- 'IH_LumA'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IS']] <- 'IS_LumA'

b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_LumA'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_LumA','IM_LumA','IH_LumA'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IS']] <- 'IS_LumA'

b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_Basal'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_Basal','IM_Basal','IH_Basal'))##对齐坐标轴原点#4cm*5cm

##接下来对基因进行归类
a <- surv_sig_inter[[2]]
colnames(a) <- c('gene1','value','gene2')
b <- a[,3:1]
colnames(b) <- c('gene1','value','gene2')
a <- rbind(a,b)
gene <- unique(a$gene1)
b <- data.frame(1:length(gene))
for (i in 1:length(gene)) {
  k1 <- a$gene2[a$gene1%in%gene[i]]
  k2 <- a$gene2[a$gene1%in%k1]
  k3 <- a$gene2[a$gene1%in%k2]
  b[i,2] <- length(unique(c(k1,k2,k3)))
}
b[,1] <- gene
colnames(b) <- c('gene','k3')
b <- b[order(b$k3,decreasing = T),]

a <- surv_sig_dgree[[2]]
for (i in 1:nrow(b)) {
  ifelse(b[i,1]%in%a[,1],b$degree[i] <- a[a[,1]==b[i,1],2],b$degree[i] <- 0)
}
b <- b[1:20,]
b <- b[b[,3]!=0,]
# a <- surv_sig_inter[[2]][surv_sig_inter[[2]][,1]==b[1,1],]
# a <- b[b[,1]%in%a[,3],]
# a <- a[order(a[,2],decreasing = T),]
# a <- a[1:10,]
# a <- a[order(a$degree,decreasing = T),]
# a <- a[1:5,1]
a <- b[,1]

#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
library(clusterProfiler)
# a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
#           toType = c('ENTREZID'), #totype指需要转换成的ID类型
#           OrgDb='org.Hs.eg.db')
# a <- enrichGO(a[,2], #数据源
#                                    pvalueCutoff = 1, #P值阈值
#                                    qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
#                                    OrgDb = org.Hs.eg.db, #人类参考基因组
#                                    ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
#                                    readable = TRUE) #是否将基因ID转换为基因名



data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][surv_sig_dgree[[2]][,2]>=16,1]),]))
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%a),]))

for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}

#data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=4)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
annotation_col[annotation_col[,1]==2,1] <- 'IM'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
annotation_col[annotation_col[,1]%in%4,1] <- 'IS'
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IS'],])#4cm*8cm

a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])

a <- t(a)
# a <- log2(t(a)+1)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col,
                   breaks = bk)#5*8

data <- as.matrix(expression[[2]][which(rownames(expression[[2]])%in%unique(surv_sig_inter[[2]][,1])),])
data <- as.matrix(expression[[2]][which(rownames(expression[[2]])%in%gene),])

data <- data[,colnames(a)]
for (i in 1:nrow(data)) {
  data[i,] <- scale(as.numeric(data[i,]))
}
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
pheatmap::pheatmap(data,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col,
                   breaks = bk)#5*8

##接下来对基因进行归类
a <- surv_sig_inter[[2]]
colnames(a) <- c('gene1','value','gene2')
b <- a[,3:1]
colnames(b) <- c('gene1','value','gene2')
a <- rbind(a,b)
gene <- unique(a$gene1)
b <- data.frame(1:length(gene))
for (i in 1:length(gene)) {
  k1 <- a$gene2[a$gene1%in%gene[i]]
  k2 <- a$gene2[a$gene1%in%k1]
  k3 <- a$gene2[a$gene1%in%k2]
  b[i,2] <- length(unique(c(k1,k2,k3)))
}
b[,1] <- gene
colnames(b) <- c('gene','k3')
b <- b[order(b$k3,decreasing = T),]

a <- surv_sig_dgree[[2]]
for (i in 1:nrow(b)) {
  ifelse(b[i,1]%in%a[,1],b$degree[i] <- a[a[,1]==b[i,1],2],b$degree[i] <- 0)
}
b <- b[1:20,]
b <- b[b[,3]!=0,]
# a <- surv_sig_inter[[2]][surv_sig_inter[[2]][,1]==b[1,1],]
# a <- b[b[,1]%in%a[,3],]
# a <- a[order(a[,2],decreasing = T),]
# a <- a[1:10,]
# a <- a[order(a$degree,decreasing = T),]
# a <- a[1:5,1]
a <- b[,1]

#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
library(clusterProfiler)
# a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
#           toType = c('ENTREZID'), #totype指需要转换成的ID类型
#           OrgDb='org.Hs.eg.db')
# a <- enrichGO(a[,2], #数据源
#                                    pvalueCutoff = 1, #P值阈值
#                                    qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
#                                    OrgDb = org.Hs.eg.db, #人类参考基因组
#                                    ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
#                                    readable = TRUE) #是否将基因ID转换为基因名



data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][surv_sig_dgree[[2]][,2]>=16,1]),]))
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%a),]))

for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}

#data <- log2(data+1)
data <- data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],]

dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=4)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
annotation_col[annotation_col[,1]==2,1] <- 'IM'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
annotation_col[annotation_col[,1]%in%4,1] <- 'IS'
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IS'],])#4cm*8cm
data <- t(data[rownames(a),])


a <- data
# a <- log2(t(a)+1)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col,
                   breaks = bk)#5*8

b <- lifetime[[2]]
b <- b[b[,6]%in%colnames(data),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
b[b[,6]%in%rownames(result)[result[,1]%in%c(4,5)],7] <- 'IS'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#E24A0E","blue","#F2CA20"),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

####不考虑亚型，直接进行分析，使用中心节点
####BRCA所有网络的hub
a <- surv_sig_inter[[2]]
colnames(a) <- c('gene1','value','gene2')
b <- a[,3:1]
colnames(b) <- c('gene1','value','gene2')
a <- rbind(a,b)
gene <- unique(a$gene1)
b <- data.frame(1:length(gene))
for (i in 1:length(gene)) {
  k1 <- a$gene2[a$gene1%in%gene[i]]
  k2 <- a$gene2[a$gene1%in%k1]
  k3 <- a$gene2[a$gene1%in%k2]
  b[i,2] <- length(unique(c(k1,k2,k3)))
}
b[,1] <- gene
colnames(b) <- c('gene','k3')
b <- b[order(b$k3,decreasing = T),]

a <- surv_sig_dgree[[2]]
for (i in 1:nrow(b)) {
  ifelse(b[i,1]%in%a[,1],b$degree[i] <- a[a[,1]==b[i,1],2],b$degree[i] <- 0)
}
b <- b[1:10,]
b <- b[b[,3]!=0,]
# a <- surv_sig_inter[[2]][surv_sig_inter[[2]][,1]==b[1,1],]
# a <- b[b[,1]%in%a[,3],]
# a <- a[order(a[,2],decreasing = T),]
# a <- a[1:10,]
# a <- a[order(a$degree,decreasing = T),]
# a <- a[1:5,1]
a <- b[,1]

#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
library(clusterProfiler)
# a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
#           toType = c('ENTREZID'), #totype指需要转换成的ID类型
#           OrgDb='org.Hs.eg.db')
# a <- enrichGO(a[,2], #数据源
#                                    pvalueCutoff = 1, #P值阈值
#                                    qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
#                                    OrgDb = org.Hs.eg.db, #人类参考基因组
#                                    ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
#                                    readable = TRUE) #是否将基因ID转换为基因名



data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][,1]),]))
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%a),]))

for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}

#data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
annotation_col[annotation_col[,1]==2,1] <- 'IM'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
# annotation_col[annotation_col[,1]%in%c(4,5),1] <- 'IS'
data <- as.matrix(t(expression_raw[[2]][which(rownames(expression_raw[[2]])%in%c(b[,1],rownames(expression_raw[[2]])[1:10])),]))

for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}

a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IS'],])#4cm*8cm
a <- t(a)
# a <- log2(t(a)+1)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
# a <- t(data)
pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col,
                   breaks = bk)#5*8

paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),sep = '')
#亚型与不同聚类的生存曲线
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
b[b[,6]%in%rownames(result)[result[,1]%in%c(4,5)],7] <- 'IS'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#E24A0E","blue","#F2CA20"),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##突变分析
BRCA_mut_raw <- read.maf(maf = '/database/TCGA/BRCA/mutation/TCGA_BRCA_mutation.maf',clinicalData = '/database/TCGA/BRCA/mutation/clinical.tsv')
BRCA_mut <- BRCA_mut_raw
brca.pfam <- pfamDomains(maf=BRCA_mut, AACol="HGVSp_Short", top=10)
plotmafSummary(maf=BRCA_mut, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
               titvRaw = FALSE,log_scale = F,showBarcodes = F)
oncoplot(maf=BRCA_mut, top=20, borderCol=NULL)
lollipopPlot(maf=BRCA_mut, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
brca.mutload <- tcgaCompare(maf=BRCA_mut, cohortName="Download_LUAD")

b <- annotation_col
b$sample_id <- rownames(b)
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
IL_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IL',4],]
IM_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IM',4],]
IH_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='IH',4],]
write.table(IL_mut,'result/BRCA/mutation/IL_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(IM_mut,'result/BRCA/mutation/IM_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(IH_mut,'result/BRCA/mutation/IH_mut.maf',sep = '\t',quote = F,row.names = F)
IL_mut <- read.maf(maf ='result/BRCA/mutation/IL_mut.maf')
IM_mut <- read.maf(maf ='result/BRCA/mutation/IM_mut.maf')
IH_mut <- read.maf(maf ='result/BRCA/mutation/IH_mut.maf')

IL_mut_vs_IH_mut <- mafCompare(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
IM_mut_vs_IH_mut <- mafCompare(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
IL_mut_vs_IM_mut <- mafCompare(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL_mut', m2Name = 'IM_mut', minMut = 2, useCNV =FALSE)

r1<-IL_mut_vs_IH_mut$results
r1<-IM_mut_vs_IH_mut$results
r1<-IL_mut_vs_IM_mut$results
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[1:5,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = IL_mut, m2 = IH_mut, m1Name = 'IH_mut', m2Name = 'IH', genes = g1, removeNonMutated = T)
coOncoplot(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM_mut', m2Name = 'IH_mut', genes = g1, removeNonMutated = F)
coOncoplot(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL', m2Name = 'IM', genes = g1, removeNonMutated = F)

BRCA_mut <- BRCA_mut_raw@data
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
a <- as.vector(BRCA_mut[BRCA_mut$Hugo_Symbol=='CDH1','Tumor_Sample_Barcode'])
a <- levels(a$Tumor_Sample_Barcode)

b[b[,1]%in%a,7] <- 'CDH1_mut'

b[b[,7]!='CDH1_mut',7] <- 'CDH1_wt'

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)


################################BRCA第二次正式分析
#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:9,1]),]))
for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}
# data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=2)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
annotation_col[annotation_col[,1]==2,1] <- 'IH'
a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm


a <- t(a)
bk = unique(c(seq(-1,1, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
# a <- t(data)
pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col,
                   breaks = bk)#5*8

paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
#亚型与不同聚类的生存曲线
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IH'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#E24A0E","blue","#F2CA20"),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##亚型生存曲线
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#4498F2","gray","#ED5163","#72FCA0"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm



####查看不同亚型下免疫low与median的区别
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IL']] <- 'IL_LumA'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IM']] <- 'IM_LumA'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IH']] <- 'IH_LumA'
b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_LumA'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_LumA','IM_LumA','IH_LumA'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'

b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_Basal'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_Basal','IM_Basal','IH_Basal'))##对齐坐标轴原点#4cm*5cm

####分析调控基因
a <- surv_sig_inter[[2]]
colnames(a) <- c('gene1','value','gene2')
b <- a[,3:1]
colnames(b) <- c('gene1','value','gene2')
a <- rbind(a,b)
gene <- unique(a$gene1)
b <- data.frame(1:length(gene))
for (i in 1:length(gene)) {
  k1 <- a$gene2[a$gene1%in%gene[i]]
  k2 <- a$gene2[a$gene1%in%k1]
  k3 <- a$gene2[a$gene1%in%k2]
  b[i,2] <- length(unique(c(k1,k2,k3)))
}
b[,1] <- gene
colnames(b) <- c('gene','k3')
b <- b[order(b$k3,decreasing = T),]

a <- surv_sig_dgree[[2]]
for (i in 1:nrow(b)) {
  ifelse(b[i,1]%in%a[,1],b$degree[i] <- a[a[,1]==b[i,1],2],b$degree[i] <- 0)
}
b <- b[1:5,]
b <- b[b[,3]!=0,]
a <- b[,1]

data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(a,surv_sig_dgree[[2]][1:10,1])),]))
for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}

a <- t(data)
a <- cbind(a[,c(rownames(annotation_col)[annotation_col$subtype=='LumA'],
                rownames(annotation_col)[annotation_col$subtype=='LumB'],
                rownames(annotation_col)[annotation_col$subtype=='Her2'],
                rownames(annotation_col)[annotation_col$subtype=='Basal'])])
a <- cbind(a[,colnames(a)%in%rownames(annotation_col)[annotation_col$cluster=='IL']],
           a[,colnames(a)%in%rownames(annotation_col)[annotation_col$cluster=='IH']])
a <- cbind(a[,c(rownames(annotation_col)[annotation_col$cluster=='IL'],
                rownames(annotation_col)[annotation_col$cluster=='IH'])])
# a <- log2(t(a)+1)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IH = "#E24A0E")) 

pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col[,1:2],
                   breaks = bk)#5*8



####分析主要是哪种免疫细胞在起作用
####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 2) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:10,])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:9,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name

bk = unique(c(seq(-1,1, length=200)))
pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                   color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T,
                   treeheight_row = 8,treeheight_col = 8)#8cm*8cm

########分析LumA和Basal种CD8 T和Treg的含量差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)

names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IL_Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('IM_Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('IH_Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IM_LumA','IH_LumA','IL_Basal','IM_Basal','IH_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IM_LumA"),c("IM_LumA","IH_LumA"),c("IL_Basal","IM_Basal"),c("IM_Basal","IH_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2,0.21),
              tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
a

####分析T细胞激活marker
##分析PD1,PDL1的水平LumA和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('IGLC7','IGHV3-43','CD79A','IGAN2','IGAN1','FCGR2A','FCGR3A','GSDME','GSDMD','BCL2L1','CASP3','XIAP','TRAF1','HTRA2','BIRC7','BIRC5','BIRC2','BIRC3','TGIF1','HIF1A','IL10','TNFRSF9','IL21','CD8A','PDCD1','CD274','CTLA4','GZMA','GZMB','PRF1','PRF2'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

# plot <- TMB_plot[,c('Tumor_Sample_Barcode','cluster','GZMA','GZMB','PRF1')]
# plot <- pivot_longer(plot,cols = 3:5,names_to = 'gene',values_to = 'expr')
# plot$cluster <- factor(plot$cluster)
# plot$gene <- factor(plot$gene)
TMB_plot$IGLC7 <- TMB_plot$IGLC7+1
ggplot(TMB_plot, aes(x=cluster, y=`IGLC7`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
a <-ggplot(TMB_plot, aes(x=cluster, y=`IGLC7`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
b <-ggplot(TMB_plot, aes(x=cluster, y=GZMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
c <-ggplot(TMB_plot, aes(x=cluster, y=PRF1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

####LUAD聚类应该正态分布后进行
##从头开始画图
###################################从头开始画图
####读取算到的数据

##extract top1000
for (i in 1:15) {
  surv_sig_inter[[i]] <- read.csv(paste('result/',cancer_name[i],'/inter_probality/surv_sig_inter_new.csv',sep = ''),header = T)
  a <- surv_sig_inter[[i]][order(surv_sig_inter[[i]][,2],decreasing = T)[1000],2]
  surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]>=a,]
}
# surv_sig_inter[[3]] <- read.csv('result/CESC/inter_probality/surv_sig_inter_new.csv')
for (i in 1:15) {
  a <- surv_sig_inter[[i]][,1][!duplicated(surv_sig_inter[[i]][,1])]
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- length(which(surv_sig_inter[[i]][,1]==a[x]))
  }
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
  write.csv(surv_sig_dgree[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_dgree_new.csv',sep = ''),quote = F,row.names = F)
}
########figure1
##
##双柱状图
##获取批量生存分析的每个基因标签
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据

library(survival)
library(survminer)
HR_all <- list()
surv_p_all <- list()
for (x in 10:15) {
  HR_all[[x]] <- data.frame()
  surv_p_all[[x]] <- data.frame()
  b <- lifetime_all[[x]][lifetime_all[[x]][,6] %in% colnames(expression[[x]]),]
  for (j in 1:nrow(expression[[x]])) {
    tryCatch({a <- expression[[x]][j,]
    b[b[,6]%in%colnames(expression[[x]])[which(a <= median(as.numeric(a)))],7] <- 'low'
    b[b[,6]%in%colnames(expression[[x]])[which(a > median(as.numeric(a)))],7] <- 'high'
    c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
    surv_p_all[[x]][j,1] <- 1-pchisq(c$chisq,1)
    HR_all[[x]][j,1] <- (c$obs[2]/c$exp[2])/(c$obs[1]/c$exp[1])},warning = function(w){
      print('warning')}, error = function(e){surv_p_all[[x]][j,1] <- 1
      HR_all[[x]][j,1] <- 1
      print('error')})
  }
  rownames(surv_p_all[[x]]) <- rownames(expression[[x]])
  rownames(HR_all[[x]]) <- rownames(expression[[x]])
}


names(surv_p_all) <- cancer_name
names(HR_all) <- cancer_name
for (i in 1:15) {
  surv_p_all[[i]][is.na(surv_p_all[[i]][,1]),1] <- 1
  surv_p_all[[i]][surv_p_all[[i]][,1]<0.05,2] <- 'sig'
  surv_p_all[[i]][surv_p_all[[i]][,1]>=0.05,2] <- 'non-sig'
}

##画柱状图
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
for (i in 1:15) {
  A <- surv_data[[i]][[1]]
  for (j in 1:ncol(A)) {
    colnames(A)[j] <- as.character(substring(colnames(A)[j],2,nchar(colnames(A)[j])))
  }
  A$group <- surv_p_all[[i]][,2]
  A$Gene <- rownames(A)
  A <- pivot_longer(data = A,cols = 1:(dim(A)[2]-2),
                    names_to = "Type",values_to = "count")
  str_sort(unique(A$Type),numeric = T)
  A$Type <- factor(A$Type, levels = str_sort(unique(A$Type),numeric = T))
  A$Type <- as.factor(A$Type)
  A$Type <- fct_inorder(A$Type)
  A$group <- factor(A$group,levels = c('non-sig','sig'))
  # A$group <- fct_inorder(A$group)
  
  plot <- ggplot(A, aes(fill=group, y=count, x=Type))+
    geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
    theme_classic(base_size = 12)+
    theme(legend.direction = "horizontal", legend.position = "top")+
    labs(title = "", y="Surv-sig rate ", x = "Sample Size")+
    stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
                 width = 0.5,position = position_dodge(1))+
    scale_y_continuous(limits = c(0,1),expand = c(0,0))+
    theme(axis.text.x = element_text(size = 12))+
    theme(axis.text.y = element_text(size = 12))+
    theme(axis.title = element_text(size = 14))
  pdf(paste('result/Figure/AI_plot_new/fig1/V4/s_fig1/',cancer_name[i],'.pdf',sep = ''), width=6, height=5)
  print(plot,newpage = FALSE)
  dev.off()
}

##画折线图
sig_gene_num <- data.frame()
sig_gene_max <- data.frame()
sig_gene_add <- data.frame()
for (i in 1:15) {
  for (j in 1:10) {
    sig_gene_num[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8))
    sig_gene_max[i,j] <- max(surv_data[[i]][[1]][,j])
    ifelse(j==1,sig_gene_add[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8)),
           sig_gene_add[i,j] <- (length(which(surv_data[[i]][[1]][,j]>=0.8))-sig_gene_add[i,j-1]))
  }
}
rownames(sig_gene_num) <- cancer_name
colnames(sig_gene_num) <- c(seq(0.1,1,0.1))
rownames(sig_gene_max) <- cancer_name
colnames(sig_gene_max) <- c(seq(0.1,1,0.1))
rownames(sig_gene_add) <- cancer_name
colnames(sig_gene_add) <- c(seq(0.1,1,0.1))

sig_gene_num$cancer_name <- rownames(sig_gene_num)
sig_gene_num <- pivot_longer(data = sig_gene_num,cols = 1:(dim(sig_gene_num)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_num$cancer_name <- factor(sig_gene_num$cancer_name, levels = str_sort(unique(sig_gene_num$cancer_name),numeric = T))
sig_gene_num$cancer_name <- as.factor(sig_gene_num$cancer_name)

sig_gene_max$cancer_name <- rownames(sig_gene_max)
sig_gene_max <- pivot_longer(data = sig_gene_max,cols = 1:(dim(sig_gene_max)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_max$cancer_name <- factor(sig_gene_max$cancer_name, levels = str_sort(unique(sig_gene_max$cancer_name),numeric = T))
sig_gene_max$cancer_name <- as.factor(sig_gene_max$cancer_name)

sig_gene_add$cancer_name <- rownames(sig_gene_add)
sig_gene_add <- pivot_longer(data = sig_gene_add,cols = 1:(dim(sig_gene_add)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_add$cancer_name <- factor(sig_gene_add$cancer_name, levels = str_sort(unique(sig_gene_add$cancer_name),numeric = T))
sig_gene_add$cancer_name <- as.factor(sig_gene_add$cancer_name)

plot <- ggplot(sig_gene_max, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  theme_base()+
  geom_line(size=1)#size是线的宽度
# ggplot(sig_gene_add, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
#   geom_line(size=1)#size是线的宽度
pdf(paste('result/Figure/AI_plot_new/fig1/V4/fig1C.pdf',sep = ''), width=7, height=5)
print(plot,newpage = FALSE)
dev.off()

#####fig2
####fig2C排版
####富集通路
library(clusterProfiler)
library(stringr)

cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- apply(surv_data[[j]][[1]], 2, max)
  b <- surv_data[[j]][[1]][,which.max(a[a!=0])]
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which.max(a[a!=0])] >= 0.8),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- rownames(surv_data_sig[[i]][[1]])
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}
names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
sig_pathway_plot_all <- surv_sig_pathway
sig_pathway_plot_all@compareClusterResult <- sig_pathway_plot_all@compareClusterResult[sig_pathway_plot_all@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
a <- sig_pathway_plot_all@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(7,8,6,2,15,11,5,3,9,1)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_all
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(7,8,6,2,15,11,5,3,9,1)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(7,8,6,2,15,11,5,3,9,1)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 70)

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]
# write.csv(annotation_col,'result/Figure/AI_plot_new/fig2/v5/pathway_annotation_top10.csv',row.names = F)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v5/pathway_annotation_top10.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='others',3] <- 'black'
y_color[y_color[,2]=='mitotic',3] <- 'red'
y_color[y_color[,2]=='immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
# y_color$color <- factor(y_color$color,levels = c('black','red','blue'))
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))


a <- as.vector(y_color$type)
a <-as.vector(y_color$pathway)[c(which(a=='others'),
                                 which(a=='immune'),
                                 which(a=='mitotic'))]
plot$data$Description <- factor(plot$data$Description,levels = a)

pdf(paste('result/Figure/AI_plot_new/fig2/V4/fig2A.pdf',sep = ''), width=12, height=10)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='others'),
                                                           which(y_color$type=='immune'),
                                                           which(y_color$type=='mitotic'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=c("red","blue","black"))#10cm*12cm
dev.off()


####fig2C
##对网络top10进行富集（dotplot）
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- surv_sig_dgree[[i]][1:10,1]
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}

names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
##提取指定层次的通路进行绘制通路图
sig_pathway_plot_top10 <- surv_sig_pathway
sig_pathway_plot_top10@compareClusterResult <- sig_pathway_plot_top10@compareClusterResult[sig_pathway_plot_top10@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_top10,showCategory=5,includeAll=TRUE,label_format = 70)
a <- sig_pathway_plot_top10@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(2,15,7,8,6)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_top10
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(2,15,7,8,6)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(2,15,7,8,6,11,5,3,9,1)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 35)
write.csv(a@compareClusterResult,'result/Figure/AI_plot_new/fig2/v2/annotation_top10.csv')

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]

# write.csv(annotation_col,'result/Figure/AI_plot_new/fig2/v2/pathway_annotation_top10.csv',row.names = F)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/pathway_annotation_top10.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='others',3] <- 'black'
y_color[y_color[,2]=='mitotic',3] <- 'red'
y_color[y_color[,2]=='immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

a <- as.vector(y_color$type)
a <-as.vector(y_color$pathway)[c(which(a=='others'),
                                 which(a=='mitotic'),
                                 which(a=='immune'))]
plot$data$Description <- factor(plot$data$Description,levels = a)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='others'),
                                                           which(y_color$type=='mitotic'),
                                                           which(y_color$type=='immune'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=y_color$color[!duplicated(y_color$color)])#6cm*8cm

##ggplot2画sankey图
####top10sankey plot

annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/annotation_top10.csv')
b <- annotation_col[,c(1,2,4)]
b <- b[c(which(b$X=='mitotic'),which(b$X=='immune'),which(b$X=='others')),]
b$weight <- 1
library("ggplot2")
library("ggalluvial")
colnames(b) <- c('pathway','cancer_type','pathway_name','weight')
b$cohort <- 1:nrow(b)
b <- pivot_longer(data = b[,c(1,2,5)],cols = 1:2,
                  names_to = "feature",##这一个参数是将列名命名为sample_size
                  values_to = "nodes")##col
b$nodes <- factor(b$nodes,levels = c(unique(b$nodes)[c(3,2,4,6,7,1,5,8)]))
mycol <- c("#F29530","#F29530","#F29530","#4FAAC8","#4FAAC8",'red','#245BAA','#D9D9D9')
plot <- ggplot(b,aes(x = feature, stratum = nodes, alluvium = cohort,
                     fill = nodes, label = nodes)) +
  scale_x_discrete(expand = c(0, 0)) + 
  geom_flow(width = 1/8) + #线跟方块间空隙的宽窄 
  geom_stratum(alpha = 1,width = 2/10) + #方块的透明度、宽度
  geom_text(stat = "stratum", size = 3,color="white") + #文字大小、颜色
  #不喜欢默认的配色方案，用前面自己写的配色方案
  scale_fill_manual(values = mycol) +
  xlab("") + ylab("") +
  theme_bw() + #去除背景色
  theme(panel.grid =element_blank()) + #去除网格线
  theme(panel.border = element_blank()) + #去除外层边框
  theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text = element_blank()) + #去掉坐标轴
  ggtitle("")+
  guides(fill = FALSE) #5cm*7cm

pdf(paste('result/Figure/AI_plot_new/fig2/V4/fig2C.pdf',sep = ''), width=7, height=5)
print(plot,newpage = F)
dev.off()

######fig3ABC
####Depmap分析
##read database
CCLE_cell_line <- read.csv('/database/depmap/突变信息/sample_info.csv')
cell_line_crispr <- read.csv('/database/depmap/CRISPR_(DepMap_21Q4_Public+Score,_Chronos).csv')
RNAi_raw <- read.csv('/database/depmap/RNAi_(Achilles+DRIVE+Marcotte,_DEMETER2).csv')
crispr_raw <- read.csv('/database/depmap/CRISPR_gene_effect_after_process.csv',header = T,row.names = 1)
#从此处接着运行
cell_line <- cell_line_crispr
cell_line <- cell_line[,c('DepMap_ID','stripped_cell_line_name','lineage','lineage_subtype','lineage_sub_subtype','lineage_molecular_subtype')]
crispr <- read.csv('/database/depmap/CRISPR_gene_dependency.csv',header = T,row.names = 1)
a <- colnames(crispr)
a <- str_split(string = a,pattern = '[.][.]',simplify = T)
a[,1] <- gsub(x = a[,1],pattern = '[.]',replacement = '-')
colnames(crispr) <- a[,1]
# RNAi <- RNAi_raw
# rownames(RNAi) <- RNAi[,1]
# RNAi <- RNAi[,-1:-6]

cancer_name_crispr_RNAi <- read.csv('cancer_name_crispr_rnai_CCLE.csv',header = F)
##提取相关crispr数据
sig_gene_expr_plot <- list()
sig_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  tryCatch({
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    for (i in 1:ncol(b)) {
      colnames(b)[i] <- cancer_cell_line[,2][cancer_cell_line[,1] %in% colnames(b)[i]]
    }
    bk = unique(c(seq(0,1, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("white","navy"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    sig_gene_expr_plot[[j]] <- a
    sig_gene_expr_crispr[[j]] <- b
    # save_pheatmap_pdf(a,width=((50/268)*(ncol(b)+8))*1.8, 
    #                   height =((50/268)*(nrow(b)+8))*1.8, 
    #                   paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_crispr.pdf',sep = ''))
  }, error = function(e) {print(j)})
}

#Depmap分析有丝分裂通路中的基因对细胞生存的影响
ref_path_mitotic <- read.csv('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/GO0000278_mitotic_cell_cycle.csv',header = F)
ref_path_mitotic <- as.matrix(ref_path_mitotic[,1])
ref_path_mitotic <- as.vector(ref_path_mitotic)
a <- read.csv('reference/cell_cycle_mitotic.csv',header = T)
a <- as.matrix(a[,1])
a <- as.vector(a)
ref_path_mitotic <- c(ref_path_mitotic,a)
ref_path_mitotic <- ref_path_mitotic[!duplicated(ref_path_mitotic)]

mitotic_gene_expr_plot <- list()
mitotic_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  tryCatch({
    # a <- surv_sig_dgree[[j]][1:10,1][surv_sig_dgree[[j]][1:10,1]%in%ref_path_mitotic]
    a <- surv_sig_dgree[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    for (i in 1:ncol(b)) {
      colnames(b)[i] <- cancer_cell_line[,2][cancer_cell_line[,1] %in% colnames(b)[i]]
    }
    bk = unique(c(seq(0,1, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("white","navy"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    mitotic_gene_expr_plot[[j]] <- a
    mitotic_gene_expr_crispr[[j]] <- b
    names(mitotic_gene_expr_plot)[j] <- cancer_name[j]
    names(mitotic_gene_expr_crispr)[j] <- cancer_name[j]
  }, error = function(e) {print(cancer_name[[j]])})
}

for (i in 6:8) {
  a <- mitotic_gene_expr_crispr[[i]]##LGG
  b <- apply(a, 1, mean)
  a <- a[order(b,decreasing = F),]
  annotation_row <- as.data.frame(rownames(a))
  rownames(annotation_row) <- annotation_row[,1]
  annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
  annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
  colnames(annotation_row) <- 'function'
  d <- factor(annotation_row[,1])
  annotation_row[,1] <- d
  bk = unique(c(seq(0,1, length=100)))
  ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
  a <- pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,main = cancer_name[i],
                          color = c(colorRampPalette(c("white","navy"))(100)),
                          clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                          cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                          annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig3/V4/','fig3',c('A_','B_','C_')[i-5],cancer_name[i],'.pdf',sep = ''), width=5, height=4.1)
  print(a,newpage = F)
  dev.off()
}

#fig3D
####使用显著基因对LUAD进行分类，并与TCGA三种亚型进行分类
subtype <- read.csv('/database/文献/肺癌的分子分型/肺腺癌/luad_subtype.csv')
subtype <- subtype[,c('Tumor.ID','expression_subtype')]
subtype[,2] <- subtype[,2]
subtype[,2][subtype[,2]=='prox.-inflam'] <- 'PI'
subtype[,2][subtype[,2]=='prox.-prolif.'] <- 'PP'
luad_subtype <- lifetime_all[[8]]
colnames(subtype)[1] <- 'case_id'
luad_subtype <- merge(luad_subtype,subtype,by = 'case_id',all=F)

####LUAD层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- luad_subtype
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'ML'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'MH'

##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,8]=='PI',6],],data[rownames(data)%in%b[b[,8]=='PP',6],],data[rownames(data)%in%b[b[,8]=='TRU',6],])
hotmap <- rbind(hotmap[rownames(hotmap)%in%b[b[,7]=='ML',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MM',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MH',6],])
annotation_col <- rbind(b[b[,7]=='ML',7:8],b[b[,7]=='MM',7:8],b[b[,7]=='MH',7:8])
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster','subtype')
rownames(annotation_col) <- c(b[b[,7]=='ML',6],b[b[,7]=='MM',6],b[b[,7]=='MH',6])
ann_colors = list(subtype = c(PI="blue", PP="#F2CA20",TRU="#E24A0E"), #连续数值型分组可设置成渐变  
                  cluster = c(ML="#89C890",MM="#4498F2", MH="#ED5163")) 
# hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
bk = unique(c(seq(-3,3, length=100)))
plot <- pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,
                           show_colnames = F,breaks = bk,treeheight_row = 4,
                           color = c(colorRampPalette(c("navy","white"))(50),colorRampPalette(c("white","red"))(50)),
                           annotation_colors = ann_colors)#4cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig3/V4/fig3D.pdf',sep = ''), width=8, height=4)
print(plot,newpage = F)
dev.off()
##画柱状图看统计情况堆叠柱状图
library(tidyr)
subtype_sum <- data.frame()
for (i in 1:3) {
  subtype_sum[1,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='PI'))
  subtype_sum[2,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='PP'))
  subtype_sum[3,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='TRU'))
}
colnames(subtype_sum) <- c('MM','ML','MH')
rownames(subtype_sum) <- c('PI','PP','TRU')
subtype_sum <- apply(subtype_sum, 2, function(x){x/sum(x)})
subtype_sum <- as.data.frame(subtype_sum)
subtype_sum[1:3,4] <- rownames(subtype_sum)
colnames(subtype_sum)[4] <- 'subtype'
subtype_sum <- pivot_longer(data = subtype_sum,cols = 1:(ncol(subtype_sum)-1),
                            names_to = "cluster",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$subtype <- factor(subtype_sum$subtype)
subtype_sum$cluster <- factor(subtype_sum$cluster,levels = c('ML','MM','MH'))

p <- ggplot(subtype_sum, aes(x=cluster, y=percents,fill=subtype)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack",color="black", width=0.6,size=0.25)+
  scale_fill_manual(values=c("blue","#F2CA20","#E24A0E"))+
  labs(x = "",y = "Percent")+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()#6cm*5cm
p#6cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig3/V4/fig3E.pdf',sep = ''), width=5, height=6)
print(p,newpage = F)
dev.off()
##生存分析分组状况
#聚类分组
library('survival')
library('survminer')
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)
p <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#ED5163", "#4498F2","#89C890"),
                        breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        labels = c("ML","MM","MH"))##对齐坐标轴原点#4cm*5cm

pdf(paste('result/Figure/AI_plot_new/fig3/V4/fig3F.pdf',sep = ''), width=5, height=4)
print(p,newpage = F)
dev.off()

#TCGA分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,8], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,8], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)
p <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#E24A0E","blue","#F4BD0B"),
                        breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
                        labels = c("PI","PP","TRU"))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig3/V4/fig3G.pdf',sep = ''), width=5, height=4)
print(p,newpage = F)
dev.off()

#fig4A
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,1]=='ML',2],],
                data[rownames(data)%in%b[b[,1]=='MM',2],],
                data[rownames(data)%in%b[b[,1]=='MH',2],])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
# hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
bk = unique(c(seq(-3,3, length=100)))
pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                   breaks = bk,annotation_colors = ann_colors,color = c(colorRampPalette(c("navy","white"))(50),
                                                                        colorRampPalette(c("white","red"))(50)))#4cm*8cm

#全样本聚类分组的生存分析情况#supplymental
library('survival')
library('survminer')
b <- lifetime_all[[8]]
b <- b[b$Sample.ID%in%colnames(expression[[8]]),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'ML'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'MH'
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#ED5163", "#4498F2","#89C890"),
                        breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        labels = c("ML","MM","MH"))##对齐坐标轴原点#4cm*5cm

##
##常用函数
library(maftools)
LUAD_mut_raw <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = '/database/TCGA/LUAD/mutation/information/clinical.tsv')
plotmafSummary(maf=LUAD_mut_raw, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
               titvRaw = FALSE,log_scale = F,showBarcodes = F)
oncoplot(maf=LUAD_mut_raw, top=10, borderCol=NULL)
lollipopPlot(maf=LUAD_mut_raw, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
luad.mutload <- tcgaCompare(maf=LUAD_mut_raw, cohortName="Download_LUAD")

####比较ML/MMH的突变情况
LUAD_mut <- LUAD_mut_raw@data
LUAD_mut$Tumor_Sample_Barcode <- substring(text = LUAD_mut$Tumor_Sample_Barcode,first = 1,last = 12)
LUAD_mut$Tumor_Sample_Barcode <- gsub(LUAD_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

b$patient <- substring(text = b$Sample.ID,first = 1,last = 12)
ML_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$File.Name=='ML',8],]
MM_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$File.Name=='MM',8],]
MH_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$File.Name=='MH',8],]
write.table(ML_mut,'result/LUAD/mutation/ML_mut_zscore.maf',sep = '\t',quote = F,row.names = F)
write.table(MM_mut,'result/LUAD/mutation/MM_mut_zscore.maf',sep = '\t',quote = F,row.names = F)
write.table(MH_mut,'result/LUAD/mutation/MH_mut_zscore.maf',sep = '\t',quote = F,row.names = F)
ML_mut <- read.maf(maf ='result/LUAD/mutation/ML_mut_zscore.maf')
MM_mut <- read.maf(maf ='result/LUAD/mutation/MM_mut_zscore.maf')
MH_mut <- read.maf(maf ='result/LUAD/mutation/MH_mut_zscore.maf')
# ML_mut <- read.maf(maf ='result/LUAD/mutation/ML_mut.maf')
# MM_mut <- read.maf(maf ='result/LUAD/mutation/MM_mut.maf')
# MH_mut <- read.maf(maf ='result/LUAD/mutation/MH_mut.maf')


########ML/MMH的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = ML_mut)
TMB[[2]] <- tmb(maf = MM_mut)
TMB[[3]] <- tmb(maf = MH_mut)
names(TMB) <- c('ML_mut','MM_mut','MH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('ML',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('MM',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('MH',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('ML','MM','MH'))

library(ggplot2)
library(ggpubr)
# a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
#   geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
#   geom_jitter(shape=16, position = position_jitter(0.2))+
#   theme_classic()+
#   stat_compare_means(method = "t.test" )#5cm*4cm

a <- ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("ML","MM"),c("ML","MH"),c('MM','MH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(29,31,29),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
a
pdf(paste('result/Figure/AI_plot_new/fig4/V4/fig4A.pdf',sep = ''), width=4, height=5)
print(a,newpage = F)
dev.off()
#fig4B
####对每个病人进行定义,画出每个病人的高频低频突变的堆叠柱状图
##画柱状图看统计情况堆叠柱状图
library(ggplot2)
library(tidyr)
library(tidyverse)
library(ggtree)
library(aplot)
all_mut_table <- data.frame()
for (i in 1:length(sig_mut_list)) {
  all_mut_table[i,1] <- sig_mut_list[i]
  all_mut_table[i,2] <- length(unique(LUAD_mut$Tumor_Sample_Barcode[which(LUAD_mut$Hugo_Symbol==sig_mut_list[i])]))
}
names(all_mut_table) <- c('gene','num')
all_mut_table$percent <- all_mut_table$num/length(unique(LUAD_mut$Tumor_Sample_Barcode))
all_mut_table$type[all_mut_table$percent>=0.05] <- 'high'
all_mut_table$type[all_mut_table$percent<0.05] <- 'low'
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
patient_mut <- data.frame(patient_id)
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  patient_mut[i,2] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='high']])
  patient_mut[i,3] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='low']])
}
colnames(patient_mut) <- c('patient_id','high','low')
a <- patient_id[order(apply(patient_mut[,2:3], 1, sum),decreasing = T)]
a <- c(a[a%in%b$patient[b$File.Name=='ML']],a[a%in%b$patient[b$File.Name=='MM']],a[a%in%b$patient[b$File.Name=='MH']])


#rownames(patient_mut) <- patient_id
patient_mut <- patient_mut[patient_mut$patient_id%in%a,]
rownames(patient_mut) <- patient_mut$patient_id
patient_mut <- patient_mut[a,]
patient_mut$cluster[patient_mut$patient_id%in%b[b$File.Name=='ML',8]] <- 'ML'
patient_mut$cluster[patient_mut$patient_id%in%b[b$File.Name=='MM',8]] <- 'MM'
patient_mut$cluster[patient_mut$patient_id%in%b[b$File.Name=='MH',8]] <- 'MH'
for (i in 1:nrow(patient_mut)) {
  c <- patient_mut[i,2]+patient_mut[i,3]
  patient_mut[i,2] <- patient_mut[i,2]/c
  patient_mut[i,3] <- patient_mut[i,3]/c
}
a <- patient_mut$patient_id[order(patient_mut$high,decreasing = F)]
a <- c(a[a%in%b$patient[b$File.Name=='ML']],a[a%in%b$patient[b$File.Name=='MM']],a[a%in%b$patient[b$File.Name=='MH']])

group <- patient_mut[,c(1,4)]
patient_mut <- pivot_longer(data = patient_mut,cols = 2:3,
                            names_to = "mut_frequency",##这一个参数是将列名命名为sample_size
                            values_to = "mut_frequency_value")##col
patient_mut$cluster <- factor(patient_mut$cluster,levels = c('ML','MM','MH'))
patient_mut$patient_id <- factor(patient_mut$patient_id,levels = a)
patient_mut$mut_frequency <- factor(patient_mut$mut_frequency,levels = c('high','low'))



p <- ggplot(border=0,patient_mut, aes(x=patient_id, y=mut_frequency_value,fill=mut_frequency)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack", width=1,size=0.25)+
  scale_fill_manual(values=c("red","#399938"))+
  labs(x = element_blank(),y = "",title='mutation per patient')+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()+
  theme(axis.ticks.x = element_blank(),axis.text.x = element_blank())#6cm*5cm
#绘制分组色条
group$patient_id <- factor(group$patient_id,levels = a)
group$cluster <- factor(group$cluster,levels = c('ML','MM','MH'))
q <- ggplot(group,aes(patient_id,y=1,fill=cluster))+
  geom_tile()+
  scale_fill_manual(values=c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163"))+
  scale_x_discrete(expand=c(0,0)) +
  scale_y_discrete(expand=c(0,0))+
  labs(x = "patient(n=493)")+
  theme(axis.text = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks = element_blank())
#拼图
plot <- insert_bottom(p,q,height=0.03)
pdf(paste('result/Figure/AI_plot_new/fig4/V4/fig4B.pdf',sep = ''), width=8, height=6)
print(plot,newpage = F)
dev.off()

#6cm*8cm

#fig4CDE
ML_mut_vs_MH_mut <- mafCompare(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
MM_mut_vs_MH_mut <- mafCompare(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
ML_mut_vs_MM_mut <- mafCompare(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = ML_mut_vs_MM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = ML_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = MM_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MM_mut$results
g0<-r1[which(r1$pval<0.001),Hugo_Symbol]
g0<-r1[1:10,Hugo_Symbol]
g1<-r1[1:10,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig4/V4/fig4C_ML_MM.pdf',sep = ''), width=12, height=3)
coOncoplot(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', genes = g, removeNonMutated = T)
dev.off()
r1<-MM_mut_vs_MH_mut$results
g0<-r1[which(r1$pval<0.001),Hugo_Symbol]
g0<-r1[1:10,Hugo_Symbol]
g1<-r1[1:10,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig4/V4/fig4C_MM_MH.pdf',sep = ''), width=12, height=3)
coOncoplot(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', genes = g, removeNonMutated = T)
dev.off()
r1<-ML_mut_vs_MH_mut$results
g0<-r1[which(r1$pval<0.001),Hugo_Symbol]
g0<-r1[1:10,Hugo_Symbol]
g1<-r1[1:10,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig4/V4/fig4C_ML_MH.pdf',sep = ''), width=12, height=3)
coOncoplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', genes = g, removeNonMutated = T)
dev.off()

coBarplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut')

#fig4F
####读取细胞系突变
library(stringr)
CCLE_mut <- read.csv('/database/depmap/突变信息/CCLE_mutations.csv')
CCLE_cell_line <- read.csv('/database/depmap/突变信息/sample_info.csv')
luad_cell_line <- CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1:3]
luad_cell_line_mut <- CCLE_mut[CCLE_mut$DepMap_ID%in%luad_cell_line$DepMap_ID,]

luad_cell_line_expr <- crispr

##对所有突变进行筛选(全细胞系)
#all_mut
all_mut_ddc <- data.frame()
sig_mut_list <- unique(LUAD_mut$Hugo_Symbol)
all_mut_table <- data.frame()
for (i in 1:length(sig_mut_list)) {
  all_mut_table[i,1] <- sig_mut_list[i]
  all_mut_table[i,2] <- length(unique(LUAD_mut$Tumor_Sample_Barcode[which(LUAD_mut$Hugo_Symbol==sig_mut_list[i])]))
}
names(all_mut_table) <- c('gene','num')
all_mut_table$percent <- all_mut_table$num/length(unique(LUAD_mut$Tumor_Sample_Barcode))
all_mut_table$type[all_mut_table$percent>=0.05] <- 'high'
all_mut_table$type[all_mut_table$percent<0.05] <- 'low'


for (i in 2377:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  all_mut_ddc[i,1] <- A
  a <- unique(CCLE_mut$DepMap_ID[CCLE_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  all_mut_ddc[i,2] <- e$estimate[1]
  all_mut_ddc[i,3] <- e$estimate[2]
  all_mut_ddc[i,4] <- e$p.value
  all_mut_ddc[i,5] <- all_mut_ddc[i,2]-all_mut_ddc[i,3]
  all_mut_ddc[i,6] <- length(c)
  all_mut_ddc[i,7] <- length(d)
}, error = function(e) {print(i)})
}
A='KRAS'
colnames(all_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value','diff_ddc','mut_num','wt_num')
all_mut_ddc$p_adj <- p.adjust(all_mut_ddc$p_value)
all_mut_ddc$ddc_rate <- 2*all_mut_ddc$diff_ddc/(all_mut_ddc$mut_cell_line+all_mut_ddc$wt_cell_line)
effect_mut <- all_mut_ddc[!is.na(all_mut_ddc$p_value)&all_mut_ddc$p_value<0.05&abs(all_mut_ddc$diff_ddc)>0.01&abs(all_mut_ddc$ddc_rate)>0.10,]

####火山图展示有效突变基因
library(ggpubr)
library(ggplot2)
library(ggthemes)
library(ggrepel)
mut_gene_plot <- all_mut_ddc[!is.na(all_mut_ddc$p_value),]
mut_gene_plot$'-lg(pvalue)' <- -1*log10(mut_gene_plot$p_value)
mut_gene_plot$label <- NA
mut_gene_plot$label[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05]
mut_gene_plot$label[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05]
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&mut_gene_plot$Gene%in%all_mut_table[all_mut_table$type=='high',1]] <- 'effective_high'
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&mut_gene_plot$Gene%in%all_mut_table[all_mut_table$type=='low',1]] <- 'effective_low'
mut_gene_plot$group[!(abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05)] <- 'invalid'

mut_gene_plot <- mut_gene_plot[order(mut_gene_plot$`-lg(pvalue)`),]#对差异表达基因调整后的p值进行排序
mut_gene_plot$`-lg(pvalue)`[mut_gene_plot$`-lg(pvalue)`>25] <- 25

#添加特定基因label
p <- ggscatter(mut_gene_plot,x = "ddc_rate",y = 'p_value',color = "group",
               palette = c('red','#399938','gray'),
               repel = T, ylab = 'p_value', size = 1) + 
  theme_base()+
  theme(element_line(size = 0),element_rect(size = 1.5))+ #坐标轴线条大小设置
  scale_y_continuous(limits = c(0,26))+
  scale_x_continuous(limits = c(-2,2))+
  geom_point(aes(size=abs(diff_ddc),color=group))+
  geom_text_repel(data = mut_gene_plot,parse = F,
                  color="black",min.segment.length = 0,force = 1,max.iter = 3e3,
                  aes(label = label),
                  size = 4,segment.size=1,segment.colour='black')+
  geom_hline(yintercept = -log10(0.05),linetype = "dashed")+
  geom_vline(xintercept = c(-0.1,0.1),linetype = "dashed")#7cm*6cm

pdf(paste('result/Figure/AI_plot_new/fig4/V4/fig4F.pdf',sep = ''), width=6, height=7)
print(p,newpage = F)
dev.off()


#fig4G
#################替换为伯努利检验（二项检验）
####Nest定义每个病人
library(stats)
nest_pathway <- read.csv('/database/IAS/NeST Map - Main Model default node.csv')
nest_pathway_list <- list()
for (i in 1:nrow(nest_pathway)) {
  a <- nest_pathway[i,4]
  nest_pathway_list[[i]] <- str_split(a,' ',simplify = F)[[1]]
}
names(nest_pathway_list) <- nest_pathway$Annotation

path_num_cal <- function(x){
  x=nest_pathway_list[[x]]
  length(which(a%in%x))
}
patient_pathway <- list()
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  a <- a[a%in%ref_all_mut_ddc$Gene]
  b <- as.data.frame(names(nest_pathway_list))
  b[,2] <- apply(b, 1, path_num_cal)
  colnames(b) <- c('pathway_name','map_mut_num')
  patient_pathway[[i]] <- b
}
names(patient_pathway) <- patient_id

patient_pathway_table <- data.frame(names(nest_pathway_list))
rownames(patient_pathway_table) <- patient_pathway_table[,1]
for (i in 1:length(patient_pathway)) {
  patient_pathway_table[,i] <- patient_pathway[[i]][,2]
  patient_pathway_table[patient_pathway_table[,i]>0,i] <- 1
  patient_pathway_table[patient_pathway_table[,i]==0,i] <- 0
}
colnames(patient_pathway_table) <- names(patient_pathway)

patient_pathway_table <- patient_pathway_table[apply(patient_pathway_table, 1, sum)>0,]

result
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
##画热图比较这两组样本的基因
hotmap <- cbind(patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='ML',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MM',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
##画瀑布图
diff_pathway_list <- data.frame(rownames(hotmap))
for (i in 1:nrow(diff_pathway_list)) {
  c <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='ML',3]])
  d <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='MM',3]])
  e <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='MH',3]])
  diff_pathway_list[i,2] <- sum(c)
  diff_pathway_list[i,3] <- sum(d)
  diff_pathway_list[i,4] <- sum(e)
  diff_pathway_list[i,5] <- binom.test(x = sum(d),n = length(d),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value
  diff_pathway_list[i,6] <- binom.test(x = sum(e),n = length(e),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value
  diff_pathway_list[i,7] <- binom.test(x = sum(e),n = length(e),p = sum(d)/length(d),alternative = "two.sided",conf.level = 0.95)$p.value
}

binom.test(x = sum(d),n = length(d),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value

colnames(diff_pathway_list) <- c('pathway','ML','MM','MH','ML_MM','ML_MH','MM_MH')
c <- apply(hotmap, 1, sum)
c <- cbind(rownames(hotmap),c)
c <- as.data.frame(c)
colnames(c) <- c('nest','num')
c <- c[order(as.numeric(c[,2]),decreasing = F),]
for (i in 1:nrow(c)) {
  a <- as.data.frame(hotmap[i,])
  hotmap <- cbind(hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==1]],
                  hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==0]])
}
hotmap <- hotmap[rownames(c)[nrow(c):1],]
a <- pheatmap::pheatmap(hotmap,cluster_col = T,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- as.data.frame(cutree(a$tree_col,k=2))
hotmap <- cbind(hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==1]],
                hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==2]])

hotmap <- cbind(hotmap[,colnames(hotmap)%in%b[b[,1]=='ML',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MM',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MH',3]])
hotmap <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[!(diff_pathway_list$ML_MM>0.05&diff_pathway_list$ML_MH>0.05&diff_pathway_list$MM_MH>0.05)],]


a <- pheatmap::pheatmap(hotmap,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$ML_MM<0.05],]
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$MM_MH<0.05],]
a <- pheatmap::pheatmap(a,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm



diff_pathway_list$ML_specific[(diff_pathway_list$ML/179)>(diff_pathway_list$MM/258)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$ML/179)>(diff_pathway_list$MH/67)&diff_pathway_list$ML_MH<0.05] <- 1
diff_pathway_list$MM_specific[(diff_pathway_list$MM/258)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MM<0.05] <- 1
diff_pathway_list$MH_specific[(diff_pathway_list$MH/67)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MH<0.05&
                                (diff_pathway_list$MH/67)>(diff_pathway_list$MM/258)&diff_pathway_list$MM_MH<0.05] <- 1
write.csv(diff_pathway_list,'result/Figure/AI_plot_new/fig4/v2/样本差异突变通路_NEW.csv',row.names = F)
####验证结果
a <- patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]]
colnames(a)[a["Proximal RTK signaling",]==1]

##画差异通路气泡图
b <- result
b[b[,1]=='1',1] <- 'MM'
b[b[,1]=='2',1] <- 'ML'
b[b[,1]=='3',1] <- 'MH'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
diff_pathway_plot <- diff_pathway_list
diff_pathway_plot$ML <- diff_pathway_plot$ML/sum(b$result=='ML')
diff_pathway_plot$MM <- diff_pathway_plot$MM/sum(b$result=='MM')
diff_pathway_plot$MH <- diff_pathway_plot$MH/sum(b$result=='MH')
diff_pathway_plot$ML_MM_log2FC <- log2(diff_pathway_plot$ML/diff_pathway_plot$MM)
diff_pathway_plot$ML_MH_log2FC <- log2(diff_pathway_plot$ML/diff_pathway_plot$MH)
diff_pathway_plot$MM_MH_log2FC <- log2(diff_pathway_plot$MM/diff_pathway_plot$MH)

diff_pathway_plot$ML_MH[is.nan(diff_pathway_plot$ML_MH)] <- 1
diff_pathway_plot$MM_MH[is.nan(diff_pathway_plot$MM_MH)] <- 1
diff_pathway_plot$ML_MM_log2FC[diff_pathway_plot$ML_MM_log2FC==Inf] <- 4
diff_pathway_plot$ML_MM_log2FC[diff_pathway_plot$ML_MM_log2FC==-Inf] <- -4
diff_pathway_plot$ML_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==Inf] <- 4
diff_pathway_plot$ML_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==-Inf] <- -4
diff_pathway_plot$MM_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==Inf] <- 4
diff_pathway_plot$MM_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==-Inf] <- -4


diff_pathway_plot <- diff_pathway_plot[!(diff_pathway_plot$ML_MM>0.05&
                                           diff_pathway_plot$ML_MH>0.05&
                                           diff_pathway_plot$MM_MH>0.05),]
diff_pathway_plot <- diff_pathway_plot[!(abs(diff_pathway_plot$ML_MM_log2FC)<1&
                                           abs(diff_pathway_plot$ML_MH_log2FC)<1&
                                           abs(diff_pathway_plot$MM_MH_log2FC)<1),]
colnames(diff_pathway_plot)[1] <- 'Annotation'
diff_pathway_plot <- merge(diff_pathway_plot,nest_pathway[,c('Annotation','Size')],all=F,by='Annotation')
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Size<50&
                                         diff_pathway_plot$ML>0.05|
                                         diff_pathway_plot$MM>0.05|
                                         diff_pathway_plot$MH>0.05,]

a <- c(diff_pathway_plot[order(diff_pathway_plot$ML_MM,decreasing = F)[1:10],1],
       diff_pathway_plot[order(diff_pathway_plot$ML_MH,decreasing = F)[1:10],1],
       diff_pathway_plot[order(diff_pathway_plot$MM_MH,decreasing = F)[1:10],1])
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Annotation%in%a,]

a <- pivot_longer(diff_pathway_plot[,c('Annotation','ML_MM','ML_MH','MM_MH')],cols = 2:4,
                  names_to = 'compare_object',values_to = 'p_value')
b <- pivot_longer(diff_pathway_plot[,c('Annotation','ML_MM_log2FC','ML_MH_log2FC','MM_MH_log2FC')],cols = 2:4,
                  names_to = 'compare_object',values_to = 'log2FC')
diff_pathway_plot <- cbind(a,b[,3]) 
diff_pathway_plot$p_value <- round(as.numeric(diff_pathway_plot$p_value),4)
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$p_value<0.05,]
diff_pathway_plot$compare_object <- factor(diff_pathway_plot$compare_object,
                                           levels = c('ML_MM','MM_MH','ML_MH'))
a <- as.data.frame(unique(diff_pathway_plot$Annotation))
# write.csv(a,'result/Figure/AI_plot_new/fig4/V4/annotation_v4.csv')
a <- read.csv('result/Figure/AI_plot_new/fig4/v4/annotation_v4.csv',row.names = 1)
a <- a[c(which(a$function.=='other process'),
         which(a$function.=='signaling process'),
         which(a$function.=='cell cycle')),]

diff_pathway_plot$Annotation <- factor(diff_pathway_plot$Annotation,levels = a$pathway)

y_color <- as.data.frame(a)
colnames(y_color)[2] <- 'fuction'
y_color[y_color[,2]=='other process',3] <- 'black'
y_color[y_color[,2]=='cell cycle',3] <- 'red'
y_color[y_color[,2]=='signaling process',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$type <- factor(y_color$type,levels = c('cell cycle','signaling process','other process'))
y_color$xmin <- -Inf
y_color$xmax <- Inf
y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

plot <- ggplot(diff_pathway_plot,aes(x=compare_object,y=Annotation))+
  geom_point(aes(size=abs(`log2FC`),color=`p_value`))+
  scale_color_gradient(high="#1E08F7",low="#F20808")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=0,hjust = 0.5,vjust=0.5),
        axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='other process'),
                                                           which(y_color$type=='signaling process'),
                                                           which(y_color$type=='cell cycle'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=c('red','blue','black'))+
  labs(x=NULL,y=NULL,title = 'the pathway of different cluster')#6cm*7cm

pdf(paste('result/Figure/AI_plot_new/fig4/V4/fig4G.pdf',sep = ''), width=7, height=6)
print(plot)
dev.off()

####先不关心突变，直接筛选药效好的药物，然后看这些药物的通路是否与周期蛋白和PIK3CA相关
####drug effection significance
####药物筛选
###fig5A
A549_drug_gdsc1 <- read.csv('result/Figure/table3_from_GDSC1_A549.csv')
A549_drug_gdsc1[,6] <- 'GDSC1'
A549_drug_gdsc1[,7] <- rownames(A549_drug_gdsc1)
A549_drug_gdsc2 <- read.csv('result/Figure/table3_from_GDSC2_A549.csv')
A549_drug_gdsc2[,6] <- 'GDSC2'
A549_drug_gdsc2[,7] <- rownames(A549_drug_gdsc2)
a <- rbind(A549_drug_gdsc1[,c(7,4,6)],A549_drug_gdsc2[,c(7,4,6)])
colnames(a) <- c('num','Z_score','version')
a[,1] <- as.numeric(a[,1])

plot <- ggplot(a, aes(x=num, y=Z_score,color=version)) + 
  ggtitle("GDSC_drug_screen")+
  geom_point(size=0.8,stroke =1)+
  theme_bw()+
  geom_hline(yintercept = c(-2,2),linetype = "dashed")+
  annotate('text',x=150,y=2.2,label=expression('resistant'),size=4,color='red')+
  annotate('text',x=50,y=-2.2,label=expression('sensitive'),size=4,color='blue')##画散点图5cm*8cm

pdf(paste('result/Figure/AI_plot_new/fig5/V4/fig5A.pdf',sep = ''), width=8, height=5)
print(plot,newpage = F)
dev.off()
#fig5B
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA

##画韦恩图
library(VennDiagram)
venn.plot <- venn.diagram(x = list(cMAP_A549=All_drug,GDSC_A549=gdsc_A549_drug),
                          category.names = c('cMAP_A549','GDSC_A549'),
                          filename = NULL,
                          scaled = F,
                          height = 1500, width = 1500, resolution =600,
                          alpha=c(0.6, 0.6),
                          fill=c(colors()[616], colors()[38]), 
                          lwd=rep(1,2), cex=0.45, 
                          fontfamily = "serif", fontface = "bold",
                          cat.dist=c(-0.07, -0.07),
                          output=TRUE,
                          area.vector = 0,
                          cat.pos=c(280, 80), #位置
                          cat.cex=0.45)##画韦恩图

pdf(paste('result/Figure/AI_plot_new/fig5/V4/fig5B.pdf',sep = ''), width=2, height=2)
grid.draw(venn.plot)
dev.off()


#fig5c
##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
pheatmap::pheatmap(luad_overlap[,2:10],clustering_method = 'ward.D2')
bk = unique(c(seq(-4,4, length=200)))
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:10]),breaks = bk,show_rownames = T,treeheight_row = 0,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = F,cluster_rows = T,cluster_cols = T)
cluster <- hotmap$tree_col
plot(cluster,hang = -1,cex=0.6,axes=FALSE,ann=FALSE)
cut <- as.data.frame(cutree(cluster,2))
annotation_row <- cut
colnames(annotation_row) <- 'cluster'
annotation_row[annotation_row[,1]==1,1] <- 'mitotic_inhibit'
annotation_row[annotation_row[,1]==2,1] <- 'mitotic_activate'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
ann_colors = list(cluster = c(con="#ED5163", mitotic_i="#4498F2")) 
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:10]),breaks = bk,show_rownames = T,treeheight_row = 0,annotation_col = annotation_row,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = F,cluster_rows = T,cluster_cols = T,
                             annotation_colors = ann_colors,treeheight_col = 3)#6cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig5/V4/fig5C.pdf',sep = ''), width=8, height=6)
grid.draw(hotmap)
dev.off()


#fig5D
drug_effection <- list()
drug_effection[[1]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==1],]
drug_effection[[2]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==2],]
names(drug_effection) <- c('mitotic_inhibit','mitotic_activate')
for (i in 1:2) {
  a <- aggregate(drug_effection[[i]]$V11,by=list(drug_effection[[i]][,1]),FUN=mean)
  drug_effection[[i]] <- a
}
for (i in 1:2) {
  drug_effection[[i]] <- cbind(drug_effection[[i]],rep(c('mitotic_inhibit','mitotic_activate')[i],nrow(drug_effection[[i]])))
  colnames(drug_effection[[i]]) <- c('drug_name','IC50-Z_SCORE','cluster')
}
#drug_effection[[1]] <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
a <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
b <- drug_effection[[2]][!drug_effection[[2]]$drug_name%in%drug_effection[[1]]$drug_name,]
drug_effection_plot <- rbind(a,b)

#drug_effection_plot <- rbind(drug_effection[[1]],
#                            drug_effection[[2]])
drug_effection_plot$cluster <- as.factor(drug_effection_plot$cluster)
# colnames(drug_effection_plot)[2] <- 'IC50-Z_SCORE'

library(ggplot2)
library(ggpubr)

p <- ggplot(drug_effection_plot, aes(x=cluster, y=`IC50-Z_SCORE`,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("mitotic_inhibit","mitotic_activate")), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.1),
              tip_length = c(0.02))#5cm*4cm

pdf(paste('result/Figure/AI_plot_new/fig5/V4/fig5D.pdf',sep = ''), width=4, height=5)
print(p,newpage = F)
dev.off()


#fig5E
drug_info <- read.csv('/database/GDSC/drug_IC50/screened_compunds_rel_8.2.csv')
drug_info$name <- tolower(drug_info$DRUG_NAME)
effect_drug_info <- drug_info[drug_info$name%in%drug_effection_plot$drug_name[drug_effection_plot$cluster=='mitotic_inhibit'],]
##查看是否有相应的细胞系数据
#获取PIK3CA，KRAS突变细胞系名称
library(maftools)
# CCLE_cell_mut <- read.csv('/database/depmap/突变信息/CCLE_mutations.csv')
LUAD_cell_mut <- CCLE_cell_mut[CCLE_cell_mut$DepMap_ID%in%CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1],]
LUAD_cell_mut_sig <- data.frame(1:76)
LUAD_cell_mut_sig <- as.data.frame(t(LUAD_cell_mut_sig))
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='KRAS'])
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='PIK3CA'&
                                                      LUAD_cell_mut$DepMap_ID%in%P_K_mut_cell_line])
CCLE_cell_line$stripped_cell_line_name[CCLE_cell_line$DepMap_ID%in%P_K_mut_cell_line]

gdsc_SW1573 <- gdsc[gdsc$CELL_LINE_NAME=='SW1573',]
gdsc_SW1573 <- gdsc_SW1573[gdsc_SW1573$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_SW1573 <- gdsc_SW1573[gdsc_SW1573$DATASET=='GDSC2',]
gdsc_A549 <- gdsc[gdsc$CELL_LINE_NAME=='A549',]
gdsc_A549 <- gdsc_A549[gdsc_A549$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_A549 <- gdsc_A549[gdsc_A549$DATASET=='GDSC2',]

c <- gdsc_A549[-8,c(5,9,19)]
d <- gdsc_SW1573[-8,c(5,9,19)]
t.test(c[,3], d[,3], paired = TRUE)
a <- rbind(c,d)
p <- ggplot(a, aes(x=CELL_LINE_NAME, y=Z_SCORE,fill=CELL_LINE_NAME)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  stat_compare_means(method = "t.test",paired = T )+
  geom_signif(comparisons = list(c("A549","SW1573")), 
              map_signif_level = TRUE, test = t.test, y_position = c(2.5),
              tip_length = c(0.02))#5cm*4cm

pdf(paste('result/Figure/AI_plot_new/fig5/V4/fig5E.pdf',sep = ''), width=4, height=5)
print(p,newpage = F)
dev.off()
####然后查询文献或临床试验中PI3K抑制剂与其他药物联用的效果
####联合用药预测(这部分可能还是得实验)
drug_combine_raw <- read.csv('/database/DrugComb/summary_v_1_5.csv')
drug_combine <- drug_combine_raw
drug_combine$drug_row <- tolower(drug_combine$drug_row)
drug_combine$drug_col <- tolower(drug_combine$drug_col)
drug_combine <- drug_combine[c(which(drug_combine$drug_row%in%effect_drug_info$name),
                               which(drug_combine$drug_col%in%effect_drug_info$name)),]


####BUB1B的解释
#BUB1B的基因依赖性
luad_cell_line_expr[a[a%in%rownames(luad_cell_line_expr)],'BUB1B']
luad_cell_line_expr['ACH-002157','BUB1B']

a <- CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1]
a <- CCLE_mut[CCLE_mut$DepMap_ID%in%a,]

#计算在药物作用下与BUB1B相关性最强的基因群
luad <- cell_line_expr_drug[[8]][[7]]
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA

##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
# write.csv(luad_overlap,'result/A549_effect_drug_list.csv')
pheatmap::pheatmap(luad_overlap[,2:10],clustering_method = 'ward.D2')
bk = unique(c(seq(-4,4, length=200)))
hotmap <- pheatmap::pheatmap(luad_overlap[,2:10],breaks = bk,show_rownames = F,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = T,cluster_rows = T,cluster_cols = T)
cluster <- hotmap$tree_row
plot(cluster,hang = -1,cex=0.6,axes=FALSE,ann=FALSE)
cut <- as.data.frame(cutree(cluster,2))
drug_inhibit_gene <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==1],]
for (i in 1:nrow(drug_inhibit_gene)) {
  drug_inhibit_gene[i,11] <- min(drug_inhibit_gene[i,11:13][!is.na(drug_inhibit_gene[i,11:13])])
}
colnames(drug_inhibit_gene)[c(1,11)] <- c('drug_name','IC50_Z-score')
# write.csv(drug_inhibit_gene[,1:10],'result/Figure/table1_effect_drug_gene_res.csv',row.names = T)
drug_inhibit_gene_name <- drug_inhibit_gene[!duplicated(drug_inhibit_gene[,1]),c(1,11)]
# write.csv(drug_inhibit_gene_name,'result/Figure/table2_effect_drug_name.csv',row.names = F)
pheatmap::pheatmap(rcorr(as.matrix(drug_inhibit_gene[,2:10]))[[1]])##画相关性图

#fig5F
####BUB1B相关性变化的气泡图
library(Hmisc)
library(ggplot2)
BUB1B_drug_spearman <- rcorr(as.matrix(drug_inhibit_gene[,2:10]))
a <- expression[[8]]
a <- t(a[rownames(a)%in%colnames(drug_inhibit_gene[,2:10]),])
BUB1B_tcga_spearman <- rcorr(a,type = 'spearman')
a <- cbind(rownames(BUB1B_tcga_spearman[[1]]),BUB1B_tcga_spearman[[1]][,'BUB1B'],BUB1B_tcga_spearman[[3]][,'BUB1B'],rep('TCGA',nrow(BUB1B_tcga_spearman[[1]])))
b <- cbind(rownames(BUB1B_drug_spearman[[1]]),BUB1B_drug_spearman[[1]][,'BUB1B'],BUB1B_drug_spearman[[3]][,'BUB1B'],rep('cMap',nrow(BUB1B_drug_spearman[[1]])))
BUB1B_spearman_plot <- rbind(a,b)
colnames(BUB1B_spearman_plot) <- c('gene','spearman','p_value','data_source')
BUB1B_spearman_plot <- as.data.frame(BUB1B_spearman_plot[BUB1B_spearman_plot[,1]!="BUB1B",])
BUB1B_spearman_plot$p_value <- -1*log10(as.numeric(BUB1B_spearman_plot$p_value)+0.0001)
BUB1B_spearman_plot$spearman <- round(as.numeric(BUB1B_spearman_plot$spearman),2)

ggplot(BUB1B_spearman_plot,aes(x=gene,y=data_source))+
  geom_point()
plot <- ggplot(BUB1B_spearman_plot,aes(x=gene,y=data_source))+
  geom_point(aes(size=`p_value`,color=`spearman`))+
  scale_color_gradient(high="#F20808",low="#1E08F7")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=90,hjust = 1,vjust=0.5))+
  labs(x=NULL,y=NULL,title = 'the correlation of BUB1B in different situations')#3.54cm*4.34cm

pdf(paste('result/Figure/AI_plot_new/fig5/V4/fig5F.pdf',sep = ''), width=6, height=3)
print(plot,newpage = F)
dev.off()
# ggsave(plot = plot,filename = paste('result/Figure/AI_plot_new/fig5/V4/fig5F.pdf',sep = ''),width = 5,height = 2.5)
# 


#fig5G
####读取A549细胞系有效药物的基因表达数据
A549_drug_gene_res <- read.csv('/database/cMAP/A549_cell_drug_expr_data.csv')
library(clusterProfiler)
a <- bitr(A549_drug_gene_res[,1],fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
          toType = c('SYMBOL'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
colnames(A549_drug_gene_res)[1] <- 'ENTREZID'
A549_drug_gene_res <- merge(a,A549_drug_gene_res,by='ENTREZID',all=F)
rownames(A549_drug_gene_res) <- A549_drug_gene_res[,2]
A549_drug_gene_res <- A549_drug_gene_res[,-1:-2]

cor_p_value <- function(x){cor.test(BUB1B_expr,as.numeric(x),method = 'spearman')$p.value}
cor_estimate <- function(x){cor.test(BUB1B_expr,as.numeric(x),method = 'spearman')$estimate}

BUB1B_expr <- as.numeric(A549_drug_gene_res['BUB1B',])
BUB1B_cor <- data.frame(rownames(A549_drug_gene_res))
BUB1B_cor$drug_cor <- apply(A549_drug_gene_res,1,cor_estimate)
BUB1B_cor$drug_p_value <- apply(A549_drug_gene_res,1,cor_p_value)
BUB1B_cor$drug_p_adj <- p.adjust(BUB1B_cor$drug_p_value)

LUAD_TCGA_expr <- expr_data_raw[[8]]
LUAD_TCGA_expr <- LUAD_TCGA_expr[rownames(LUAD_TCGA_expr)%in%rownames(A549_drug_gene_res),]
LUAD_TCGA_expr <- LUAD_TCGA_expr[rownames(A549_drug_gene_res),]
rownames(LUAD_TCGA_expr) <- rownames(A549_drug_gene_res)
LUAD_TCGA_expr <- as.matrix(LUAD_TCGA_expr)
LUAD_TCGA_expr[is.na(LUAD_TCGA_expr)] <- 0
BUB1B_expr <- as.numeric(LUAD_TCGA_expr['BUB1B',])


BUB1B_cor$TCGA_cor <- apply(LUAD_TCGA_expr,1,cor_estimate)
BUB1B_cor$TCGA_p_value <- apply(LUAD_TCGA_expr,1,cor_p_value)
BUB1B_cor$TCGA_p_adj <- p.adjust(BUB1B_cor$TCGA_p_value)

a <- BUB1B_cor[BUB1B_cor$drug_cor>0.5&BUB1B_cor$TCGA_cor>0.5,1]
a <- bitr(a,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
#可以看到，在正常状态下与药物作用下与BUB1B都高度相关的基因（>0.5），它富集到的普遍是DNA复制检查点和G2/M检查点，以此可以解释为什么BUB1B在药物作用下会升高
p <- barplot(a,label_format = 60)
pdf(paste('result/Figure/AI_plot_new/fig5/V4/fig5G.pdf',sep = ''), width=8, height=3)
print(p,newpage = F)
dev.off()
#fig6
####FIG6的修改
####LUAD的模型构建与验证
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据
lifetime <- list()
for (i in 1:15) {
  lifetime[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/',cancer_name[i],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[[i]][,6] <- gsub('-','.',lifetime[[i]][,6])
  expression_raw[[i]] <- expression_raw[[i]][,which(colnames(expression_raw[[i]]) %in% lifetime[[i]][,6])]
  lifetime[[i]] <- lifetime[[i]][which(lifetime[[i]][,6] %in% colnames(expression_raw[[i]])),]
  lifetime[[i]] <- lifetime[[i]][which(!duplicated(lifetime[[i]][,6])),]
  lifetime[[i]]$Sample.ID <- factor(lifetime[[i]]$Sample.ID, levels = colnames(expression_raw[[i]]))
  lifetime[[i]] <- lifetime[[i]][order(lifetime[[i]]$Sample.ID),]
  lifetime[[i]][which(lifetime[[i]][,2]=='Alive'),2] <- 0
  lifetime[[i]][which(lifetime[[i]][,2]=='Dead'),2] <- 1
}
names(lifetime) <- cancer_name
library('DESeq2')
library('survival')
library('survminer')
library('dplyr')
library('glmnet')
library('ggplot2')
library('GGally')
library('rms')
library('survivalROC')
library('plotROC')
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in 1:ncol(risk_score_table)){
    risk_score_table[,each_sig_gene] <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[colnames(risk_score_table)[each_sig_gene],1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
##对5年生存的预测
for (j in 8) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    #formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    #correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)#5cm*9cm
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      #scale_color_gradient(high="#F20808",low="#1E08F7")+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                           conf.int = F,    # 显示置信区间
                                           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                           add.all = F,     # 添加总患者生存曲线
                                           palette = "hue",    # 自定义调色板
                                           surv.median.line = "hv",     # 添加中位生存时间线
                                           risk.table = F,             # 添加风险表
                                           xlab = "Follow up time(d)", # 指定x轴标签
                                           legend = c(0.8,0.9),         # 指定图例位置
                                           title = c('LUAD_predict'),                 # 设置图例标题
                                           #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                           break.x.by = 365,# 设置x轴刻度间距
                                           pval.method=T)
    predict_effect[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点 #4cm*5cm
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证
ver_expr_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/tumor_CPTAC_LUAD_immune.csv',row.names = 1)
for (j in 8) {
  ##计算基因模型风险评分
  tryCatch({
    predict_effect_ver[[j]] <- list()
    gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
    expr_data <- ver_expr_data
    rownames(expr_data) <- gsub('-','_',rownames(expr_data))
    expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
    expr_data <- log2(expr_data+1)
    life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
    life_data[life_data[,2]=='Alive',2] <- 1
    life_data[life_data[,2]=='Dead',2] <- 0
    life_data <- life_data[,c(1,6,5,2)]
    life_data[,2] <- gsub('-','.',life_data[,2])
    life_data[,2] <- gsub(', ','..',life_data[,2])
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
    
    #calculate the risk score of each sample.
    candidate_genes_for_cox2 <- gene_list
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_Validation'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)
    predict_effect_ver[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect_ver[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点#4cm*5cm
  })
}


#fig8A
#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:9,1]),]))
for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}
# data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=2)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IL'
# annotation_col[annotation_col[,1]==2,1] <- 'IM'
annotation_col[annotation_col[,1]%in%2,1] <- 'IH'
a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm


a <- t(a)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IH = "#E24A0E")) 
# a <- t(data)
plot <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                           annotation_colors = ann_colors,
                           clustering_method = 'ward.D2', 
                           color = c(colorRampPalette(c("navy", "white"))(100),
                                     colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                           cluster_cols = F,cluster_rows = T,treeheight_row = 3,
                           annotation_col = annotation_col,breaks = bk)#5*8
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8A.pdf',sep = ''), width=8, height=5)
print(plot,newpage = F)
dev.off()
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')






# library(ggplot2)
# data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:9,1]),]))
# # for (i in 1:ncol(data)) {
# #   data[,i] <- scale(as.numeric(data[,i]))
# # }
# data <- log2(data+1)
# dist.e <- dist(data,method='euclidean')
# model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
# result <- cutree(model1,k=3)#分类
# result <- as.data.frame(result)
# paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
# a <- cbind(rownames(result),result)
# colnames(a)[1] <- colnames(BRCA_subtype)[1]
# a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
# rownames(a) <- a[,1]
# a <- a[,-1]
# colnames(a) <- c('cluster','subtype')
# result <- a
# annotation_col <- result
# annotation_col[annotation_col[,1]==1,1] <- 'IL'
# annotation_col[annotation_col[,1]==2,1] <- 'IM'
# annotation_col[annotation_col[,1]==3,1] <- 'IH'
# a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
#            data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
#            data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
#            data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
# a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
#            a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
#            a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm
# 
# 
# a <- t(a)
# bk = unique(c(seq(-1,1, length=200)))
# ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
#                   cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
# # a <- t(data)
# pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
#                    annotation_colors = ann_colors,
#                    clustering_method = 'ward.D2', 
#                    color = c(colorRampPalette(c("navy", "white"))(100),
#                              colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
#                    cluster_cols = F,cluster_rows = T,
#                    annotation_col = annotation_col,
#                    breaks = bk)#5*8
# 
# paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
#亚型与不同聚类的生存曲线
# b <- lifetime_all[[2]]
# b <- b[b[,6]%in%rownames(annotation_col),]
# b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
# b[b[,6]%in%rownames(result)[result[,1]%in%2:3],7] <- 'IH'
# # b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
# # b[b[,6]%in%rownames(result)[result[,1]%in%2:3],7] <- 'IH'
# b$vital_status[which(b$V5 > 3650)] <- 0
# b$V5[which(b$V5 > 3650)] <- 3650
# c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
# c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
# plot <- ggsurvplot(c,            # 创建的拟合对象
#                    conf.int = F,    # 显示置信区间
#                    pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                    add.all = F,     # 添加总患者生存曲线
#                    palette = "hue",    # 自定义调色板
#                    surv.median.line = "hv",     # 添加中位生存时间线
#                    risk.table = TRUE,             # 添加风险表
#                    xlab = "Follow up time(d)", # 指定x轴标签
#                    legend = c(0.8,0.75),         # 指定图例位置
#                    title = c('BRCA_cluster'),                 # 设置图例标题
#                    #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                    break.x.by = 365,# 设置x轴刻度间距
#                    pval.method=T)
# 
# plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
#                         type = c("#E24A0E","blue","#F2CA20"),
#                         labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##亚型生存曲线
# all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
# BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
# BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
# #BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
# a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
# a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
# BRCA_subtype[,1] <- a
# annotation_row <- BRCA_subtype
# annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
# b <- annotation_row[,1]
# annotation_row <- as.data.frame(annotation_row[,3])
# rownames(annotation_row) <- b
# colnames(annotation_row) <- 'BRCA_subtype'
# 
# b <- lifetime_all[[2]]
# b <- b[b[,6]%in%rownames(annotation_col),]
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
# 
# b$vital_status[which(b$V5 > 3650)] <- 0
# b$V5[which(b$V5 > 3650)] <- 3650
# c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
# c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
# plot <- ggsurvplot(c,            # 创建的拟合对象
#                    conf.int = F,    # 显示置信区间
#                    pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                    add.all = F,     # 添加总患者生存曲线
#                    palette = "hue",    # 自定义调色板
#                    surv.median.line = "hv",     # 添加中位生存时间线
#                    risk.table = TRUE,             # 添加风险表
#                    xlab = "Follow up time(d)", # 指定x轴标签
#                    legend = c(0.8,0.75),         # 指定图例位置
#                    title = c('BRAD_subtype'),                 # 设置图例标题
#                    #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                    break.x.by = 365,# 设置x轴刻度间距
#                    pval.method=T)
# 
# plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
#                         type = c("#4498F2","gray","#ED5163","#72FCA0"),
#                         labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm
# 
# ####查看不同亚型下免疫low与median的区别
# b <- lifetime_all[[2]]
# b <- b[b[,6]%in%rownames(annotation_col),]
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
# 
# annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
# b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IL']] <- 'IL_LumA'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IM']] <- 'IM_LumA'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IH']] <- 'IH_LumA'
# b_IM <- b[!is.na(b$cluster_subtype),]
# 
# b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
# b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
# c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
# c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
# plot <- ggsurvplot(c,            # 创建的拟合对象
#                    conf.int = F,    # 显示置信区间
#                    pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                    add.all = F,     # 添加总患者生存曲线
#                    palette = "hue",    # 自定义调色板
#                    surv.median.line = "hv",     # 添加中位生存时间线
#                    risk.table = TRUE,             # 添加风险表
#                    xlab = "Follow up time(d)", # 指定x轴标签
#                    legend = c(0.8,0.75),         # 指定图例位置
#                    title = c('BRCA_immune_LumA'),                 # 设置图例标题
#                    #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                    break.x.by = 365,# 设置x轴刻度间距
#                    pval.method=T)
# plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
#                         type = c('#22BA4D','red','blue'),
#                         labels = c('IL_LumA','IM_LumA','IH_LumA'))##对齐坐标轴原点#4cm*5cm
# 
# b <- lifetime_all[[2]]
# b <- b[b[,6]%in%rownames(annotation_col),]
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
# 
# annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
# b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'
# 
# b_IM <- b[!is.na(b$cluster_subtype),]
# 
# b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
# b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
# c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
# c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
# plot <- ggsurvplot(c,            # 创建的拟合对象
#                    conf.int = F,    # 显示置信区间
#                    pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                    add.all = F,     # 添加总患者生存曲线
#                    palette = "hue",    # 自定义调色板
#                    surv.median.line = "hv",     # 添加中位生存时间线
#                    risk.table = TRUE,             # 添加风险表
#                    xlab = "Follow up time(d)", # 指定x轴标签
#                    legend = c(0.8,0.75),         # 指定图例位置
#                    title = c('BRCA_immune_Basal'),                 # 设置图例标题
#                    #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                    break.x.by = 365,# 设置x轴刻度间距
#                    pval.method=T)
# plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
#                         type = c('#22BA4D','red','blue'),
#                         labels = c('IL_Basal','IM_Basal','IH_Basal'))##对齐坐标轴原点#4cm*5cm

####分析主要是哪种免疫细胞在起作用
####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 1:15) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:10,])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:9,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name

bk = unique(c(seq(-1,1, length=200)))
plot <- pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T,
                           treeheight_row = 8,treeheight_col = 8)#8cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8B.pdf',sep = ''), width=8, height=8)
print(plot,newpage = F)
dev.off()

##fig8C
# 判断是什么免疫细胞
data <- expression_raw[[2]][1:10,]
# for (i in 1:10) {
#   data[,i] <- log2(as.numeric(data[,i])+1)
# }
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
a <- data.frame(sample=colnames(data))
a$immune_cell <- as.numeric(data[8,])
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
a <- a[!is.na(a$group),]
a$immune_cell <- a$immune_cell*100
a$group <- factor(a$group,levels = c('IL','IH'))
plot <- ggplot(a, aes(fill=group, y=immune_cell, x=group)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IH")), 
              map_signif_level = TRUE, test = t.test, y_position = c(19),
              tip_length = c(0.02))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8C.pdf',sep = ''), width=4, height=5)
print(plot,newpage = F)
dev.off()

#fig8D
##查看免疫浸润高低的突变差异
BRCA_mut_raw <- read.maf(maf = '/database/TCGA/BRCA/mutation/TCGA_BRCA_mutation.maf',clinicalData = '/database/TCGA/BRCA/mutation/clinical.tsv')
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

a <- rownames(annotation_col)
a <- substring(text = a,first = 1,last = 12)
IL_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IL'],]
IH_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IH'],]

write.table(IL_mut,'result/BRCA/mutation/IL_mut_new.maf',sep = '\t',quote = F,row.names = F)
write.table(IH_mut,'result/BRCA/mutation/IH_mut_new.maf',sep = '\t',quote = F,row.names = F)

IL_mut <- read.maf(maf ='result/BRCA/mutation/IL_mut_new.maf')
IH_mut <- read.maf(maf ='result/BRCA/mutation/IH_mut_new.maf')
#突变负荷差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_mut)
TMB[[2]] <- tmb(maf = IH_mut)
names(TMB) <- c('IL_mut','IH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IH_mut',nrow(TMB[[2]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_mut','IH_mut'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL_mut','IH_mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2,0.21),
              tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig8/V4/fig8E.pdf",width = 4,height = 5)
print(a,newpage = F)
dev.off()
#差异突变
IL_mut_vs_IH_mut <- mafCompare(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
forestPlot(mafCompareRes = IL_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
r1<-IL_mut_vs_IH_mut$results
g0<-r1[order(r1$IL_mut,decreasing = T)[1:10],Hugo_Symbol]
g1<-r1[order(r1$IL_mut,decreasing = T)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V4/fig8D.pdf",width = 15,height = 3)
coOncoplot(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = T)
dev.off()

#发现GATA3突变集中在IL组，然后这个GATA3可以调控CXCL1的转录，CXCL1可以诱导CD8+细胞
##fig8F

data <- expression_raw[[2]][c('CXCL1','GATA3'),]
rcorr(t(data),type = 'spearman')
annotation_col 

library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(scales)
a <- data.frame(sample=colnames(data))
a$CXCL1 <- as.numeric(data[1,])
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
a <- a[!is.na(a$group),]
# a$immune_cell <- a$immune_cell*100
a$group <- factor(a$group,levels = c('IL','IH'))
plot <- ggplot(a, aes(fill=group, y=CXCL1, x=group)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_signif(comparisons = list(c("IL","IH")), 
              map_signif_level = TRUE, test = t.test, y_position = c(19),
              tip_length = c(0.02))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8F.pdf',sep = ''), width=4, height=5)
print(plot,newpage = F)
dev.off()

a <- data.frame(sample=colnames(data))
a$GATA3 <- as.numeric(data[2,])
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
a <- a[!is.na(a$group),]
# a$immune_cell <- a$immune_cell*100
a$group <- factor(a$group,levels = c('IL','IH'))
plot <- ggplot(a, aes(fill=group, y=GATA3, x=group)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_signif(comparisons = list(c("IL","IH")), 
              map_signif_level = TRUE, test = t.test, y_position = c(19),
              tip_length = c(0.02))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8F.pdf',sep = ''), width=4, height=5)
print(plot,newpage = F)
dev.off()

#取出GATA3突变的患者
a <- data.frame(sample=colnames(data))
a$CXCL1 <- as.numeric(data[1,])
a$sample <- substring(a$sample,1,12)
a <- a[a$sample%in%BRCA_mut$Tumor_Sample_Barcode,]
a$group[a$sample%in%BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='GATA3']] <- 'mut'
a$group[is.na(a$group)] <- 'wt'
a <- a[!is.na(a$group),]
# a$immune_cell <- a$immune_cell*100
a$group <- factor(a$group,levels = c('wt','mut'))
plot <- ggplot(a, aes(fill=group, y=CXCL1, x=group)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_signif(comparisons = list(c("wt","mut")), 
              map_signif_level = TRUE, test = t.test, y_position = c(19),
              tip_length = c(0.02))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8F.pdf',sep = ''), width=4, height=5)
print(plot,newpage = F)
dev.off()

#此处已证明GATA3突变与CXCL1的表达降低相关
#接下来证明与CD8浸润相关的chemokine中，相关的有哪些
chemokine <- chemokine
CD8_chemokine <- chemokine$`T cell CD8+`
CD8_chemokine <- unique(CD8_chemokine)
data <- as.matrix(t(expression_raw[[2]][which(rownames(expression_raw[[2]])%in%c(CD8_chemokine,rownames(expression_raw[[2]])[8])),]))
a <- rcorr(data,type = 'spearman')[[1]]
a <- pheatmap::pheatmap(a)

pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8G.pdf',sep = ''), width=8, height=6)
grid.draw(a)
dev.off()


#然后接下来取出GATA3调控表达的几个基因作为辅助证明GATA3突变功能会丧失
data <- expression_raw[[2]][rownames(expression_raw[[2]])%in%human_TF[human_TF$TF=='GATA3',2],]
for (i in 1:37) {
  data[i,] <- scale(as.numeric(data[i,]))
}
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(scales)
a <- as.data.frame(t(data))
a$sample <- substring(rownames(a),1,12)
a <- a[a$sample%in%BRCA_mut$Tumor_Sample_Barcode,]
a$group[a$sample%in%BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='GATA3']] <- 'mut'
a$group[is.na(a$group)] <- 'wt'
a <- a[!is.na(a$group),]
a <- rbind(a[a$group=='wt',],a[a$group=='mut',])
bk = unique(c(seq(-1,1, length=200)))
plot <- pheatmap::pheatmap(a[,1:37],cluster_cols = T,show_rownames = F,breaks = bk,cluster_rows = F,
                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)))


plot <- pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = ,cluster_cols = T,
                           treeheight_row = 8,treeheight_col = 8)#8cm*8cm
GATA3 <- data.frame(gene <- colnames(a)[1:37])
for (i in 1:37) {
  GATA3$wt_mean[i] <- mean(a[a$group=='wt',i])
  GATA3$mut_mean[i] <- mean(a[a$group=='mut',i])
  GATA3$p_value[i] <- t.test(a[a$group=='wt',i],a[a$group=='mut',i])$p.value
}

pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8H.pdf',sep = ''), width=9, height=5)
grid.draw(plot)
dev.off()
#然后用maftools比较IL和IH组里面GATA3的突变结构域的差异

#ccle
library(stringr)
CCLE_expr <- read.csv('/database/depmap/CCLE_expression.csv',row.names = 1)
a <- colnames(CCLE_expr)
a <- str_split(a,'[.][.]',simplify = T)
colnames(CCLE_expr) <- a[,1]
CCLE_expr <- as.data.frame(t(CCLE_expr))
CCLE_expr <- 2**CCLE_expr
normalized_func <- function(x){x/sum(x)*1000000}
a <- as.data.frame(apply(CCLE_expr, 2, normalized_func))
CCLE_expr <- a
data <- CCLE_expr[rownames(CCLE_expr)%in%c(human_TF[human_TF$TF=='GATA3',2],'GATA3'),]
for (i in 1:37) {
  data[i,] <- scale(as.numeric(data[i,]))
}
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(scales)
a <- as.data.frame(t(data))
a$sample <- rownames(a)

a$group[a$sample%in%CCLE_mut[CCLE_mut$Hugo_Symbol=='GATA3','DepMap_ID']] <- 'mut'
a$group[is.na(a$group)] <- 'wt'
a <- a[!is.na(a$group),]
a <- rbind(a[a$group=='wt',],a[a$group=='mut',])
bk = unique(c(seq(-1,1, length=200)))

GATA3_cell <- data.frame(gene <- colnames(a)[1:36])
for (i in 1:36) {
  GATA3_cell$wt_mean[i] <- mean(a[a$group=='wt',i])
  GATA3_cell$mut_mean[i] <- mean(a[a$group=='mut',i])
  GATA3_cell$p_value[i] <- t.test(a[a$group=='wt',i],a[a$group=='mut',i])$p.value
}
a <- 
  
  pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8H.pdf',sep = ''), width=9, height=5)
grid.draw(plot)
dev.off()

##单样本GSEA
#处理EMT基因集
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

#单样本基因集富集分析
library(GSVA)
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

#单样本GSEA
geneset <- as.data.frame(EMT_gene$Gene)
colnames(geneset) <- 'EMT_score'
gs <- as.list(geneset)
a <- as.matrix(log2(expression_raw[[2]]+1))
ssgsea_score = gsva(a, 
                    gs, method = "ssgsea", 
                    kcdf="Gaussian",
                    ssgsea.norm = TRUE, 
                    verbose = TRUE)
ssgsea_score <- as.data.frame(t(ssgsea_score))
ssgsea_score$sample_id <- rownames(ssgsea_score)

#
# a <- as.data.frame(colnames(expression_raw[[2]]))
# a$sample <- substring(a[,1],1,12)
# a <- a[a$sample%in%BRCA_mut$Tumor_Sample_Barcode,]
# a$group[a$sample%in%BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='GATA3']] <- 'mut'
# a$group[is.na(a$group)] <- 'wt'
# a <- a[!is.na(a$group),]
# a <- rbind(a[a$group=='wt',],a[a$group=='mut',])
# colnames(a)[1] <- 'sample_id'
a <- annotation_col
a$sample <- substring(rownames(a),1,12)
a$sample_id <- rownames(a)

#
b <- merge(a,ssgsea_score,by='sample_id',all=F)

##画图
plot1 <- b
plot1 <- ggplot(plot1, aes(x=cluster, y=EMT_score,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.5),
              tip_length = c(0.03))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8I.pdf',sep = ''), width=5, height=5)
print(plot1,newpage = F)
dev.off()





plot2 <- b[b$N.Stage%in%c('group1','group2'),]
plot2 <- ggplot(plot2, aes(x=N.Stage, y=VIM,fill=N.Stage)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('group1','group2')), 
              map_signif_level = TRUE, test = t.test, y_position = c(12.5),
              tip_length = c(0.03))#5cm*4cm

plot2 <- b[b$N.Stage%in%c('group1','group2'),]
plot2 <- ggplot(plot2, aes(x=N.Stage, y=VIM,fill=N.Stage)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('group1','group2')), 
              map_signif_level = TRUE, test = t.test, y_position = c(12.5),
              tip_length = c(0.03))#5cm*4cm

plot3 <- b[b$N.Stage%in%c('group1','group2'),]
plot3 <- ggplot(plot3, aes(x=N.Stage, y=CDH2,fill=N.Stage)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('group1','group2')), 
              map_signif_level = TRUE, test = t.test, y_position = c(10),
              tip_length = c(0.03))#5cm*12cm

library(patchwork)
plot1|plot2|plot3




####阳性对照
b$VIM_level[b$VIM>median(b$VIM)] <- 'high'
b$VIM_level[b$VIM<=median(b$VIM)] <- 'low'
plot4 <- b[b$N.Stage%in%c('group1','group2'),]
ggplot(b, aes(x=VIM_level, y=EMT_score,fill=VIM_level)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('high','low')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.5),
              tip_length = c(0.03))#5cm*5cm



# 判断是什么免疫细胞
r1<-LumA_IL_mut_vs_IM_mut$results
r1<-LumA_IL_mut_vs_IH_mut$results
r1<-LumA_IM_mut_vs_IH_mut$results
r1<-Basal_IL_mut_vs_IM_mut$results
g0 <- r1[order(r1$pval,decreasing = F)[1:40],Hugo_Symbol]
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = IL_basal_mut, m2 = IM_basal_mut, m1Name = 'IL', m2Name = 'IM', genes = g, removeNonMutated = F)
coOncoplot(m1 = IM_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = F)
coOncoplot(m1 = IL_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = F)
#3cm*10cm







########分析LumA和Basal种CD8 T和Treg的含量差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)

names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IL_Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('IM_Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('IH_Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IM_LumA','IH_LumA','IL_Basal','IM_Basal','IH_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IM_LumA"),c("IM_LumA","IH_LumA"),c("IL_Basal","IM_Basal"),c("IM_Basal","IH_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2,0.21),
              tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
a

####分析T细胞激活marker
##分析PD1,PDL1的水平LumA和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('IGLC7','IGHV3-43','CD79A','IGAN2','IGAN1','FCGR2A','FCGR3A','GSDME','GSDMD','BCL2L1','CASP3','XIAP','TRAF1','HTRA2','BIRC7','BIRC5','BIRC2','BIRC3','TGIF1','HIF1A','IL10','TNFRSF9','IL21','CD8A','PDCD1','CD274','CTLA4','GZMA','GZMB','PRF1','PRF2'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

# plot <- TMB_plot[,c('Tumor_Sample_Barcode','cluster','GZMA','GZMB','PRF1')]
# plot <- pivot_longer(plot,cols = 3:5,names_to = 'gene',values_to = 'expr')
# plot$cluster <- factor(plot$cluster)
# plot$gene <- factor(plot$gene)
TMB_plot$IGLC7 <- TMB_plot$IGLC7+1
ggplot(TMB_plot, aes(x=cluster, y=`IGLC7`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
a <-ggplot(TMB_plot, aes(x=cluster, y=`IGLC7`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
b <-ggplot(TMB_plot, aes(x=cluster, y=GZMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
c <-ggplot(TMB_plot, aes(x=cluster, y=PRF1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

##分析免疫检查点
TMB_plot$PDCD1 <- TMB_plot$PDCD1+1
TMB_plot$CD274 <- TMB_plot$CD274+1
TMB_plot$CTLA4 <- TMB_plot$CTLA4+1
a <-ggplot(TMB_plot, aes(x=cluster, y=PDCD1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

b <-ggplot(TMB_plot, aes(x=cluster, y=CD274,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

c <-ggplot(TMB_plot, aes(x=cluster, y=CTLA4,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

####GSEA分析
TMB <- list()
TMB[[1]] <- tmb(maf = IM_LumA_mut)
TMB[[2]] <- tmb(maf = IH_LumA_mut)
TMB[[3]] <- tmb(maf = IM_basal_mut)
TMB[[4]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IM_LumA_mut','IH_LumA_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('Basal',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
# TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
# TMB <- list()
# TMB[[1]] <- tmb(maf = IL_LumA_mut)
# TMB[[2]] <- tmb(maf = IM_LumA_mut)
# TMB[[3]] <- tmb(maf = IH_LumA_mut)
# TMB[[4]] <- tmb(maf = IL_basal_mut)
# TMB[[5]] <- tmb(maf = IM_basal_mut)
# TMB[[6]] <- tmb(maf = IH_basal_mut)
# names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
# ##画箱线图
# TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
#                   cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
#                   cbind(TMB[[3]],rep('LumA',nrow(TMB[[3]]))),
#                   cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
#                   cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
#                   cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
# colnames(TMB_plot)[5] <- 'cluster'
# TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)
group_list <- TMB_plot[,c(1,5)]
TMB_plot <- TMB_plot[,17:ncol(TMB_plot)]
TMB_plot <- as.data.frame(t(TMB_plot))
colnames(TMB_plot) <- group_list$Tumor_Sample_Barcode
library(GSEABase)
library(limma) 
library(clusterProfiler)
library(enrichplot)
dat <- TMB_plot
group_list <- factor(group_list$cluster,ordered = F)
design <- model.matrix(~factor( group_list ))
fit=lmFit(dat,design)
fit=eBayes(fit)
options(digits = 4)
topTable(fit,coef=2,adjust='BH')
deg=topTable(fit,coef=2,adjust='BH',number = Inf)
a <- TMB_plot[rownames(deg),group_list=='LumA']
deg$LumA_mean <- apply(a,1,mean)
a <- TMB_plot[rownames(deg),group_list=='Basal']
deg$Basal_mean <- apply(a,1,mean)
deg$gene <- rownames(deg)
head(deg)
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c5.go.v7.5.1.symbols.gmt")
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c7.immunesigdb.v7.5.1.symbols.gmt")
geneList <- deg$logFC
names(geneList) <- toupper(rownames(deg))
geneList <- sort(geneList,decreasing = T)
gsea_results <- GSEA(geneList = geneList,
                     TERM2GENE = geneset,
                     verbose = F,minGSSize = 0,maxGSSize = 500,
                     eps=0,pvalueCutoff = 1)

gsea_results_immune <- GSEA(geneList = geneList,
                            TERM2GENE = geneset,
                            verbose = F,minGSSize = 0,maxGSSize = 500,
                            eps=0,pvalueCutoff = 1)
class(gsea_results)
gseaplot2(x=gsea_results,geneSetID=c('GOBP_B_CELL_MEDIATED_IMMUNITY')) #3*5cm

# for (i in 1:length(list)) {
#   p <- gseaplot2(x=gsea_results,geneSetID=paste("HALLMARK_",list[i],sep="")) 
#   d <- paste("./",list[i],".pdf",sep="")
#   pdf(file=d,
#       family = "Times",width=10,height = 6)
#   print(p)
#   dev.off()
# }
gsea_results@result$core_enrichment[1]


#####LumB与basal的分析
#亚型与不同聚类的生存曲线
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#E24A0E","blue","#F2CA20"),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##亚型生存曲线
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#4498F2","gray","#ED5163","#72FCA0"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm

####查看不同亚型下免疫low与median的区别
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumB'&annotation_col$cluster=='IL']] <- 'IL_LumB'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumB'&annotation_col$cluster=='IM']] <- 'IM_LumB'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumB'&annotation_col$cluster=='IH']] <- 'IH_LumB'
b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_LumA'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_LumA','IM_LumA','IH_LumA'))##对齐坐标轴原点#4cm*5cm

b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'

b_IM <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_Basal'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c('#22BA4D','red','blue'),
                        labels = c('IL_Basal','IM_Basal','IH_Basal'))##对齐坐标轴原点#4cm*5cm

####观察hub基因在basal中还有没有效果
b <- lifetime[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'
b_basal <- b[!is.na(b$cluster_subtype),]

b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
surv_sig_dgree[[2]][1:10]
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_immune_Basal'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)


####分析主要是哪种免疫细胞在起作用
####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 2) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:10,])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:9,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name

bk = unique(c(seq(-1,1, length=200)))
pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                   color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                   clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T,
                   treeheight_row = 8,treeheight_col = 8)#8cm*8cm

########分析LumB和Basal种CD8 T和Treg的含量差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumB_mut)
TMB[[2]] <- tmb(maf = IM_LumB_mut)
TMB[[3]] <- tmb(maf = IH_LumB_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)

names(TMB) <- c('IL_LumB_mut','IM_LumB_mut','IH_LumB_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumB',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_LumB',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_LumB',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IL_Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('IM_Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('IH_Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumB','IM_LumB','IH_LumB','IL_Basal','IM_Basal','IH_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IM_LumA"),c("IM_LumA","IH_LumA"),c("IL_Basal","IM_Basal"),c("IM_Basal","IH_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2,0.21),
              tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
a

####分析T细胞激活marker
##分析PD1,PDL1的水平LumB和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumB_mut)
TMB[[2]] <- tmb(maf = IM_LumB_mut)
TMB[[3]] <- tmb(maf = IH_LumB_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumB',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumB',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('LumB',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumB','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('IGLC7','IGHV3-43','CD79A','IGAN2','IGAN1','FCGR2A','FCGR3A','GSDME','GSDMD','BCL2L1','CASP3','XIAP','TRAF1','HTRA2','BIRC7','BIRC5','BIRC2','BIRC3','TGIF1','HIF1A','IL10','TNFRSF9','IL21','CD8A','PDCD1','CD274','CTLA4','GZMA','GZMB','PRF1','PRF2'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)


a <-ggplot(TMB_plot, aes(x=cluster, y=`PDCD1`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
b <-ggplot(TMB_plot, aes(x=cluster, y=GZMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
c <-ggplot(TMB_plot, aes(x=cluster, y=PRF1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

##分析免疫检查点
TMB_plot$PDCD1 <- TMB_plot$PDCD1+1
TMB_plot$CD274 <- TMB_plot$CD274+1
TMB_plot$CTLA4 <- TMB_plot$CTLA4+1
a <-ggplot(TMB_plot, aes(x=cluster, y=PDCD1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

b <-ggplot(TMB_plot, aes(x=cluster, y=CD274,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

c <-ggplot(TMB_plot, aes(x=cluster, y=CTLA4,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumB","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

####GSEA分析
TMB <- list()
TMB[[1]] <- tmb(maf = IM_LumB_mut)
TMB[[2]] <- tmb(maf = IH_LumB_mut)
TMB[[3]] <- tmb(maf = IM_basal_mut)
TMB[[4]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IM_LumB_mut','IH_LumB_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumB',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumB',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('Basal',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'

data <- as.data.frame(t(expr_data_raw[[2]]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)
group_list <- TMB_plot[,c(1,5)]
TMB_plot <- TMB_plot[,17:ncol(TMB_plot)]
TMB_plot <- as.data.frame(t(TMB_plot))
colnames(TMB_plot) <- group_list$Tumor_Sample_Barcode
library(GSEABase)
library(limma) 
library(clusterProfiler)
library(enrichplot)
dat <- TMB_plot
group_list <- factor(group_list$cluster,ordered = F)
design <- model.matrix(~factor( group_list ))
fit=lmFit(dat,design)
fit=eBayes(fit)
options(digits = 4)
topTable(fit,coef=2,adjust='BH')
deg=topTable(fit,coef=2,adjust='BH',number = Inf)
a <- TMB_plot[rownames(deg),group_list=='LumB']
deg$LumB_mean <- apply(a,1,mean)
a <- TMB_plot[rownames(deg),group_list=='Basal']
deg$Basal_mean <- apply(a,1,mean)
deg$gene <- rownames(deg)
head(deg)
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c5.go.v7.5.1.symbols.gmt")
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c7.immunesigdb.v7.5.1.symbols.gmt")
geneList <- deg$logFC
names(geneList) <- toupper(rownames(deg))
geneList <- sort(geneList,decreasing = T)
gsea_results <- GSEA(geneList = geneList,
                     TERM2GENE = geneset,
                     verbose = F,minGSSize = 0,maxGSSize = 500,
                     eps=0,pvalueCutoff = 1)

gsea_results_immune <- GSEA(geneList = geneList,
                            TERM2GENE = geneset,
                            verbose = F,minGSSize = 0,maxGSSize = 500,
                            eps=0,pvalueCutoff = 1)
class(gsea_results)
d <- gseaplot2(x=gsea_results,geneSetID=c('GOBP_POSITIVE_REGULATION_OF_B_CELL_ACTIVATION',
                                          'GOBP_B_CELL_MEDIATED_IMMUNITY')) 

pdf(file='GSEA.pdf',
    family = "Times",width=10,height = 6)
print(d)
dev.off()

for (i in 1:length(list)) {
  p <- gseaplot2(x=gsea_results,geneSetID=paste("HALLMARK_",list[i],sep="")) 
  d <- paste("./",list[i],".pdf",sep="")
  pdf(file=d,
      family = "Times",width=10,height = 6)
  print(p)
  dev.off()
}
gsea_results@result$core_enrichment[1]

####接下来分析Basal浸润高低之间的突变差异
#差异突变
LumA_IL_mut_vs_IH_mut <- mafCompare(m1 = IL_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IL_LumA_mut', m2Name = 'IH_LumA_mut', minMut = 2, useCNV =FALSE)
LumA_IM_mut_vs_IH_mut <- mafCompare(m1 = IM_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IM_LumA_mut', m2Name = 'IH_LumA_mut', minMut = 2, useCNV =FALSE)
LumA_IL_mut_vs_IM_mut <- mafCompare(m1 = IL_LumA_mut, m2 = IM_LumA_mut, m1Name = 'IL_LumA_mut', m2Name = 'IM_LumA_mut', minMut = 2, useCNV =FALSE)

Basal_IL_mut_vs_IH_mut <- mafCompare(m1 = IL_basal_mut, m2 = IH_basal_mut, m1Name = 'IL_Basal_mut', m2Name = 'IH_Basal_mut', minMut = 2, useCNV =FALSE)
Basal_IM_mut_vs_IH_mut <- mafCompare(m1 = IM_basal_mut, m2 = IH_basal_mut, m1Name = 'IM_Basal_mut', m2Name = 'IH_Basal_mut', minMut = 2, useCNV =FALSE)
Basal_IL_mut_vs_IM_mut <- mafCompare(m1 = IL_basal_mut, m2 = IM_basal_mut, m1Name = 'IL_Basal_mut', m2Name = 'IM_Basal_mut', minMut = 2, useCNV =FALSE)

# a <- mafCompare(m1 = IL_LumA_mut, m2 = IL_basal_mut, m1Name = 'IL_LumA_mut', m2Name = 'IL_basal_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = LumA_IL_mut_vs_IM_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = LumA_IL_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = LumA_IM_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = Basal_IL_mut_vs_IM_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = Basal_IM_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = Basal_IL_mut_vs_IM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)




r1<-LumA_IL_mut_vs_IM_mut$results
r1<-LumA_IL_mut_vs_IH_mut$results
r1<-LumA_IM_mut_vs_IH_mut$results
r1<-Basal_IL_mut_vs_IM_mut$results
g0 <- r1[order(r1$pval,decreasing = F)[1:40],Hugo_Symbol]
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = IL_basal_mut, m2 = IM_basal_mut, m1Name = 'IL', m2Name = 'IM', genes = g, removeNonMutated = F)
coOncoplot(m1 = IM_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = F)
coOncoplot(m1 = IL_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = F)
#3cm*10cm

#########分析LumA_ML组特异性突变的功能类型
a <- r1[r1$pval<0.05&r1$IL_Basal_mut>r1$IM_Basal_mut,]
a <- bitr(a$Hugo_Symbol,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 1, #P值阈值
              qvalueCutoff = 1, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名















# a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell regulatory (Tregs)`,fill=cluster)) +
#   # scale_y_continuous(trans = log2_trans(),
#   #                    breaks = trans_breaks("log2", function(x) 2^x),
#   #                    labels = trans_format("log2", math_format(2^.x))) +
#   geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
#   geom_jitter(shape=16, position = position_jitter(0.2))+
#   theme_classic()+
#   geom_signif(comparisons = list(c("IL_LumA","IM_LumA"),c("IM_LumA","IH_LumA"),c("IL_Basal","IM_Basal"),c("IM_Basal","IH_Basal")), 
#               map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.22,0.2,0.22),
#               tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
# a
# #画柱状图
# library(ggplot2)
# library(forcats)
# library(tidyr)
# library(tidyverse)
# plot <- TMB_plot[,c(1,5,13:14)]
# plot <- pivot_longer(data = plot,cols = 3:4,names_to = 'cell_type',values_to = 'percent')
# plot$cluster <- factor(plot$cluster)
# plot$cell_type <- factor(plot$cell_type)
# ggplot(plot, aes(fill=cluster, y=percent, x=cell_type))+
#   geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
#   theme_classic(base_size = 12)+
#   theme(legend.direction = "horizontal", legend.position = "top")+
#   labs(title = "", y="Surv-sig rate ", x = "Sample Size")+
#   stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
#                width = 0.5,position = position_dodge(0.9))+
#   scale_y_continuous(limits = c(0,0.05),expand = c(0,0))+
#   theme(axis.text.x = element_text(size = 12))+
#   theme(axis.text.y = element_text(size = 12))+
#   theme(axis.title = element_text(size = 14))+
#   geom_signif(data = plot,aes(xmin=0.75, xmax=1.25, annotations="*", y_position=5.25),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.2),
#               manual=TRUE)
#   
#   
#   
# Genotype = c("Wildtype", "APOE4", "Wildtype", "APOE4", "Wildtype", "APOE4", "Wildtype", "APOE4")
# Material = c("Shredded paper","Shredded paper","Square","Square","Bedding","Bedding","Twist", "Twist")
# Mean = c(4.77,3.52, 2.57, 1.39, 2.73, 1.73, 2.63, 1.30)
# se = c(0.16, 0.24, 0.36, 0.06, 0.25, 0.26, 0.29, 0.05) 
# df = data.frame(Genotype, Material, Mean, se)
# df$Genotype<- factor(df$Genotype, levels=(c("Wildtype", "APOE4")))
# df$Material<- factor(df$Material, levels=(c("Shredded paper","Square", "Bedding", "Twist")))
# ggplot(df, aes(x=Material, y = Mean, fill=Genotype))+
#   geom_bar(position=position_dodge(), stat="identity")+
#   scale_fill_manual(values=c("#CCCCCC", "#666666", "#CCCCCC", "#666666", "#CCCCCC", "#666666", "#CCCCCC", "#666666"))+
#   geom_errorbar(aes(ymin=Mean-se, ymax=Mean+se), 
#                 width=0.2,
#                 position=position_dodge(0.9))+  #this line of code makes the bar that extends across the 3-nonsig materials
#   scale_y_continuous(name="Average score\n", expand=c(0,0))+
#   geom_text(aes(x=1, y=5.9, label="Stretch It"), vjust=-1)+
#   scale_x_discrete(name="\nProvided materials")+
#   ggtitle("          Averaged scores of nests constructed by wildtype or APOE4 mice\n")+ #added chunk of space to center title in jpeg file
#   theme(plot.title=element_text(lineheight=0.8, face="bold", hjust=0.5))+
#   theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
#         panel.background=element_blank(), axis.line=element_line(color="black")) -> p1
# p1+
#   geom_signif(data=df,
#               aes(xmin=0.75, xmax=1.25, annotations="*", y_position=5.25),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.2),
#               manual=TRUE)+
#   geom_signif(data=df,
#               aes(xmin=1.75, xmax=2.25, annotations="*", y_position=3.30),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.3),
#               manual=TRUE) +
#   geom_signif(data=df,
#               aes(xmin=2.75, xmax=3.25, annotations="*", y_position=3.30),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.2),
#               manual=TRUE)+
#   geom_signif(data=df,
#               aes(xmin=3.75, xmax=4.25, annotations="*", y_position=3.30),
#               textsize = 5, vjust = 0.05, tip_length = c(0.04, 0.3),
#               manual=TRUE)














#再看看LumA和basal的NK和CD8的比例如何
########Basal的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = IL_basal_mut)
TMB[[2]] <- tmb(maf = IM_basal_mut)
TMB[[3]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_basal',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_basal',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_basal',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_basal','IM_basal','IH_basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:10,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)


a <-ggplot(TMB_plot, aes(x=cluster, y=`total_perMB`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_basal","IM_basal"),c("IM_basal","IH_basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.1,0.11,0.1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a

########LumA的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IL_basal_mut)
TMB[[3]] <- tmb(maf = IM_LumA_mut)
TMB[[4]] <- tmb(maf = IM_basal_mut)
names(TMB) <- c('IL_LumA_mut','IL_basal_mut','IM_LumA_mut','IM_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IL_Basal',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IM_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IM_Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IL_Basal','IM_LumA','IM_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:10,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`NK cell`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.1,0.11,0.1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.2),
              tip_length = c(0.01,0.01))#5cm*4cm
a

a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell regulatory (Tregs)`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.2),
              tip_length = c(0.01,0.01))#5cm*4cm
a

a <-ggplot(TMB_plot, aes(x=cluster, y=`B cell`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IL_Basal"),c("IM_LumA","IM_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.2),
              tip_length = c(0.01,0.01))#5cm*4cm
a
##分析PD1,PDL1的水平LumA和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IL_basal_mut)
TMB[[3]] <- tmb(maf = IM_LumA_mut)
TMB[[4]] <- tmb(maf = IM_basal_mut)

names(TMB) <- c('IL_LumA_mut','IL_basal_mut','IM_LumA_mut','IM_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IL_Basal',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IM_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IM_Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IL_Basal','IM_LumA','IM_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('GSDME','GSDMD','BCL2L1','CASP3','XIAP','TRAF1','HTRA2','BIRC7','BIRC5','BIRC2','BIRC3','TGIF1','HIF1A','IL10','TNFRSF9','IL21','CD8A','PDCD1','CD274','CTLA4','GZMA','GZMB','PRF1','PRF2'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=TGIF1,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(33,33),
              tip_length = c(0.05,0.05))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=CD274,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(6,6),
              tip_length = c(0.02,0.02))#5cm*4cm
a

a <-ggplot(TMB_plot, aes(x=cluster, y=CTLA4,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(33,33),
              tip_length = c(0.02,0.02))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=CD8A,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(33,33),
              tip_length = c(0.02,0.02))#5cm*4cm
a
a <-ggplot(TMB_plot, aes(x=cluster, y=HIF1A,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IM_LumA","IM_Basal"),c('IL_LumA','IL_Basal')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1,1),
              tip_length = c(0.02,0.02))#5cm*4cm
a






##免疫浸润的程度比较
#整体浸润比较
a <- expression_raw[[2]][1:11,]
a <- as.data.frame(t(a))
a$all_immune <- 1-a$`uncharacterized cell`
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)

b$cluster <- factor(b$cluster,levels = c('IL','IM','IH'))
a <-ggplot(b, aes(x=cluster, y=all_immune,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1,1.1,1),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm

a <-ggplot(b, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_dotplot(dotsize = 0.1)
geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IM"),c("IL","IH"),c('IM','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.3,0.4,0.3),
              tip_length = c(0.05,0.05,0.05))#5cm*4cm
####通路
nest_pathway <- read.csv('/database/IAS/NeST Map - Main Model default node.csv')
nest_pathway_list <- list()
for (i in 1:nrow(nest_pathway)) {
  a <- nest_pathway[i,4]
  nest_pathway_list[[i]] <- str_split(a,' ',simplify = F)[[1]]
}
names(nest_pathway_list) <- nest_pathway$Annotation

path_num_cal <- function(x){
  x=nest_pathway_list[[x]]
  length(which(a%in%x))
}
patient_pathway <- list()
patient_id <- unique(BRCA_mut$Tumor_Sample_Barcode)
for (i in 1:length(patient_id)) {
  a <- unique(BRCA_mut$Hugo_Symbol[BRCA_mut$Tumor_Sample_Barcode==patient_id[i]])
  b <- as.data.frame(names(nest_pathway_list))
  b[,2] <- apply(b, 1, path_num_cal)
  colnames(b) <- c('pathway_name','map_mut_num')
  patient_pathway[[i]] <- b
}
names(patient_pathway) <- patient_id

patient_pathway_table <- data.frame(names(nest_pathway_list))
rownames(patient_pathway_table) <- patient_pathway_table[,1]
for (i in 1:length(patient_pathway)) {
  patient_pathway_table[,i] <- patient_pathway[[i]][,2]
  patient_pathway_table[patient_pathway_table[,i]>0,i] <- 1
  patient_pathway_table[patient_pathway_table[,i]==0,i] <- 0
}
colnames(patient_pathway_table) <- names(patient_pathway)

patient_pathway_table <- patient_pathway_table[apply(patient_pathway_table, 1, sum)>0,]

##画热图比较这两组样本的基因
hotmap <- cbind(patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='IL',4]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='IM',4]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='IH',4]])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,3]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(IL = "#72FCA0",IM = "#4498F2", IH = "#ED5163")) #连续数值型分组可设置成渐变  
##画瀑布图
diff_pathway_list <- data.frame(rownames(hotmap))
for (i in 1:nrow(diff_pathway_list)) {
  tryCatch({
    c <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='IL',4]]
    d <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='IM',4]]
    e <- hotmap[i,colnames(hotmap)%in%b[b[,1]=='IH',4]]
    diff_pathway_list[i,2] <- sum(c)
    diff_pathway_list[i,3] <- sum(d)
    diff_pathway_list[i,4] <- sum(e)
    diff_pathway_list[i,5] <- t.test(c,d)$p.value
    diff_pathway_list[i,6] <- t.test(c,e)$p.value
    diff_pathway_list[i,7] <- t.test(d,e)$p.value
  }, error = function(e) {print('error')})
}
diff_pathway_list[1,5:7] <- 1
colnames(diff_pathway_list) <- c('pathway','IL','IM','IH','IL_IM','IL_IH','IM_IH')
c <- apply(hotmap, 1, sum)
c <- cbind(rownames(hotmap),c)
c <- as.data.frame(c)
colnames(c) <- c('nest','num')
c <- c[order(as.numeric(c[,2]),decreasing = F),]
for (i in 1:nrow(c)) {
  a <- as.data.frame(hotmap[i,])
  hotmap <- cbind(hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==1]],
                  hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==0]])
}
hotmap <- hotmap[rownames(c)[nrow(c):1],]
a <- pheatmap::pheatmap(hotmap,cluster_col = T,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- as.data.frame(cutree(a$tree_col,k=2))
hotmap <- cbind(hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==1]],
                hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==2]])

hotmap <- cbind(hotmap[,colnames(hotmap)%in%b[b[,1]=='IL',4]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='IM',4]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='IH',4]])
hotmap <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[!(diff_pathway_list$IL_IM>0.05&diff_pathway_list$IL_IH>0.05&diff_pathway_list$IM_IH>0.05)],]


a <- pheatmap::pheatmap(hotmap,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$IL_IM<0.05],]
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$IM_IH<0.05],]
a <- pheatmap::pheatmap(a,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm



diff_pathway_list$ML_specific[(diff_pathway_list$ML/179)>(diff_pathway_list$MM/258)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$ML/179)>(diff_pathway_list$MH/67)&diff_pathway_list$ML_MH<0.05] <- '1'
diff_pathway_list$MM_specific[(diff_pathway_list$MM/258)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$MM/258)>(diff_pathway_list$MH/67)&diff_pathway_list$MM_MH<0.05] <- '1'
diff_pathway_list$MH_specific[(diff_pathway_list$MH/67)>(diff_pathway_list$ML/179)&diff_pathway_list$ML_MH<0.05&
                                (diff_pathway_list$MH/67)>(diff_pathway_list$MM/258)&diff_pathway_list$MM_MH<0.05] <- '1'

























#判断是什么免疫细胞
# data <- expression_raw[[2]][1:10,]
# # for (i in 1:10) {
# #   data[,i] <- log2(as.numeric(data[,i])+1)
# # }
# library(ggplot2)
# library(forcats)
# library(tidyr)
# library(tidyverse)
# library(ggthemes)
# a <- data.frame(sample=colnames(data))
# a$immune_cell <- as.numeric(data[i,])
# a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
# a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
# a <- a[!is.na(a$group),]
# a$immune_cell <- a$immune_cell*100
# ggplot(a, aes(fill=group, y=immune_cell, x=group)) +
#   geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
#   geom_jitter(shape=16, position = position_jitter(0.2))+
#   theme_classic()+
#   stat_compare_means(method = "t.test",paired = F )#5cm*4cm










a




































####分析调控基因
a <- surv_sig_inter[[2]]
colnames(a) <- c('gene1','value','gene2')
b <- a[,3:1]
colnames(b) <- c('gene1','value','gene2')
a <- rbind(a,b)
gene <- unique(a$gene1)
b <- data.frame(1:length(gene))
for (i in 1:length(gene)) {
  k1 <- a$gene2[a$gene1%in%gene[i]]
  k2 <- a$gene2[a$gene1%in%k1]
  k3 <- a$gene2[a$gene1%in%k2]
  b[i,2] <- length(unique(c(k1,k2,k3)))
}
b[,1] <- gene
colnames(b) <- c('gene','k3')
b <- b[order(b$k3,decreasing = T),]

a <- surv_sig_dgree[[2]]
for (i in 1:nrow(b)) {
  ifelse(b[i,1]%in%a[,1],b$degree[i] <- a[a[,1]==b[i,1],2],b$degree[i] <- 0)
}
b <- b[1:10,]
b <- b[b[,3]!=0,]
a <- b[,1]

# data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(a,surv_sig_dgree[[2]][1:10,1])),]))
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%a),]))
for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=2)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col[rownames(annotation_col)%in%rownames(result)[result[,1]==1],3] <- 'low'
annotation_col[rownames(annotation_col)%in%rownames(result)[result[,1]==2],3] <- 'median'
annotation_col[rownames(annotation_col)%in%rownames(result)[result[,1]==3],3] <- 'high'
colnames(annotation_col)[3] <- 'main'

data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%c(b[,1],surv_sig_dgree[[2]][1:10,1])),]))
data <- as.matrix(t(expression_raw[[2]][which(rownames(expression_raw[[2]])%in%c(b[,1],rownames(expression_raw[[2]])[1:10])),]))
data <- as.matrix(t(expression_raw[[2]][which(rownames(expression_raw[[2]])%in%c(b[,1],c('PDCD1','CD274','CTLA4'))),]))

for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}
a <- t(data)
a <- cbind(a[,c(rownames(annotation_col)[annotation_col$subtype=='LumA'],
                rownames(annotation_col)[annotation_col$subtype=='LumB'],
                rownames(annotation_col)[annotation_col$subtype=='Her2'],
                rownames(annotation_col)[annotation_col$subtype=='Basal'])])
a <- cbind(a[,c(rownames(annotation_col)[annotation_col$cluster=='IL'],
                rownames(annotation_col)[annotation_col$cluster=='IH'])])
a <- cbind(a[,colnames(a)%in%rownames(annotation_col)[annotation_col$main=='low']],
           a[,colnames(a)%in%rownames(annotation_col)[annotation_col$main=='median']],
           a[,colnames(a)%in%rownames(annotation_col)[annotation_col$main=='high']])


bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "blue",IH = "#E24A0E")) 

pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                   annotation_colors = ann_colors,
                   clustering_method = 'ward.D2', 
                   color = c(colorRampPalette(c("navy", "white"))(100),
                             colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                   cluster_cols = F,cluster_rows = T,
                   annotation_col = annotation_col[,1:3],
                   breaks = bk)#5*8

####BRCA分析
#首先计算真正的hub基因
#fig8A
####BRCA所有网络的hub
a <- surv_sig_inter[[2]]
colnames(a) <- c('gene1','value','gene2')
b <- a[,3:1]
colnames(b) <- c('gene1','value','gene2')
a <- rbind(a,b)
gene <- unique(a$gene1)
b <- data.frame(1:length(gene))
for (i in 1:length(gene)) {
  k1 <- a$gene2[a$gene1%in%gene[i]]
  k2 <- a$gene2[a$gene1%in%k1]
  k3 <- a$gene2[a$gene1%in%k2]
  b[i,2] <- length(unique(c(k1,k2,k3)))
}
b[,1] <- gene
colnames(b) <- c('gene','k3')
b <- b[order(b$k3,decreasing = T),]

a <- surv_sig_dgree[[2]]
for (i in 1:nrow(b)) {
  ifelse(b[i,1]%in%a[,1],b$degree[i] <- a[a[,1]==b[i,1],2],b$degree[i] <- 0)
}
b <- b[b[,3]!=0,]
b <- b[1:10,]
a <- b[,1]

#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
library(clusterProfiler)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%a),]))
# for (i in 1:ncol(data)) {
#   data[,i] <- scale(as.numeric(data[,i]))
# }
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'type1'
annotation_col[annotation_col[,1]==2,1] <- 'type2'
annotation_col[annotation_col[,1]==3,1] <- 'type3'

a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='type3'],])#4cm*8cm
a <- t(a)
# a <- log2(t(a)+1)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(type1 = "blue",type2 = "#F2CA20", type3 = "#E24A0E")) 
# a <- t(data)
plot <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                           annotation_colors = ann_colors,
                           clustering_method = 'ward.D2', 
                           color = c(colorRampPalette(c("navy", "white"))(100),
                                     colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                           cluster_cols = F,cluster_rows = T,
                           annotation_col = annotation_col,
                           breaks = bk)#5*8
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8A.pdf',sep = ''), width=9, height=5)
grid.draw(plot)
dev.off()

##生存分析
#亚型与不同聚类的生存曲线
b <- lifetime_all[[2]]
b <- b[b[,6]%in%rownames(annotation_col),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'type1'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'type2'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'type3'
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8B1.pdf',sep = ''), width=8, height=7)
print(plot,newpage = F)
dev.off()

plot <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
                        type = c("#E24A0E","blue","#F2CA20"),
                        labels = c('type1','type2','type3'))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8B2.pdf',sep = ''), width=7, height=5)
grid.draw(plot)
dev.off()
##亚型生存曲线
library(stringr)
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime_all[[2]]
b <- b[b[,6]%in%rownames(annotation_row),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8C1.pdf',sep = ''), width=8, height=7)
print(plot,newpage = F)
dev.off()

plot <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#4498F2","gray","#ED5163","#72FCA0"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8C2.pdf',sep = ''), width=7, height=5)
grid.draw(plot)
dev.off()

##计算三个类别的差异基因
type1 <- rownames(annotation_col)[annotation_col$cluster=='type1']
type1 <- expression_raw[[2]][,type1]
type2 <- rownames(annotation_col)[annotation_col$cluster=='type2']
type2 <- expression_raw[[2]][,type2]
type3 <- rownames(annotation_col)[annotation_col$cluster=='type3']
type3 <- expression_raw[[2]][,type3]


diff_gene <- list()
x <- cbind(a,b)[1,]
gene_change <- function(x){c(mean(as.numeric(x[1:ncol(a)])),
                             mean(as.numeric(x[(ncol(a)+1):ncol(b)])),
                             mean(as.numeric(x[1:ncol(a)]))/mean(as.numeric(x[(ncol(a)+1):ncol(b)])),
                             t.test(as.numeric(x[1:ncol(a)]),as.numeric(x[(ncol(a)+1):ncol(b)]))$p.value)}

diff_gene[[1]] <- data.frame(gene=rownames(expression_raw[[2]]))
for (i in 37766:nrow(expression_raw[[2]])) {
  diff_gene[[1]]$mean_type1[i] <- mean(as.numeric(type1[i,]))
  diff_gene[[1]]$mean_type2[i] <- mean(as.numeric(type2[i,]))
  diff_gene[[1]]$fold_change[i] <- mean(as.numeric(type1[i,]))/mean(as.numeric(type2[i,]))
  diff_gene[[1]]$p_value[i] <- t.test(as.numeric(type1[i,]),as.numeric(type2[i,]))$p.value
}
diff_gene[[2]] <- data.frame(gene=rownames(expression_raw[[2]]))
for (i in 1:nrow(expression_raw[[2]])) {
  diff_gene[[2]]$mean_type2[i] <- mean(as.numeric(type2[i,]))
  diff_gene[[2]]$mean_type3[i] <- mean(as.numeric(type3[i,]))
  diff_gene[[2]]$fold_change[i] <- mean(as.numeric(type2[i,]))/mean(as.numeric(type3[i,]))
  diff_gene[[2]]$p_value[i] <- t.test(as.numeric(type2[i,]),as.numeric(type3[i,]))$p.value
}
diff_gene[[3]] <- data.frame(gene=rownames(expression_raw[[2]]))
for (i in 1:nrow(expression_raw[[2]])) {
  diff_gene[[3]]$mean_type1[i] <- mean(as.numeric(type1[i,]))
  diff_gene[[3]]$mean_type3[i] <- mean(as.numeric(type3[i,]))
  diff_gene[[3]]$fold_change[i] <- mean(as.numeric(type1[i,]))/mean(as.numeric(type3[i,]))
  diff_gene[[3]]$p_value[i] <- t.test(as.numeric(type1[i,]),as.numeric(type3[i,]))$p.value
}
names(diff_gene) <- c('type1_type2','type2_type3','type1_type3')

for (i in 1:3) {
  diff_gene[[i]]$logFC <- log2(diff_gene[[i]]$fold_change)
  diff_gene[[i]]$padj <- p.adjust(diff_gene[[i]]$p_value,method = 'BH')
}
diff_gene_set <- list()
for (i in 1:3) {
  diff_gene_set[[i]] <- diff_gene[[i]][diff_gene[[i]]$padj<0.05&abs(diff_gene[[i]]$logFC)>1&
                                         !is.nan(diff_gene[[i]]$padj)&!is.nan(diff_gene[[i]]$logFC),]
  diff_gene_set[[i]] <- diff_gene_set[[i]][diff_gene_set[[i]][,2]>5|diff_gene_set[[i]][,3]>5,]
}
names(diff_gene_set) <- c('type1_type2','type2_type3','type1_type3')

#把差异基因和突变相互印证，找到相应的通路
library(clusterProfiler)
diff_pathway_KEGG <- list()
diff_pathway_GO <- list()
for (i in 1:3) {tryCatch({
  geneset_id <- bitr(diff_gene_set[[i]][,1],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                     toType = c('ENTREZID'), #totype指需要转换成的ID类型
                     OrgDb='org.Hs.eg.db')
  diff_pathway_KEGG[[i]] <- enrichKEGG(geneset_id[,2], #数据源
                                       organism = 'hsa', #物种
                                       keyType = 'kegg', #"kegg"/'ncbi-geneid'/'ncib-proteinid'/'uniprot'之一，KEGG就写kegg
                                       pvalueCutoff = 1,
                                       pAdjustMethod = 'BH',#P值校正方法
                                       qvalueCutoff = 1)
  diff_pathway_GO[[i]] <- enrichGO(geneset_id[,2], #数据源
                                   pvalueCutoff = 0.05, #P值阈值
                                   qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
                                   OrgDb = org.Hs.eg.db, #人类参考基因组
                                   ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
                                   readable = TRUE) #是否将基因ID转换为基因名
}, error = function(e) {print('error')})
}
names(diff_pathway_KEGG) <- c('type1_type2','type2_type3','type1_type3')
names(diff_pathway_GO) <- c('type1_type2','type2_type3','type1_type3')










##查看突变差异
b <- annotation_col
b$sample_id <- rownames(b)
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
type1_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='type1',4],]
type2_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='type2',4],]
type3_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%b[b$cluster=='type3',4],]
write.table(type1_mut,'result/BRCA/mutation/type1_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(type2_mut,'result/BRCA/mutation/type2_mut.maf',sep = '\t',quote = F,row.names = F)
write.table(type3_mut,'result/BRCA/mutation/type3_mut.maf',sep = '\t',quote = F,row.names = F)
type1_mut <- read.maf(maf ='result/BRCA/mutation/type1_mut.maf')
type2_mut <- read.maf(maf ='result/BRCA/mutation/type2_mut.maf')
type3_mut <- read.maf(maf ='result/BRCA/mutation/type3_mut.maf')

type1_mut_vs_type2_mut <- mafCompare(m1 = type1_mut, m2 = type2_mut, m1Name = 'type1', m2Name = 'type2', minMut = 2, useCNV =FALSE)
type2_mut_vs_type3_mut <- mafCompare(m1 = type2_mut, m2 = type3_mut, m1Name = 'type2', m2Name = 'type3', minMut = 2, useCNV =FALSE)
type1_mut_vs_type3_mut <- mafCompare(m1 = type1_mut, m2 = type3_mut, m1Name = 'type1', m2Name = 'type3', minMut = 2, useCNV =FALSE)

#EMT
###单样本GSEA处理EMT基因集
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

#单样本基因集富集分析
library(GSVA)
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

#单样本GSEA
library(GSVA)
geneset <- as.data.frame(EMT_gene$Gene)
colnames(geneset) <- 'EMT_score'
gs <- as.list(geneset)
a <- as.matrix(log2(expression_raw[[2]]+1))
ssgsea_score = gsva(a, 
                    gs, method = "ssgsea", 
                    kcdf="Gaussian",
                    ssgsea.norm = TRUE, 
                    verbose = TRUE)
ssgsea_score <- as.data.frame(t(ssgsea_score))
ssgsea_score$sample_id <- rownames(ssgsea_score)

a <- annotation_col
a$sample_id <- rownames(a)
b <- merge(a,ssgsea_score,by='sample_id',all=F)
a <- expression_raw[[2]][c('CDH2','VIM'),]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
##画图
plot1 <- b
plot1 <- ggplot(plot1, aes(x=cluster, y=EMT_score,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('type1','type2'),c('type1','type3'),c('type2','type3')), 
              map_signif_level = TRUE, test = t.test, y_position = c(2.5,2.8,2.5),
              tip_length = c(0.1,0.1,0.1))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8D.pdf',sep = ''), width=5, height=5)
print(plot1,newpage = F)
dev.off()

plot2 <- b
plot2 <- ggplot(plot2, aes(x=cluster, y=CDH2,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('type1','type2'),c('type1','type3'),c('type2','type3')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8,9,8),
              tip_length = c(0.1,0.1,0.1))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8D2.pdf',sep = ''), width=5, height=5)
print(plot2,newpage = F)
dev.off()

plot3 <- b
plot3 <- ggplot(plot3, aes(x=cluster, y=VIM,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('type1','type2'),c('type1','type3'),c('type2','type3')), 
              map_signif_level = TRUE, test = t.test, y_position = c(13,14,13),
              tip_length = c(0.1,0.1,0.1))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8D3.pdf',sep = ''), width=5, height=5)
print(plot3,newpage = F)
dev.off()

#等会儿用KS检验再验证一下

#
r1 <- type1_mut_vs_type2_mut$results
g0 <- r1[1:40,Hugo_Symbol]
g1 <- r1[1:40,Hugo_Symbol]
l <- length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8E.pdf',sep = ''), width=15, height=10)
coOncoplot(m1 = type1_mut, m2 = type2_mut, m1Name = 'type1_mut', m2Name = 'type2_mut', genes = g, removeNonMutated = T)
dev.off()

r1 <- type2_mut_vs_type3_mut$results
g0 <- r1[1:40,Hugo_Symbol]
g1 <- r1[1:40,Hugo_Symbol]
l <- length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8E2.pdf',sep = ''), width=15, height=10)
coOncoplot(m1 = type2_mut, m2 = type3_mut, m1Name = 'type2_mut', m2Name = 'type3_mut', genes = g, removeNonMutated = T)
dev.off()

r1 <- type1_mut_vs_type3_mut$results
g0 <- r1[1:40,Hugo_Symbol]
g1 <- r1[1:40,Hugo_Symbol]
l <- length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8E3.pdf',sep = ''), width=15, height=10)
coOncoplot(m1 = type1_mut, m2 = type3_mut, m1Name = 'type1_mut', m2Name = 'type3_mut', genes = g, removeNonMutated = T)
dev.off()

TMB <- list()
TMB[[1]] <- tmb(maf = type1_mut)
TMB[[2]] <- tmb(maf = type2_mut)
TMB[[3]] <- tmb(maf = type3_mut)
names(TMB) <- c('type1_mut','type2_mut','type3_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('type1_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('type2_mut',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('type3_mut',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- as.factor(TMB_plot$cluster)

library(ggplot2)
library(ggpubr)
p = ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) + 
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)
p+geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.5,)+
  stat_compare_means(method = "t.test" )

ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) + 
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,fill='grey')+
  geom_jitter(aes(color=cluster),shape=16, position = position_jitter(0.3))+
  stat_compare_means(method = "t.test" )
plot <- ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('type1_mut','type2_mut'),c('type1_mut','type3_mut'),c('type2_mut','type3_mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(7,8,7),
              tip_length = c(0.1,0.1,0.1))#5cm*4cm

pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8F1.pdf',sep = ''), width=5, height=5)
print(plot,newpage = F)
dev.off()

#fig8G
#通路富集

#######################分析所有癌症，看看基于生存分析得到的网络是否都能表现出这种性质
#获取HUB基因集
#1去除网络计算结果中的RNA等
library(clusterProfiler)
surv_data_clean <- list()
gene_protein <- read.csv('/database/gene_name_id_data/gene_protein_ID.txt',header = T)
gene_protein <- gene_protein[gene_protein[,3]!='',]
for (i in 1:15) {
  surv_data_clean[[i]] <- list()
  for (j in 1:3) {
    surv_data_clean[[i]][[j]] <- surv_data[[i]][[j]]
    surv_data_clean[[i]][[j]] <- surv_data_clean[[i]][[j]][rownames(surv_data_clean[[i]][[j]])%in%unique(gene_protein$Gene.name),]
  }
  names(surv_data_clean[[i]]) <- c('surv_t','surv_up','surv_down')
}
names(surv_data_clean) <- cancer_name

#计算显著基因
library(grid)
cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data_V2 <- list()
surv_data_sig_V2 <- list()
for (j in 1:length(cancer_name)) {
  # surv_data[[j]] <- list()
  # names(surv_data)[j] <- cancer_name[j]
  # surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  # surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  # surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  # names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- apply(surv_data_clean[[j]][[1]], 2, max)
  b <- surv_data_clean[[j]][[1]][,which.max(a[a!=0])]
  surv_data_sig_V2[[j]] <- surv_data_clean[[j]]
  surv_data_sig_V2[[j]][[1]] <- surv_data_sig_V2[[j]][[1]][which(surv_data_sig_V2[[j]][[1]][,which.max(a[a!=0])] >= 0.8),]
  surv_data_sig_V2[[j]][[2]] <- surv_data_sig_V2[[j]][[2]][which(surv_data_sig_V2[[j]][[2]][,which.max(a[a!=0])] >= min(surv_data_sig_V2[[j]][[1]][,which.max(a[a!=0])])),]
  surv_data_sig_V2[[j]][[3]] <- surv_data_sig_V2[[j]][[3]][which(surv_data_sig_V2[[j]][[3]][,which.max(a[a!=0])] >= min(surv_data_sig_V2[[j]][[1]][,which.max(a[a!=0])])),]
}##读取数据以及计算sig_gene
names(surv_data_sig_V2) <- cancer_name



#构建生存基因网络
gene_protein <- read.csv('/database/gene_name_id_data/gene_protein_ID.txt',header = T)
gene_protein <- gene_protein[gene_protein[,3]!='',]

surv_raw_data_V2 <- list()
result <- list()
surv_sig_inter_V2 <- list()
surv_sig_dgree_V2 <- list()
# for (i in 1:length(cancer_name)) {
#   file_name <- dir(paste('result/',cancer_name[i],'/raw_data',sep = ''))
#   a <- which.min(which(apply(surv_data_sig_V2[[i]][[1]], 2, min)>0.1))
#   print(file_name[[a]])
# }
similar_value <- function(value){length(which(which(value==1)%in%which(a1==1)))/((length(which(a1==1))+length(which(value==1)))-2*length(which(which(a1==1)%in%which(value==1)))+1)}
# similar_value_all <- function(ob){
#     a1 <- ob
#     a2 <- surv_raw_data_V2[[i]]
#     apply(a2, 1, similar_value)
# }


length(cancer_name)
for (i in c(1:15)) {
  file_name <- dir(paste('result/',cancer_name[i],'/raw_data',sep = ''))
  a <- which.min(which(apply(surv_data_sig_V2[[i]][[1]], 2, min)>0.1))
  surv_raw_data_V2[[i]] <- read.csv(paste('result/',cancer_name[i],'/raw_data/',file_name[[a]],sep = ''),row.names = 1,header = T)
  surv_raw_data_V2[[i]] <- surv_raw_data_V2[[i]][rownames(surv_raw_data_V2[[i]])%in%unique(gene_protein$Gene.name),]
  surv_raw_data_V2[[i]] <- as.matrix(surv_raw_data_V2[[i]])
  surv_raw_data_V2[[i]][surv_raw_data_V2[[i]]>=0.05] <- 0
  surv_raw_data_V2[[i]][surv_raw_data_V2[[i]]!=0] <- 1
  a <- surv_raw_data_V2[[i]][rownames(surv_raw_data_V2[[i]])%in%rownames(surv_data_sig_V2[[i]][[1]]),]
  result[[i]] <- data.frame(row.names = rownames(surv_raw_data_V2[[i]]))
  # c <- apply(a[1:2,], 1, similar_value_all)
  for (x in 1:nrow(a)) {
    a1 <- a[x,]
    a2 <- surv_raw_data_V2[[i]]
    result[[i]][,x] <- apply(a2, 1, similar_value)
  }
  #   for (j in 1:nrow(surv_raw_data_V2[[i]])) {
  #     result[[i]][j,x] <- length(which(which(surv_raw_data_V2[[i]][j,]==1)%in%which(a[x,]==1)))/((length(which(a[x,]==1))+length(which(surv_raw_data_V2[[i]][j,]==1)))-2*length(which(which(a[x,]==1)%in%which(surv_raw_data_V2[[i]][j,]==1)))+1)
  #   }
  # }
  # for (x in 1:nrow(a)) {
  #   a1 <- a[x,]
  #   a2 <- surv_raw_data_V2[[i]]
  #   apply(array, margin, ...)
  #   for (j in 1:nrow(surv_raw_data_V2[[i]])) {
  #     result[[i]][j,x] <- length(which(which(surv_raw_data_V2[[i]][j,]==1)%in%which(a[x,]==1)))/((length(which(a[x,]==1))+length(which(surv_raw_data_V2[[i]][j,]==1)))-2*length(which(which(a[x,]==1)%in%which(surv_raw_data_V2[[i]][j,]==1)))+1)
  #   }
  # }
  # rownames(result[[i]]) <- rownames(surv_raw_data_V2[[i]])
  colnames(result[[i]]) <- rownames(a)
  result_matrix <- as.matrix(result[[i]])
  a <- seq(0.01,1,0.01)
  b <- data.frame()
  for (x in 1:100) {
    b[x,1] <- a[x]
    b[x,2] <- length(which(result_matrix>a[x]))-ncol(result_matrix)
  }
  plot(b)
  surv_sig_inter_V2[[i]] <- data.frame()
  for (x in 1:ncol(result[[i]])) {
    # a <- which(result[[i]][,x]>=max(b[which(b[,2]>=2000),1]))##此处还需更改，应当需要一个合适的数字
    a <- 1:length(result[[i]][,x])
    n <- nrow(surv_sig_inter_V2[[i]])
    surv_sig_inter_V2[[i]][(n+1):(n+length(a)),1] <- rep(colnames(result[[i]])[x],length(a))
    surv_sig_inter_V2[[i]][(n+1):(n+length(a)),2] <- result[[i]][a,x]
    surv_sig_inter_V2[[i]][(n+1):(n+length(a)),3] <- rownames(result[[i]])[a]
  }
  a <- character()
  b <- character()
  paste_all <- function(ob){paste0(ob,collapse = '')}
  a <- apply(surv_sig_inter_V2[[i]][,1:3], 1, paste_all)
  b <- apply(surv_sig_inter_V2[[i]][,3:1], 1, paste_all)
  # for (x in 1:nrow(surv_sig_inter_V2[[i]])) {
  #   a[x] <- paste0(surv_sig_inter_V2[[i]][x,1:3],collapse = '')
  #   b[x] <- paste0(surv_sig_inter_V2[[i]][x,3:1],collapse = '')
  # }
  c <- surv_sig_inter_V2[[i]][!b%in%a,]
  d <- surv_sig_inter_V2[[i]][b%in%a,]
  e <- unique(d$V1)
  f <- as.data.frame(t(data.frame(row.names = colnames(c))))
  colnames(f) <- colnames(c)
  for (x in 1:length(e)) {
    f <- rbind(f,d[d[,1]==e[x],])
    d <- d[d[,3]!=e[x],]
  }
  c <- rbind(c,f)
  surv_sig_inter_V2[[i]] <- c
  surv_sig_inter_V2[[i]][surv_sig_inter_V2[[i]][,1]==surv_sig_inter_V2[[i]][,3],2] <- 0
  # for (x in 1:nrow(surv_sig_inter_V2[[i]])) {
  #   ifelse(surv_sig_inter_V2[[i]][x,1]==surv_sig_inter_V2[[i]][x,3],surv_sig_inter_V2[[i]][x,2] <- 0,0)
  # }
  surv_sig_inter_V2[[i]] <- surv_sig_inter_V2[[i]][surv_sig_inter_V2[[i]][,2]!=0,]
  surv_sig_inter_V2[[i]] <- surv_sig_inter_V2[[i]][order(surv_sig_inter_V2[[i]][,2],decreasing = T),]
  surv_sig_inter_V2[[i]] <- surv_sig_inter_V2[[i]][surv_sig_inter_V2[[i]][,2]>=surv_sig_inter_V2[[i]][15000,2],]
  b <- surv_sig_inter_V2[[i]][,3:1]
  colnames(b) <- colnames(surv_sig_inter_V2[[i]])
  b <- rbind(surv_sig_inter_V2[[i]][,1:3],b)
  
  a <- unique(c(surv_sig_inter_V2[[i]][,1],surv_sig_inter_V2[[i]][,3]))
  surv_sig_dgree_V2[[i]] <- data.frame(a)
  sum_dgree <- function(ob){sum(b[,1]==ob)}
  surv_sig_dgree_V2[[i]][,2] <- apply(surv_sig_dgree_V2[[i]], 1, sum_dgree)
  # for (x in 1:length(a)) {
  #   surv_sig_dgree_V2[[i]][x,1] <- a[x]
  #   surv_sig_dgree_V2[[i]][x,2] <- sum(b[,1]==a[x])
  # }
  surv_sig_dgree_V2[[i]] <- surv_sig_dgree_V2[[i]][order(surv_sig_dgree_V2[[i]][,2],decreasing = T),]
  
  write.csv(surv_sig_inter_V2[[i]],paste('result/network/raw_data/',cancer_name[i],'_surv_sig_inter.csv',sep = ''),quote = F,row.names = F)
  write.csv(surv_sig_dgree_V2[[i]],paste('result/network/raw_data/',cancer_name[i],'_surv_sig_dgree.csv',sep = ''),quote = F,row.names = F)
  write.csv(result[[i]],paste('result/network/raw_data/',cancer_name[i],'_surv_sig_result.csv',sep = ''),quote = F)
  surv_raw_data_V2[[i]] <- data.frame()
  result[[i]] <- data.frame()
  a <- data.frame()
  b <- data.frame()
  c <- data.frame()
}

names(surv_sig_inter_V2) <- cancer_name
names(surv_sig_dgree_V2) <- cancer_name
names(result) <- cancer_name





##以上用服务器计算完成
surv_sig_inter_V2 <- list()
surv_sig_dgree_V2 <- list()
for (i in 1:15) {
  surv_sig_inter_V2[[i]] <- read.csv(paste('result/network/raw_data/',cancer_name[i],'_surv_sig_inter.csv',sep = ''))
  surv_sig_dgree_V2[[i]] <- read.csv(paste('result/network/raw_data/',cancer_name[i],'_surv_sig_dgree.csv',sep = ''))
}
names(surv_sig_inter_V2) <- cancer_name
names(surv_sig_dgree_V2) <- cancer_name

#计算hub基因
hub_gene <- list()
# hub_type <- read.csv('',)
for (i in 1:15) {
  a <- surv_sig_inter_V2[[i]]
  colnames(a) <- c('gene1','value','gene2')
  b <- a[,3:1]
  colnames(b) <- c('gene1','value','gene2')
  a <- rbind(a,b)
  gene <- unique(a$gene1)
  b <- data.frame(1:length(gene))
  for (j in 1:length(gene)) {
    k1 <- a$gene2[a$gene1%in%gene[j]]
    k2 <- a$gene2[a$gene1%in%k1]
    k3 <- a$gene2[a$gene1%in%k2]
    b[j,2] <- length(unique(c(k1,k2,k3)))
    b[j,3] <- sum(a$gene1%in%gene[j])
  }
  b[,1] <- gene
  colnames(b) <- c('gene','k3','degree')
  b <- b[b$gene%in%rownames(surv_data_sig_V2[[i]][[1]]),]
  b <- b[order(b$k3,decreasing = T),]
  a <- which.min(which(apply(surv_data_sig_V2[[i]][[1]], 2, min)>0.1))
  a <- as.data.frame(cbind(rownames(surv_data_sig_V2[[i]][[1]]),surv_data_sig_V2[[i]][[1]][,a]))
  colnames(a) <- c('gene','surv_sig_p')
  b <- merge(b,a,by='gene',all=F)
  b <- b[order(b$k3,decreasing = T)[1:10],]
  # b <- b[b$k3>=median(b$k3)&b$degree>=median(b$degree),]
  hub_gene[[i]] <- b
}
names(hub_gene) <- cancer_name
#使用hub基因聚类
library(ggplot2)
library(clusterProfiler)
library(survival)
library(survminer)
for (i in 1:15) {
  data <- as.matrix(t(expression[[i]][which(rownames(expression[[i]])%in%hub_gene[[i]][,1]),]))
  for (j in 1:ncol(data)) {
    data[,j] <- scale(as.numeric(data[,j]))
  }
  dist.e <- dist(data,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=3)#分类
  result <- as.data.frame(result)
  paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
  a <- cbind(rownames(result),result)
  # colnames(a)[1] <- colnames(BRCA_subtype)[1]
  # a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
  b <- a[,1]
  a <- as.data.frame(a[,-1])
  rownames(a) <- b
  colnames(a) <- c('cluster')
  result <- a
  annotation_col <- result
  annotation_col[annotation_col[,1]==1,1] <- 'type1'
  annotation_col[annotation_col[,1]==2,1] <- 'type2'
  annotation_col[annotation_col[,1]==3,1] <- 'type3'
  
  a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type3'],])#4cm*8cm
  a <- t(a)
  # a <- log2(t(a)+1)
  bk = unique(c(seq(-3,3, length=200)))
  ann_colors = list(cluster = c(type1 = "blue",type2 = "#F2CA20", type3 = "#E24A0E")) 
  # a <- t(data)
  plot1 <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                              kmeans_k = 3,
                              annotation_colors = ann_colors,
                              clustering_method = 'ward.D2', 
                              color = c(colorRampPalette(c("navy", "white"))(100),
                                        colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                              cluster_cols = F,cluster_rows = T,
                              annotation_col = annotation_col,
                              breaks = bk)#5*8
  pdf(paste('result/network/cluster_heatmap/',cancer_name[i],'_hot.pdf',sep = ''), width=9, height=10)
  grid.draw(plot1)
  dev.off()
  
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(annotation_col),]
  b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'type1'
  b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'type2'
  b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'type3'
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Follow up time(d)", # 指定x轴标签
                     legend = c(0.8,0.75),         # 指定图例位置
                     title = cancer_name[i],                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 365,# 设置x轴刻度间距
                     pval.method=T)
  
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
                          type = c("blue","#F2CA20","#E24A0E"),
                          labels = c('type1','type2','type3'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/network/cluster_heatmap/',cancer_name[i],'_surv.pdf',sep = ''), width=7, height=5)
  grid.draw(plot2)
  dev.off()
}#
for (i in 1:15) {
  data <- as.matrix(t(expression[[i]][which(rownames(expression[[i]])%in%hub_gene[[i]][,1]),]))
  for (j in 1:ncol(data)) {
    data[,j] <- scale(as.numeric(data[,j]))
  }
  a <- kmeans(data,centers = 3)
  result <- as.data.frame(a$cluster)#分类
  paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
  a <- cbind(rownames(result),result)
  # colnames(a)[1] <- colnames(BRCA_subtype)[1]
  # a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
  b <- a[,1]
  a <- as.data.frame(a[,-1])
  rownames(a) <- b
  colnames(a) <- c('cluster')
  result <- a
  annotation_col <- result
  annotation_col[annotation_col[,1]==1,1] <- 'type1'
  annotation_col[annotation_col[,1]==2,1] <- 'type2'
  annotation_col[annotation_col[,1]==3,1] <- 'type3'
  
  a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type3'],])#4cm*8cm
  a <- t(a)
  # a <- log2(t(a)+1)
  bk = unique(c(seq(-3,3, length=200)))
  ann_colors = list(cluster = c(type1 = "blue",type2 = "#F2CA20", type3 = "#E24A0E")) 
  # a <- t(data)
  plot1 <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                              annotation_colors = ann_colors,
                              clustering_method = 'ward.D2', 
                              color = c(colorRampPalette(c("navy", "white"))(100),
                                        colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                              cluster_cols = F,cluster_rows = T,
                              annotation_col = annotation_col,
                              breaks = bk)#5*8
  pdf(paste('result/network/cluster_heatmap/',cancer_name[i],'_hot.pdf',sep = ''), width=9, height=10)
  grid.draw(plot1)
  dev.off()
  
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(annotation_col),]
  b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'type1'
  b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'type2'
  b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'type3'
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Follow up time(d)", # 指定x轴标签
                     legend = c(0.8,0.75),         # 指定图例位置
                     title = cancer_name[i],                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 365,# 设置x轴刻度间距
                     pval.method=T)
  
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
                          type = c("blue","#F2CA20","#E24A0E"),
                          labels = c('type1','type2','type3'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/network/cluster_heatmap/',cancer_name[i],'_surv.pdf',sep = ''), width=7, height=5)
  grid.draw(plot2)
  dev.off()
}#2





network_type <- read.csv()
#使用hub基因聚类
library(ggplot2)
library(clusterProfiler)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%a),]))
for (i in 1:ncol(data)) {
  data[,i] <- scale(as.numeric(data[,i]))
}
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'type1'
annotation_col[annotation_col[,1]==2,1] <- 'type2'
annotation_col[annotation_col[,1]==3,1] <- 'type3'

a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='type3'],])#4cm*8cm
a <- t(a)
# a <- log2(t(a)+1)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(cluster = c(type1 = "blue",type2 = "#F2CA20", type3 = "#E24A0E")) 
# a <- t(data)
plot <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                           annotation_colors = ann_colors,
                           clustering_method = 'ward.D2', 
                           color = c(colorRampPalette(c("navy", "white"))(100),
                                     colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                           cluster_cols = F,cluster_rows = T,
                           annotation_col = annotation_col,
                           breaks = bk)#5*8
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8A.pdf',sep = ''), width=9, height=5)
grid.draw(plot)
dev.off()





###################################从头开始画图
####读取算到的数据

##extract top1000
for (i in 1:15) {
  surv_sig_inter[[i]] <- read.csv(paste('result/',cancer_name[i],'/inter_probality/surv_sig_inter_new.csv',sep = ''),header = T)
  a <- surv_sig_inter[[i]][order(surv_sig_inter[[i]][,2],decreasing = T)[1000],2]
  surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]>=a,]
}
# surv_sig_inter[[3]] <- read.csv('result/CESC/inter_probality/surv_sig_inter_new.csv')
for (i in 1:15) {
  a <- surv_sig_inter[[i]][,1][!duplicated(surv_sig_inter[[i]][,1])]
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- length(which(surv_sig_inter[[i]][,1]==a[x]))
  }
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
  write.csv(surv_sig_dgree[[i]],paste('result/',cancer_name[i],'/inter_probality/surv_sig_dgree_new.csv',sep = ''),quote = F,row.names = F)
}
########figure1
##
##双柱状图
##获取批量生存分析的每个基因标签
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据

library(survival)
library(survminer)
HR_all <- list()
surv_p_all <- list()
for (x in 10:15) {
  HR_all[[x]] <- data.frame()
  surv_p_all[[x]] <- data.frame()
  b <- lifetime_all[[x]][lifetime_all[[x]][,6] %in% colnames(expression[[x]]),]
  for (j in 1:nrow(expression[[x]])) {
    tryCatch({a <- expression[[x]][j,]
    b[b[,6]%in%colnames(expression[[x]])[which(a <= median(as.numeric(a)))],7] <- 'low'
    b[b[,6]%in%colnames(expression[[x]])[which(a > median(as.numeric(a)))],7] <- 'high'
    c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
    surv_p_all[[x]][j,1] <- 1-pchisq(c$chisq,1)
    HR_all[[x]][j,1] <- (c$obs[2]/c$exp[2])/(c$obs[1]/c$exp[1])},warning = function(w){
      print('warning')}, error = function(e){surv_p_all[[x]][j,1] <- 1
      HR_all[[x]][j,1] <- 1
      print('error')})
  }
  rownames(surv_p_all[[x]]) <- rownames(expression[[x]])
  rownames(HR_all[[x]]) <- rownames(expression[[x]])
}


names(surv_p_all) <- cancer_name
names(HR_all) <- cancer_name
for (i in 1:15) {
  surv_p_all[[i]][is.na(surv_p_all[[i]][,1]),1] <- 1
  surv_p_all[[i]][surv_p_all[[i]][,1]<0.05,2] <- 'sig'
  surv_p_all[[i]][surv_p_all[[i]][,1]>=0.05,2] <- 'non-sig'
}

##画柱状图
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
for (i in 1:15) {
  A <- surv_data[[i]][[1]]
  for (j in 1:ncol(A)) {
    colnames(A)[j] <- as.character(substring(colnames(A)[j],2,nchar(colnames(A)[j])))
  }
  A$group <- surv_p_all[[i]][,2]
  A$Gene <- rownames(A)
  A <- pivot_longer(data = A,cols = 1:(dim(A)[2]-2),
                    names_to = "Type",values_to = "count")
  str_sort(unique(A$Type),numeric = T)
  A$Type <- factor(A$Type, levels = str_sort(unique(A$Type),numeric = T))
  A$Type <- as.factor(A$Type)
  A$Type <- fct_inorder(A$Type)
  A$group <- factor(A$group,levels = c('non-sig','sig'))
  # A$group <- fct_inorder(A$group)
  
  plot <- ggplot(A, aes(fill=group, y=count, x=Type))+
    geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
    theme_classic(base_size = 12)+
    theme(legend.direction = "horizontal", legend.position = "top")+
    labs(title = "", y="Surv-sig rate ", x = "Sample Size")+
    stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
                 width = 0.5,position = position_dodge(1))+
    scale_y_continuous(limits = c(0,1),expand = c(0,0))+
    theme(axis.text.x = element_text(size = 12))+
    theme(axis.text.y = element_text(size = 12))+
    theme(axis.title = element_text(size = 14))
  pdf(paste('result/Figure/AI_plot_new/fig1/V4/s_fig1/',cancer_name[i],'.pdf',sep = ''), width=6, height=5)
  print(plot,newpage = FALSE)
  dev.off()
}

##画折线图
sig_gene_num <- data.frame()
sig_gene_max <- data.frame()
sig_gene_add <- data.frame()
for (i in 1:15) {
  for (j in 1:10) {
    sig_gene_num[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8))
    sig_gene_max[i,j] <- max(surv_data[[i]][[1]][,j])
    ifelse(j==1,sig_gene_add[i,j] <- length(which(surv_data[[i]][[1]][,j]>=0.8)),
           sig_gene_add[i,j] <- (length(which(surv_data[[i]][[1]][,j]>=0.8))-sig_gene_add[i,j-1]))
  }
}
rownames(sig_gene_num) <- cancer_name
colnames(sig_gene_num) <- c(seq(0.1,1,0.1))
rownames(sig_gene_max) <- cancer_name
colnames(sig_gene_max) <- c(seq(0.1,1,0.1))
rownames(sig_gene_add) <- cancer_name
colnames(sig_gene_add) <- c(seq(0.1,1,0.1))

sig_gene_num$cancer_name <- rownames(sig_gene_num)
sig_gene_num <- pivot_longer(data = sig_gene_num,cols = 1:(dim(sig_gene_num)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_num$cancer_name <- factor(sig_gene_num$cancer_name, levels = str_sort(unique(sig_gene_num$cancer_name),numeric = T))
sig_gene_num$cancer_name <- as.factor(sig_gene_num$cancer_name)

sig_gene_max$cancer_name <- rownames(sig_gene_max)
sig_gene_max <- pivot_longer(data = sig_gene_max,cols = 1:(dim(sig_gene_max)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_max$cancer_name <- factor(sig_gene_max$cancer_name, levels = str_sort(unique(sig_gene_max$cancer_name),numeric = T))
sig_gene_max$cancer_name <- as.factor(sig_gene_max$cancer_name)

sig_gene_add$cancer_name <- rownames(sig_gene_add)
sig_gene_add <- pivot_longer(data = sig_gene_add,cols = 1:(dim(sig_gene_add)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_add$cancer_name <- factor(sig_gene_add$cancer_name, levels = str_sort(unique(sig_gene_add$cancer_name),numeric = T))
sig_gene_add$cancer_name <- as.factor(sig_gene_add$cancer_name)

plot <- ggplot(sig_gene_max, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  theme_base()+
  geom_line(size=1)#size是线的宽度
# ggplot(sig_gene_add, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
#   geom_line(size=1)#size是线的宽度
pdf(paste('result/Figure/AI_plot_new/fig1/V4/fig1C.pdf',sep = ''), width=7, height=5)
print(plot,newpage = FALSE)
dev.off()

#####fig2
####fig2C排版
####富集通路
library(clusterProfiler)
library(stringr)

cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
surv_data <- list()
surv_data_sig <- list()
for (j in 1:length(cancer_name)) {
  surv_data[[j]] <- list()
  names(surv_data)[j] <- cancer_name[j]
  surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
  surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
  surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
  names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
  a <- apply(surv_data[[j]][[1]], 2, max)
  b <- surv_data[[j]][[1]][,which.max(a[a!=0])]
  surv_data_sig[[j]] <- surv_data[[j]]
  surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which.max(a[a!=0])] >= 0.8),]
  surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
  surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
}##读取数据以及计算sig_gene
names(surv_data_sig) <- cancer_name
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- rownames(surv_data_sig[[i]][[1]])
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}
names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
sig_pathway_plot_all <- surv_sig_pathway
sig_pathway_plot_all@compareClusterResult <- sig_pathway_plot_all@compareClusterResult[sig_pathway_plot_all@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
a <- sig_pathway_plot_all@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(7,8,6,2,15,11,5,3,9,1)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_all
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(7,8,6,2,15,11,5,3,9,1)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(7,8,6,2,15,11,5,3,9,1)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 70)

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]
# write.csv(annotation_col,'result/Figure/AI_plot_new/fig2/v2/pathway_annotation.csv',row.names = F)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/pathway_annotation.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='others',3] <- 'black'
y_color[y_color[,2]=='mitotic',3] <- 'red'
y_color[y_color[,2]=='immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
# y_color$color <- factor(y_color$color,levels = c('black','red','blue'))
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))


a <- as.vector(y_color$type)
a <-as.vector(y_color$pathway)[c(which(a=='others'),
                                 which(a=='immune'),
                                 which(a=='mitotic'))]
plot$data$Description <- factor(plot$data$Description,levels = a)

pdf(paste('result/Figure/AI_plot_new/fig2/V4/fig2A.pdf',sep = ''), width=12, height=10)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='others'),
                                                           which(y_color$type=='immune'),
                                                           which(y_color$type=='mitotic'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=c("red","blue","black"))#10cm*12cm
dev.off()


####fig2C
##对网络top10进行富集（dotplot）
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- surv_sig_dgree[[i]][1:10,1]
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}

names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
##提取指定层次的通路进行绘制通路图
sig_pathway_plot_top10 <- surv_sig_pathway
sig_pathway_plot_top10@compareClusterResult <- sig_pathway_plot_top10@compareClusterResult[sig_pathway_plot_top10@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_top10,showCategory=5,includeAll=TRUE,label_format = 70)
a <- sig_pathway_plot_top10@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(2,15,7,8,6)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_top10
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(2,15,7,8,6)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(2,15,7,8,6,11,5,3,9,1)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 35)
write.csv(a@compareClusterResult,'result/Figure/AI_plot_new/fig2/v2/annotation_top10.csv')

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]

# write.csv(annotation_col,'result/Figure/AI_plot_new/fig2/v2/pathway_annotation_top10.csv',row.names = F)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/pathway_annotation_top10.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='others',3] <- 'black'
y_color[y_color[,2]=='mitotic',3] <- 'red'
y_color[y_color[,2]=='immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

a <- as.vector(y_color$type)
a <-as.vector(y_color$pathway)[c(which(a=='others'),
                                 which(a=='mitotic'),
                                 which(a=='immune'))]
plot$data$Description <- factor(plot$data$Description,levels = a)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='others'),
                                                           which(y_color$type=='mitotic'),
                                                           which(y_color$type=='immune'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=y_color$color[!duplicated(y_color$color)])#6cm*8cm

##ggplot2画sankey图
####top10sankey plot

annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v2/annotation_top10.csv')
b <- annotation_col[,c(1,2,4)]
b <- b[c(which(b$X=='mitotic'),which(b$X=='immune'),which(b$X=='others')),]
b$weight <- 1
library("ggplot2")
library("ggalluvial")
colnames(b) <- c('pathway','cancer_type','pathway_name','weight')
b$cohort <- 1:nrow(b)
b <- pivot_longer(data = b[,c(1,2,5)],cols = 1:2,
                  names_to = "feature",##这一个参数是将列名命名为sample_size
                  values_to = "nodes")##col
b$nodes <- factor(b$nodes,levels = c(unique(b$nodes)[c(3,2,4,6,7,1,5,8)]))
mycol <- c("#F29530","#F29530","#F29530","#4FAAC8","#4FAAC8",'red','#245BAA','#D9D9D9')
plot <- ggplot(b,aes(x = feature, stratum = nodes, alluvium = cohort,
                     fill = nodes, label = nodes)) +
  scale_x_discrete(expand = c(0, 0)) + 
  geom_flow(width = 1/8) + #线跟方块间空隙的宽窄 
  geom_stratum(alpha = 1,width = 2/10) + #方块的透明度、宽度
  geom_text(stat = "stratum", size = 3,color="white") + #文字大小、颜色
  #不喜欢默认的配色方案，用前面自己写的配色方案
  scale_fill_manual(values = mycol) +
  xlab("") + ylab("") +
  theme_bw() + #去除背景色
  theme(panel.grid =element_blank()) + #去除网格线
  theme(panel.border = element_blank()) + #去除外层边框
  theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text = element_blank()) + #去掉坐标轴
  ggtitle("")+
  guides(fill = FALSE) #5cm*7cm

pdf(paste('result/Figure/AI_plot_new/fig2/V4/fig2C.pdf',sep = ''), width=7, height=5)
print(plot,newpage = F)
dev.off()


##修正数据
###################################从头开始画图
####读取算到的数据
#1去除网络计算结果中的RNA等
library(clusterProfiler)
surv_data_clean <- list()
expression <- list()
gene_protein <- read.csv('/database/gene_name_id_data/gene_protein_ID.txt',header = T)
gene_protein <- gene_protein[gene_protein[,3]!='',]
for (i in 1:15) {
  surv_data_clean[[i]] <- list()
  for (j in 1:3) {
    surv_data_clean[[i]][[j]] <- surv_data[[i]][[j]]
    surv_data_clean[[i]][[j]] <- surv_data_clean[[i]][[j]][rownames(surv_data_clean[[i]][[j]])%in%unique(gene_protein$Gene.name),]
  }
  names(surv_data_clean[[i]]) <- c('surv_t','surv_up','surv_down')
  expression[[i]] <- expression_raw[[i]]
  expression[[i]] <- expression[[i]][rownames(expression[[i]])%in%unique(gene_protein$Gene.name),]
}
names(surv_data_clean) <- cancer_name
names(expression) <- cancer_name

##extract top1000
surv_sig_inter <- list()
for (i in 1:15) {
  surv_sig_inter[[i]] <- read.csv(paste('result/network/raw_data/',cancer_name[i],'_surv_sig_inter.csv',sep = ''),header = T)
  colnames(surv_sig_inter[[i]]) <- c('gene1','value','gene2')
  a <- surv_sig_inter[[i]][order(surv_sig_inter[[i]][,2],decreasing = T)[1000],2]
  surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]>=a,]
  write.csv(surv_sig_inter[[i]],paste('result/network/top1000/',cancer_name[i],'_surv_sig_inter_top1000.csv',sep = ''),quote = F,row.names = F)
}
names(surv_sig_inter) <- cancer_name
# surv_sig_inter[[3]] <- read.csv('result/CESC/inter_probality/surv_sig_inter_new.csv')
#计算度
hub_gene <- list()
surv_sig_dgree <- list()
for (i in 1:15) {
  a <- unique(c(surv_sig_inter[[i]][,1],surv_sig_inter[[i]][,3]))
  b <- c(surv_sig_inter[[i]][,1],surv_sig_inter[[i]][,3])
  surv_sig_dgree[[i]] <- data.frame()
  for (x in 1:length(a)) {
    surv_sig_dgree[[i]][x,1] <- a[x]
    surv_sig_dgree[[i]][x,2] <- sum(b==a[x])
  }
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
  surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][surv_sig_dgree[[i]][,1]%in%rownames(surv_data_sig[[i]][[1]]),]
  colnames(surv_sig_dgree[[i]]) <- c('gene','degree')
  a <- surv_sig_dgree[[i]][surv_sig_dgree[[i]][,1]%in%rownames(expression[[i]])[apply(expression[[i]], 1, mean)>10],]
  a <- a[a[,1]%in%rownames(surv_data_sig[[i]][[1]]),]
  hub_gene[[i]] <- a[1:10,]
  write.csv(surv_sig_dgree[[i]],paste('result/network/top1000/',cancer_name[i],'_surv_sig_dgree.csv',sep = ''),quote = F,row.names = F)
}
names(surv_sig_dgree) <- cancer_name
names(hub_gene) <- cancer_name
########figure1
##
##双柱状图
##获取批量生存分析的每个基因标签
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据

library(survival)
library(survminer)
HR_all <- list()
surv_p_all <- list()
for (x in 1:15) {
  HR_all[[x]] <- data.frame()
  surv_p_all[[x]] <- data.frame()
  b <- lifetime_all[[x]][lifetime_all[[x]][,6] %in% colnames(expression[[x]]),]
  for (j in 1:nrow(expression[[x]])) {
    tryCatch({a <- expression[[x]][j,]
    b[b[,6]%in%colnames(expression[[x]])[which(a <= median(as.numeric(a)))],7] <- 'low'
    b[b[,6]%in%colnames(expression[[x]])[which(a > median(as.numeric(a)))],7] <- 'high'
    c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
    surv_p_all[[x]][j,1] <- 1-pchisq(c$chisq,1)
    HR_all[[x]][j,1] <- (c$obs[2]/c$exp[2])/(c$obs[1]/c$exp[1])},warning = function(w){
      print('warning')}, error = function(e){surv_p_all[[x]][j,1] <- 1
      HR_all[[x]][j,1] <- 1
      print('error')})
  }
  rownames(surv_p_all[[x]]) <- rownames(expression[[x]])
  rownames(HR_all[[x]]) <- rownames(expression[[x]])
}


names(surv_p_all) <- cancer_name
names(HR_all) <- cancer_name
for (i in 1:15) {
  surv_p_all[[i]][is.na(surv_p_all[[i]][,1]),1] <- 1
  surv_p_all[[i]][surv_p_all[[i]][,1]<0.05,2] <- 'sig'
  surv_p_all[[i]][surv_p_all[[i]][,1]>=0.05,2] <- 'non-sig'
}
for (i in 1:15) {
  surv_p_all[[i]] <- surv_p_all[[i]][rownames(surv_p_all[[i]])%in%unique(gene_protein$Gene.name),]
}

##画柱状图
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
for (i in 1:15) {
  A <- surv_data_clean[[i]][[1]]
  for (j in 1:ncol(A)) {
    colnames(A)[j] <- as.character(substring(colnames(A)[j],2,nchar(colnames(A)[j])))
  }
  a <- surv_p_all[[i]][rownames(surv_p_all[[i]])%in%rownames(A),2]
  # sum(rownames(a)==rownames(A))
  A$group <- a
  A$Gene <- rownames(A)
  A <- pivot_longer(data = A,cols = 1:(dim(A)[2]-2),
                    names_to = "Type",values_to = "count")
  str_sort(unique(A$Type),numeric = T)
  A$Type <- factor(A$Type, levels = str_sort(unique(A$Type),numeric = T))
  A$Type <- as.factor(A$Type)
  A$Type <- fct_inorder(A$Type)
  A$group <- factor(A$group,levels = c('non-sig','sig'))
  # A$group <- fct_inorder(A$group)
  
  plot <- ggplot(A, aes(fill=group, y=count, x=Type))+
    geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
    theme_classic(base_size = 12)+
    theme(legend.direction = "horizontal", legend.position = "top")+
    labs(title = cancer_name[i], y="Surv-sig rate ", x = "Sample Size")+
    stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
                 width = 0.5,position = position_dodge(1))+
    scale_y_continuous(limits = c(0,1),expand = c(0,0))+
    theme(axis.text.x = element_text(size = 12))+
    theme(axis.text.y = element_text(size = 12))+
    theme(axis.title = element_text(size = 14))
  pdf(paste('result/Figure/AI_plot_new/fig1/V5/s_fig1/',cancer_name[i],'.pdf',sep = ''), width=6, height=5)
  print(plot,newpage = FALSE)
  dev.off()
}

##画折线图
sig_gene_num <- data.frame()
sig_gene_max <- data.frame()
sig_gene_add <- data.frame()
for (i in 1:15) {
  for (j in 1:10) {
    sig_gene_num[i,j] <- length(which(surv_data_clean[[i]][[1]][,j]>=0.8))
    sig_gene_max[i,j] <- max(surv_data_clean[[i]][[1]][,j])
    ifelse(j==1,sig_gene_add[i,j] <- length(which(surv_data_clean[[i]][[1]][,j]>=0.8)),
           sig_gene_add[i,j] <- (length(which(surv_data_clean[[i]][[1]][,j]>=0.8))-sig_gene_add[i,j-1]))
  }
}
rownames(sig_gene_num) <- cancer_name
colnames(sig_gene_num) <- c(seq(0.1,1,0.1))
rownames(sig_gene_max) <- cancer_name
colnames(sig_gene_max) <- c(seq(0.1,1,0.1))
rownames(sig_gene_add) <- cancer_name
colnames(sig_gene_add) <- c(seq(0.1,1,0.1))

sig_gene_num$cancer_name <- rownames(sig_gene_num)
sig_gene_num <- pivot_longer(data = sig_gene_num,cols = 1:(dim(sig_gene_num)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_num$cancer_name <- factor(sig_gene_num$cancer_name, levels = str_sort(unique(sig_gene_num$cancer_name),numeric = T))
sig_gene_num$cancer_name <- as.factor(sig_gene_num$cancer_name)

sig_gene_max$cancer_name <- rownames(sig_gene_max)
sig_gene_max <- pivot_longer(data = sig_gene_max,cols = 1:(dim(sig_gene_max)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_max$cancer_name <- factor(sig_gene_max$cancer_name, levels = str_sort(unique(sig_gene_max$cancer_name),numeric = T))
sig_gene_max$cancer_name <- as.factor(sig_gene_max$cancer_name)

sig_gene_add$cancer_name <- rownames(sig_gene_add)
sig_gene_add <- pivot_longer(data = sig_gene_add,cols = 1:(dim(sig_gene_add)[2]-1),
                             names_to = "sample_size",##这一个参数是将列名命名为sample_size
                             values_to = "count")
sig_gene_add$cancer_name <- factor(sig_gene_add$cancer_name, levels = str_sort(unique(sig_gene_add$cancer_name),numeric = T))
sig_gene_add$cancer_name <- as.factor(sig_gene_add$cancer_name)

plot <- ggplot(sig_gene_max, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
  theme_base()+
  geom_line(size=1)#size是线的宽度
# ggplot(sig_gene_add, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
#   geom_line(size=1)#size是线的宽度
pdf(paste('result/Figure/AI_plot_new/fig1/V5/fig1C_v2.pdf',sep = ''), width=10, height=5)
print(plot,newpage = FALSE)
dev.off()

#####fig2
####fig2C排版
####富集通路
library(clusterProfiler)
library(stringr)
library(ggplot2)

cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
# surv_data <- list()
# surv_data_sig <- list()
# for (j in 1:length(cancer_name)) {
#   surv_data[[j]] <- list()
#   names(surv_data)[j] <- cancer_name[j]
#   surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
#   surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
#   surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
#   names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
#   a <- apply(surv_data[[j]][[1]], 2, max)
#   b <- surv_data[[j]][[1]][,which.max(a[a!=0])]
#   surv_data_sig[[j]] <- surv_data[[j]]
#   surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which.max(a[a!=0])] >= 0.8),]
#   surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
#   surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
# }##读取数据以及计算sig_gene
# names(surv_data_sig) <- cancer_name
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- rownames(surv_data_sig_V2[[i]][[1]])
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}
names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
sig_pathway_plot_all <- surv_sig_pathway
sig_pathway_plot_all@compareClusterResult <- sig_pathway_plot_all@compareClusterResult[sig_pathway_plot_all@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
clusterProfiler::dotplot(sig_pathway_plot_all)


a <- sig_pathway_plot_all@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(7,8,6,11,2,15,5,3,9,1)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_all
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(7,8,6,11,2,15,5,3,9,1)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(7,8,6,11,2,15,5,3,9,1)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 70)

# pdf(paste('result/Figure/AI_plot_new/fig2/V5/fig2A.pdf',sep = ''), width=12, height=10)
# print(plot,newpage = F)
# dev.off()

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]
# write.csv(annotation_col,'result/Figure/AI_plot_new/fig2/v5/pathway_annotation.csv',row.names = F)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v5/pathway_annotation.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='others',3] <- 'black'
y_color[y_color[,2]=='mitotic',3] <- 'red'
y_color[y_color[,2]=='immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
# y_color$color <- factor(y_color$color,levels = c('black','red','blue'))
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))


a <- as.vector(y_color$type)
a <-as.vector(y_color$pathway)[c(which(a=='others'),
                                 which(a=='immune'),
                                 which(a=='mitotic'))]
plot$data$Description <- factor(plot$data$Description,levels = a)

pdf(paste('result/Figure/AI_plot_new/fig2/V5/fig2A_1.pdf',sep = ''), width=12, height=10)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='others'),
                                                           which(y_color$type=='immune'),
                                                           which(y_color$type=='mitotic'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_color_gradient(high="#59EF0A",low="#F77103")+
  scale_fill_manual(values=c("red","blue","black"))#10cm*12cm
dev.off()


####fig2C
a <- surv_sig_dgree_V2[[2]]
a$type[a$a%in%immune_system[,1]] <- 'immune'
write.csv(a,'result/Figure/AI_plot_new/fig2/V5/BRCA_gene_type.csv',row.names = F)
a <- surv_sig_dgree_V2[[8]]
a$type[a$a%in%ref_path_mitotic] <- 'mitotic'
write.csv(a,'result/Figure/AI_plot_new/fig2/V5/LUAD_gene_type.csv',row.names = F)
##对网络top10进行富集（dotplot）
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- hub_gene[[i]][1:10,1]
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}

names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
##提取指定层次的通路进行绘制通路图
sig_pathway_plot_top10 <- surv_sig_pathway
sig_pathway_plot_top10@compareClusterResult <- sig_pathway_plot_top10@compareClusterResult[sig_pathway_plot_top10@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_top10,showCategory=5,includeAll=TRUE,label_format = 70)
a <- sig_pathway_plot_top10@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(2,15,7,8,6,9,13)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_top10
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(2,15,7,8,6,9,13)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(2,15,7,8,6,11,5,3,9,1,13)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 35)
pdf(paste('result/Figure/AI_plot_new/fig2/V5/fig2C.pdf',sep = ''), width=12, height=10)
print(plot,newpage = F)
dev.off()
write.csv(a@compareClusterResult,'result/Figure/AI_plot_new/fig2/v5/annotation_top10.csv')

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]

write.csv(annotation_col,'result/Figure/AI_plot_new/fig2/v5/pathway_annotation_top10.csv',row.names = F)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v5/pathway_annotation_top10.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='others',3] <- 'black'
y_color[y_color[,2]=='mitotic',3] <- 'red'
y_color[y_color[,2]=='immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

a <- as.vector(y_color$type)
a <-as.vector(y_color$pathway)[c(which(a=='others'),
                                 which(a=='mitotic'),
                                 which(a=='immune'))]
plot$data$Description <- factor(plot$data$Description,levels = a)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(y_color$type=='others'),
                                                           which(y_color$type=='mitotic'),
                                                           which(y_color$type=='immune'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=y_color$color[!duplicated(y_color$color)])#6cm*8cm

##ggplot2画sankey图
####top10sankey plot
library(tidyr)
annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v5/pathway_annotation_top10.csv')
annotation_col <- annotation_col[!annotation_col$Cluster%in%c('LUSC\n(10)','STAD\n(10)'),]
b <- annotation_col[,c(1,2,4)]
b <- b[c(which(b$func=='mitotic'),which(b$func=='immune'),which(b$func=='others')),]
b$weight <- 1
library("ggplot2")
library("ggalluvial")
colnames(b) <- c('pathway','cancer_type','pathway_name','weight')
b$cohort <- 1:nrow(b)
b <- pivot_longer(data = b[,c(1,2,5)],cols = 1:2,
                  names_to = "feature",##这一个参数是将列名命名为sample_size
                  values_to = "nodes")##col
b$nodes <- factor(b$nodes,levels = c(unique(b$nodes)[c(3,2,4,6,7,1,5,8)]))
mycol <- c("#F29530","#F29530","#F29530","#4FAAC8","#4FAAC8",'red','#245BAA','#D9D9D9')
plot <- ggplot(b,aes(x = feature, stratum = nodes, alluvium = cohort,
                     fill = nodes, label = nodes)) +
  scale_x_discrete(expand = c(0, 0)) + 
  geom_flow(width = 1/8) + #线跟方块间空隙的宽窄 
  geom_stratum(alpha = 1,width = 2/10) + #方块的透明度、宽度
  geom_text(stat = "stratum", size = 3,color="white") + #文字大小、颜色
  #不喜欢默认的配色方案，用前面自己写的配色方案
  scale_fill_manual(values = mycol) +
  xlab("") + ylab("") +
  theme_bw() + #去除背景色
  theme(panel.grid =element_blank()) + #去除网格线
  theme(panel.border = element_blank()) + #去除外层边框
  theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text = element_blank()) + #去掉坐标轴
  ggtitle("")+
  guides(fill = FALSE) #5cm*7cm

pdf(paste('result/Figure/AI_plot_new/fig2/V5/fig2D.pdf',sep = ''), width=7, height=5)
print(plot,newpage = F)
dev.off()

######fig3ABC
####Depmap分析
##read database
CCLE_cell_line <- read.csv('/database/depmap/突变信息/sample_info.csv')
cell_line_crispr <- read.csv('/database/depmap/CRISPR_(DepMap_21Q4_Public+Score,_Chronos).csv')
RNAi_raw <- read.csv('/database/depmap/RNAi_(Achilles+DRIVE+Marcotte,_DEMETER2).csv')
crispr_raw <- read.csv('/database/depmap/CRISPR_gene_effect_after_process.csv',header = T,row.names = 1)
#从此处接着运行
cell_line <- cell_line_crispr
cell_line <- CCLE_cell_line
cell_line <- cell_line[,c('DepMap_ID','stripped_cell_line_name','lineage','lineage_subtype','lineage_sub_subtype','lineage_molecular_subtype')]
# crispr <- read.csv('/database/depmap/CRISPR_gene_dependency.csv',header = T,row.names = 1)
a <- colnames(crispr)
a <- str_split(string = a,pattern = '[.][.]',simplify = T)
a[,1] <- gsub(x = a[,1],pattern = '[.]',replacement = '-')
colnames(crispr) <- a[,1]
# RNAi <- RNAi_raw
# rownames(RNAi) <- RNAi[,1]
# RNAi <- RNAi[,-1:-6]

cancer_name_crispr_RNAi <- read.csv('cancer_name_crispr_rnai_CCLE.csv',header = F)
##提取相关crispr数据
sig_gene_expr_plot <- list()
sig_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  tryCatch({
    a <- hub_gene[[j]][1:10,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    for (i in 1:ncol(b)) {
      colnames(b)[i] <- cancer_cell_line[,2][cancer_cell_line[,1] %in% colnames(b)[i]]
    }
    bk = unique(c(seq(0,1, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("white","navy"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    sig_gene_expr_plot[[j]] <- a
    sig_gene_expr_crispr[[j]] <- b
    # save_pheatmap_pdf(a,width=((50/268)*(ncol(b)+8))*1.8, 
    #                   height =((50/268)*(nrow(b)+8))*1.8, 
    #                   paste('result/',cancer_name[j],'/crispr/high_dgree/',cancer_name[j],'_crispr.pdf',sep = ''))
  }, error = function(e) {print(j)})
}

#Depmap分析有丝分裂通路中的基因对细胞生存的影响
ref_path_mitotic <- read.csv('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/GO0000278_mitotic_cell_cycle.csv',header = F)
ref_path_mitotic <- as.matrix(ref_path_mitotic[,1])
ref_path_mitotic <- as.vector(ref_path_mitotic)
a <- read.csv('reference/cell_cycle_mitotic.csv',header = T)
a <- as.matrix(a[,1])
a <- as.vector(a)
ref_path_mitotic <- c(ref_path_mitotic,a)
ref_path_mitotic <- ref_path_mitotic[!duplicated(ref_path_mitotic)]

mitotic_gene_expr_plot <- list()
mitotic_gene_expr_crispr <- list()
for (j in 1:length(cancer_name)) {
  tryCatch({
    # a <- surv_sig_dgree[[j]][1:10,1][surv_sig_dgree[[j]][1:10,1]%in%ref_path_mitotic]
    # a <- surv_sig_dgree[[j]][1:10,1]
    a <- hub_gene[[j]][,1]
    sig_gene_expr <- as.data.frame(t(crispr[,which(colnames(crispr)%in%a)]))
    cancer_cell_line <- cell_line[cell_line[,cancer_name_crispr_RNAi[j,2]]==cancer_name_crispr_RNAi[j,3],]#修改这个位置即可
    cancer_cell_line <- cancer_cell_line[order(cancer_cell_line[,1]),]
    b <- sig_gene_expr[,which(colnames(sig_gene_expr)%in%cancer_cell_line[,1])]
    for (i in 1:ncol(b)) {
      colnames(b)[i] <- cancer_cell_line[,2][cancer_cell_line[,1] %in% colnames(b)[i]]
    }
    bk = unique(c(seq(0,1, length=100)))
    a <- pheatmap::pheatmap(b,breaks = bk,show_rownames = T,
                            color = c(colorRampPalette(c("white","navy"))(100)),
                            clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T)
    mitotic_gene_expr_plot[[j]] <- a
    mitotic_gene_expr_crispr[[j]] <- b
    names(mitotic_gene_expr_plot)[j] <- cancer_name[j]
    names(mitotic_gene_expr_crispr)[j] <- cancer_name[j]
  }, error = function(e) {print(cancer_name[[j]])})
}

for (i in 1:15) {
  a <- mitotic_gene_expr_crispr[[i]]##LGG
  b <- apply(a, 1, mean)
  a <- a[order(b,decreasing = F),]
  annotation_row <- as.data.frame(rownames(a))
  rownames(annotation_row) <- annotation_row[,1]
  annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
  annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
  colnames(annotation_row) <- 'function'
  d <- factor(annotation_row[,1])
  annotation_row[,1] <- d
  bk = unique(c(seq(0,1, length=100)))
  ann_colors = list('function' = c(mitotic = "navy", other = "gray"))
  a <- pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,main = cancer_name[i],
                          color = c(colorRampPalette(c("white","navy"))(100)),
                          clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                          cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                          annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig3/V5/crispr/','fig3',cancer_name[i],'.pdf',sep = ''), width=5, height=4.1)
  print(a,newpage = F)
  dev.off()
}

#fig3D
#使用hub基因聚类
# for (i in 1:15) {
#   a <- surv_sig_inter[[i]]
#   b <- surv_sig_inter[[i]][,3:1]
#   colnames(b) <- colnames(a)
#   a <- rbind(a,b)
#   hub_gene[[i]] <- surv_sig_dgree[[i]]
#   for (j in 1:nrow(surv_sig_dgree[[i]])) {
#     b <- a[a[,1]%in%surv_sig_dgree[[i]][j,1],3]
#     c <- a[a[,1]%in%b,3]
#     hub_gene[[i]]$k2[j] <- length(unique(c(b,c)))
#   }
# }


library(ggplot2)
library(clusterProfiler)
library(grid)
library(survival)
library(survminer)
for (i in 1:15) {
  data <- as.matrix(t(expression[[i]][which(rownames(expression[[i]])%in%hub_gene[[i]][,1]),]))
  # for (j in 1:ncol(data)) {
  #   data[,j] <- scale(as.numeric(data[,j]))
  # }
  data <- log2(data+1)
  dist.e <- dist(data,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=3)#分类
  result <- as.data.frame(result)
  paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
  a <- cbind(rownames(result),result)
  # colnames(a)[1] <- colnames(BRCA_subtype)[1]
  # a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
  b <- a[,1]
  a <- as.data.frame(a[,-1])
  rownames(a) <- b
  colnames(a) <- c('cluster')
  result <- a
  annotation_col <- result
  annotation_col[annotation_col[,1]==1,1] <- 'type1'
  annotation_col[annotation_col[,1]==2,1] <- 'type2'
  annotation_col[annotation_col[,1]==3,1] <- 'type3'
  
  a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type3'],])#4cm*8cm
  a <- t(a)
  # a <- log2(t(a)+1)
  # bk = unique(c(seq(-3,3, length=200)))
  ann_colors = list(cluster = c(type1 = "blue",type2 = "#F2CA20", type3 = "#E24A0E")) 
  # a <- t(data)
  plot1 <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                              annotation_colors = ann_colors,
                              clustering_method = 'ward.D2', 
                              color = c(colorRampPalette(c("navy", "white"))(100),
                                        colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                              cluster_cols = F,cluster_rows = T,
                              annotation_col = annotation_col,
                              # breaks = bk
  )#5*8
  pdf(paste('result/Figure/AI_plot_new/fig3/V5/cluster_hopmap_survive/',cancer_name[i],'_hot.pdf',sep = ''), width=8, height=5)
  grid.draw(plot1)
  dev.off()
  
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(annotation_col),]
  b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'type1'
  b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'type2'
  b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'type3'
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Follow up time(d)", # 指定x轴标签
                     legend = c(0.8,0.75),         # 指定图例位置
                     title = cancer_name[i],                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 365,# 设置x轴刻度间距
                     pval.method=T)
  
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
                          type = c("blue","#F2CA20","#E24A0E"),
                          labels = c('type1','type2','type3'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig3/V5/cluster_hopmap_survive/',cancer_name[i],'_surv.pdf',sep = ''), width=7, height=5)
  grid.draw(plot2)
  dev.off()
}#
##sfig2 sfig3
for (i in 1:15) {
  data <- as.matrix(t(expression[[i]][which(rownames(expression[[i]])%in%hub_gene[[i]][,1]),]))
  data <- log2(data+1)
  dist.e <- dist(data,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=3)#分类
  result <- as.data.frame(result)
  paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
  a <- cbind(rownames(result),result)
  # colnames(a)[1] <- colnames(BRCA_subtype)[1]
  # a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
  b <- a[,1]
  a <- as.data.frame(a[,-1])
  rownames(a) <- b
  colnames(a) <- c('cluster')
  result <- a
  annotation_col <- result
  a <- data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]==1],]
  j1 <- mean(apply(a, 1, sum))
  a <- data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]==2],]
  j2 <- mean(apply(a, 1, sum))
  a <- data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]==3],]
  j3 <- mean(apply(a, 1, sum))
  # order(c(j1,j2,j3),decreasing = F)
  annotation_col[annotation_col[,1]==order(c(j1,j2,j3),decreasing = F)[1],1] <- 'type1'
  annotation_col[annotation_col[,1]==order(c(j1,j2,j3),decreasing = F)[2],1] <- 'type2'
  annotation_col[annotation_col[,1]==order(c(j1,j2,j3),decreasing = F)[3],1] <- 'type3'
  
  a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type3'],])#4cm*8cm
  a <- t(a)
  # a <- log2(t(a)+1)
  # bk = unique(c(seq(-3,3, length=200)))
  ann_colors = list(cluster = c(type1 = "blue",type2 = "#F2CA20", type3 = "#E24A0E"))
  # a <- t(data)
  pheatmap::pheatmap(a)
  plot1 <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                              annotation_colors = ann_colors,
                              clustering_method = 'ward.D2', 
                              color = c(colorRampPalette(c("navy", "white"))(100),
                                        colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                              cluster_cols = F,cluster_rows = T,
                              annotation_col = annotation_col,
                              treeheight_row = 3,
                              main = cancer_name[i]
                              # breaks = bk
  )#5*8
  pdf(paste('result/Figure/AI_plot_new/fig3/V5/sfig2/',cancer_name[i],'_hot.pdf',sep = ''), width=7, height=5)
  grid.draw(plot1)
  dev.off()
  
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(annotation_col),]
  b[b[,6]%in%rownames(result)[result[,1]==order(c(j1,j2,j3),decreasing = F)[1]],7] <- 'type1'
  b[b[,6]%in%rownames(result)[result[,1]==order(c(j1,j2,j3),decreasing = F)[2]],7] <- 'type2'
  b[b[,6]%in%rownames(result)[result[,1]==order(c(j1,j2,j3),decreasing = F)[3]],7] <- 'type3'
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Follow up time(d)", # 指定x轴标签
                     legend = c(0.8,0.75),         # 指定图例位置
                     title = cancer_name[i],                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 365,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(labels = c('type1','type2','type3'),
                          type = c("blue","#F2CA20","#E24A0E"))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig3/V5/sfig3/',cancer_name[i],'_surv.pdf',sep = ''), width=7, height=5)
  grid.draw(plot2)
  dev.off()
}#

####使用显著基因对LUAD进行分类，并与TCGA三种亚型进行分类
subtype <- read.csv('/database/文献/肺癌的分子分型/肺腺癌/luad_subtype.csv')
subtype <- subtype[,c('Tumor.ID','expression_subtype')]
subtype[,2] <- subtype[,2]
subtype[,2][subtype[,2]=='prox.-inflam'] <- 'PI'
subtype[,2][subtype[,2]=='prox.-prolif.'] <- 'PP'
luad_subtype <- lifetime_all[[8]]
colnames(subtype)[1] <- 'case_id'
luad_subtype <- merge(luad_subtype,subtype,by = 'case_id',all=F)

####LUAD层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[8]][rownames(expression[[8]])%in%hub_gene[[8]][,1],]))
# a <- surv_sig_dgree[[8]][surv_sig_dgree[[8]][,1]%in%colnames(data),]
# data <- data[,colnames(data)%in%a[1:10,1]]
# data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%c(surv_sig_dgree[[8]][c(1:8,10),1])),
#                                     which(colnames(expression[[8]])%in%luad_subtype$Sample.ID)]))
# data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%c(surv_sig_dgree[[8]][c(1:10),1])),
#                                     which(colnames(expression[[8]])%in%luad_subtype$Sample.ID)]))
# 
# 
# data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%c('DLGAP5','CKAP2L','KPNA2','HJURP','BUB1','TPX2','BUB1B','CCNA2','NCAPG','KIF23')),]))

# for (i in 1:ncol(data)) {
#   data[,i] <- scale(as.numeric(data[,i]))
# }
data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- luad_subtype
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MH'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'ML'

##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,8]=='PI',6],],data[rownames(data)%in%b[b[,8]=='PP',6],],data[rownames(data)%in%b[b[,8]=='TRU',6],])
hotmap <- rbind(hotmap[rownames(hotmap)%in%b[b[,7]=='ML',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MM',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MH',6],])
annotation_col <- rbind(b[b[,7]=='ML',7:8],b[b[,7]=='MM',7:8],b[b[,7]=='MH',7:8])
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster','subtype')
rownames(annotation_col) <- c(b[b[,7]=='ML',6],b[b[,7]=='MM',6],b[b[,7]=='MH',6])
ann_colors = list(subtype = c(PI="blue", PP="#F2CA20",TRU="#E24A0E"), #连续数值型分组可设置成渐变  
                  cluster = c(ML="#89C890",MM="#4498F2", MH="#ED5163")) 
# hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
# bk = unique(c(seq(-3,3, length=100)))
plot <- pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,
                           show_colnames = F,
                           # breaks = bk,
                           treeheight_row = 4,
                           color = c(colorRampPalette(c("navy","white"))(50),colorRampPalette(c("white","red"))(50)),
                           annotation_colors = ann_colors)#4cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig3/V5/fig3D.pdf',sep = ''), width=6, height=4)
print(plot,newpage = F)
dev.off()
##画柱状图看统计情况堆叠柱状图
library(tidyr)
subtype_sum <- data.frame()
for (i in 1:3) {
  subtype_sum[1,i] <- length(which(b[b[,7]==c('MH','MM','ML')[i],8]=='PI'))
  subtype_sum[2,i] <- length(which(b[b[,7]==c('MH','MM','ML')[i],8]=='PP'))
  subtype_sum[3,i] <- length(which(b[b[,7]==c('MH','MM','ML')[i],8]=='TRU'))
}
colnames(subtype_sum) <- c('MH','MM','ML')
rownames(subtype_sum) <- c('PI','PP','TRU')
subtype_sum <- apply(subtype_sum, 2, function(x){x/sum(x)})
subtype_sum <- as.data.frame(subtype_sum)
subtype_sum[1:3,4] <- rownames(subtype_sum)
colnames(subtype_sum)[4] <- 'subtype'
subtype_sum <- pivot_longer(data = subtype_sum,cols = 1:(ncol(subtype_sum)-1),
                            names_to = "cluster",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$subtype <- factor(subtype_sum$subtype)
subtype_sum$cluster <- factor(subtype_sum$cluster,levels = c('ML','MM','MH'))

p <- ggplot(subtype_sum, aes(x=cluster, y=percents,fill=subtype)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack",color="black", width=0.6,size=0.25)+
  scale_fill_manual(values=c("blue","#F2CA20","#E24A0E"))+
  labs(x = "",y = "Percent")+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()#6cm*5cm
p#6cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig3/V5/fig3E.pdf',sep = ''), width=5, height=6)
print(p,newpage = F)
dev.off()
##生存分析分组状况
#聚类分组
library('survival')
library('survminer')
b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(2000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(2000,1)#P值方法文本坐标
)
p <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#ED5163","#89C890", "#4498F2"),
                        breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        labels = c("ML","MM","MH"))##对齐坐标轴原点#4cm*5cm

pdf(paste('result/Figure/AI_plot_new/fig3/V5/fig3F.pdf',sep = ''), width=5, height=4)
print(p,newpage = F)
dev.off()

#TCGA分组
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,8], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,8], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(2000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(2000,1)#P值方法文本坐标
)
p <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("blue","#F4BD0B","#E24A0E"),
                        breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
                        labels = c("PI","PP","TRU"))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig3/V5/fig3G.pdf',sep = ''), width=5, height=4)
print(p,newpage = F)
dev.off()

#fig4A
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%hub_gene[[8]][,1]),]))
# for (i in 1:ncol(data)) {
#   data[,i] <- scale(as.numeric(data[,i]))
# }
data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- result
b[b[,1]=='1',1] <- 'MH'
b[b[,1]=='2',1] <- 'MM'
b[b[,1]=='3',1] <- 'ML'
b$sample_id <- rownames(b)
##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,1]=='ML',2],],
                data[rownames(data)%in%b[b[,1]=='MM',2],],
                data[rownames(data)%in%b[b[,1]=='MH',2],])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
# hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
# bk = unique(c(seq(-3,3, length=100)))
p <- pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        # breaks = bk,
                        annotation_colors = ann_colors,color = c(colorRampPalette(c("navy","white"))(50),
                                                                 colorRampPalette(c("white","red"))(50)))#4cm*8cm
# pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4A.pdf',sep = ''), width=5, height=4)
# print(p,newpage = F)
# dev.off()
#全样本聚类分组的生存分析情况#supplymental
library('survival')
library('survminer')
b <- lifetime_all[[8]]
b <- b[b$Sample.ID%in%colnames(expression[[8]]),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MH'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'ML'
b[b$V5>3650,2] <- 0
b[b$V5>3650,5] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(2000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 1000,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(2000,1)#P值方法文本坐标
)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#ED5163", "#4498F2","#89C890"),
                        breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        labels = c("ML","MM","MH"))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig4/V5/sfig1.pdf',sep = ''), width=5, height=4)
print(plot,newpage = F)
dev.off()

##
##常用函数
library(maftools)
LUAD_mut_raw <- read.maf(maf = '/database/TCGA/LUAD/mutation/TCGA_LUAD_mutation.maf',clinicalData = '/database/TCGA/LUAD/mutation/information/clinical.tsv')
plotmafSummary(maf=LUAD_mut_raw, rmOutlier=TRUE, addStat="median", dashboard=TRUE,
               titvRaw = FALSE,log_scale = F,showBarcodes = F)
oncoplot(maf=LUAD_mut_raw, top=10, borderCol=NULL)
lollipopPlot(maf=LUAD_mut_raw, gene="TP53", AACol="HGVSp_Short", showMutationRate=TRUE)
luad.mutload <- tcgaCompare(maf=LUAD_mut_raw, cohortName="Download_LUAD")

####比较ML/MMH的突变情况
LUAD_mut <- LUAD_mut_raw@data
LUAD_mut$Tumor_Sample_Barcode <- substring(text = LUAD_mut$Tumor_Sample_Barcode,first = 1,last = 12)
LUAD_mut$Tumor_Sample_Barcode <- gsub(LUAD_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

b$patient <- substring(text = b$Sample.ID,first = 1,last = 12)
ML_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$File.Name=='ML',8],]
MM_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$File.Name=='MM',8],]
MH_mut <- LUAD_mut[LUAD_mut$Tumor_Sample_Barcode%in%b[b$File.Name=='MH',8],]
write.table(ML_mut,'result/LUAD/mutation/ML_mut_correction.maf',sep = '\t',quote = F,row.names = F)
write.table(MM_mut,'result/LUAD/mutation/MM_mut_correction.maf',sep = '\t',quote = F,row.names = F)
write.table(MH_mut,'result/LUAD/mutation/MH_mut_correction.maf',sep = '\t',quote = F,row.names = F)
ML_mut <- read.maf(maf ='result/LUAD/mutation/ML_mut_correction.maf')
MM_mut <- read.maf(maf ='result/LUAD/mutation/MM_mut_correction.maf')
MH_mut <- read.maf(maf ='result/LUAD/mutation/MH_mut_correction.maf')
# ML_mut <- read.maf(maf ='result/LUAD/mutation/ML_mut.maf')
# MM_mut <- read.maf(maf ='result/LUAD/mutation/MM_mut.maf')
# MH_mut <- read.maf(maf ='result/LUAD/mutation/MH_mut.maf')


########ML/MMH的TMB分析
TMB <- list()
TMB[[1]] <- tmb(maf = ML_mut)
TMB[[2]] <- tmb(maf = MM_mut)
TMB[[3]] <- tmb(maf = MH_mut)
names(TMB) <- c('ML_mut','MM_mut','MH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('ML',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('MM',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('MH',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('ML','MM','MH'))

library(ggplot2)
library(ggpubr)

a <- ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  scale_fill_manual(values=c(ML = "#00BA38",MM = "#619CFF", MH = "#F8766D"))+
  geom_signif(comparisons = list(c("ML","MM"),c("ML","MH"),c('MM','MH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(29,31,29),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
a
pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4A.pdf',sep = ''), width=4, height=5)
print(a,newpage = F)
dev.off()
#fig4B
####对每个病人进行定义,画出每个病人的高频低频突变的堆叠柱状图
##画柱状图看统计情况堆叠柱状图
library(ggplot2)
library(tidyr)
library(tidyverse)
library(ggtree)
library(aplot)
all_mut_table <- data.frame()
for (i in 1:length(sig_mut_list)) {
  all_mut_table[i,1] <- sig_mut_list[i]
  all_mut_table[i,2] <- length(unique(LUAD_mut$Tumor_Sample_Barcode[which(LUAD_mut$Hugo_Symbol==sig_mut_list[i])]))
}
names(all_mut_table) <- c('gene','num')
all_mut_table$percent <- all_mut_table$num/length(unique(LUAD_mut$Tumor_Sample_Barcode))
all_mut_table$type[all_mut_table$percent>=0.05] <- 'high'
all_mut_table$type[all_mut_table$percent<0.05] <- 'low'
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
patient_mut <- data.frame(patient_id)
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  patient_mut[i,2] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='high']])
  patient_mut[i,3] <- length(a[a%in%all_mut_table$gene[all_mut_table$type=='low']])
}
colnames(patient_mut) <- c('patient_id','high','low')
a <- patient_id[order(apply(patient_mut[,2:3], 1, sum),decreasing = T)]
b$patient <- substring(b$Sample.ID,1,12)
a <- c(a[a%in%b$patient[b$File.Name=='ML']],a[a%in%b$patient[b$File.Name=='MM']],a[a%in%b$patient[b$File.Name=='MH']])


#rownames(patient_mut) <- patient_id
patient_mut <- patient_mut[patient_mut$patient_id%in%a,]
rownames(patient_mut) <- patient_mut$patient_id
patient_mut <- patient_mut[a,]
patient_mut$cluster[patient_mut$patient_id%in%b[b$File.Name=='ML',8]] <- 'ML'
patient_mut$cluster[patient_mut$patient_id%in%b[b$File.Name=='MM',8]] <- 'MM'
patient_mut$cluster[patient_mut$patient_id%in%b[b$File.Name=='MH',8]] <- 'MH'
for (i in 1:nrow(patient_mut)) {
  c <- patient_mut[i,2]+patient_mut[i,3]
  patient_mut[i,2] <- patient_mut[i,2]/c
  patient_mut[i,3] <- patient_mut[i,3]/c
}
a <- patient_mut$patient_id[order(patient_mut$high,decreasing = F)]
a <- c(a[a%in%b$patient[b$File.Name=='ML']],a[a%in%b$patient[b$File.Name=='MM']],a[a%in%b$patient[b$File.Name=='MH']])

group <- patient_mut[,c(1,4)]
patient_mut <- pivot_longer(data = patient_mut,cols = 2:3,
                            names_to = "mut_frequency",##这一个参数是将列名命名为sample_size
                            values_to = "mut_frequency_value")##col
patient_mut$cluster <- factor(patient_mut$cluster,levels = c('ML','MM','MH'))
patient_mut$patient_id <- factor(patient_mut$patient_id,levels = a)
patient_mut$mut_frequency <- factor(patient_mut$mut_frequency,levels = c('high','low'))



p <- ggplot(border=0,patient_mut, aes(x=patient_id, y=mut_frequency_value,fill=mut_frequency)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack", width=1,size=0.25)+
  scale_fill_manual(values=c("red","#399938"))+
  labs(x = element_blank(),y = "",title='mutation per patient')+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()+
  theme(axis.ticks.x = element_blank(),axis.text.x = element_blank())#6cm*5cm
#绘制分组色条
group$patient_id <- factor(group$patient_id,levels = a)
group$cluster <- factor(group$cluster,levels = c('ML','MM','MH'))
q <- ggplot(group,aes(patient_id,y=1,fill=cluster))+
  geom_tile()+
  scale_fill_manual(values=c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163"))+
  scale_x_discrete(expand=c(0,0)) +
  scale_y_discrete(expand=c(0,0))+
  labs(x = "patient(n=493)")+
  theme(axis.text = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks = element_blank())
#拼图
plot <- insert_bottom(p,q,height=0.03)
pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4B.pdf',sep = ''), width=8, height=6)
print(plot,newpage = F)
dev.off()
#sfig
patient_high <- patient_mut[patient_mut$mut_frequency=='high',]
a <- ggplot(patient_high, aes(x=cluster, y=mut_frequency_value,fill=cluster)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  scale_fill_manual(values=c(ML = "#00BA38",MM = "#619CFF", MH = "#F8766D"))+
  geom_signif(comparisons = list(c("ML","MM"),c("ML","MH"),c('MM','MH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.6,0.7,0.6),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
a
pdf(paste('result/Figure/AI_plot_new/fig4/V5/sfig1.pdf',sep = ''), width=4, height=5)
print(a,newpage = F)
dev.off()




#6cm*8cm

#fig4CDE
ML_mut_vs_MH_mut <- mafCompare(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
MM_mut_vs_MH_mut <- mafCompare(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', minMut = 2, useCNV =FALSE)
ML_mut_vs_MM_mut <- mafCompare(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', minMut = 2, useCNV =FALSE)

forestPlot(mafCompareRes = ML_mut_vs_MM_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = ML_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
forestPlot(mafCompareRes = MM_mut_vs_MH_mut, pVal = 0.005, color = c('royalblue', 'maroon'), geneFontSize = 0.8)

r1<-ML_mut_vs_MM_mut$results
g0<-r1[which(r1$pval<0.001),Hugo_Symbol]
g0<-r1[1:10,Hugo_Symbol]
g1<-r1[1:10,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4C_ML_MM.pdf',sep = ''), width=12, height=3)
coOncoplot(m1 = ML_mut, m2 = MM_mut, m1Name = 'ML_mut', m2Name = 'MM_mut', genes = g, removeNonMutated = T)
dev.off()
r1<-MM_mut_vs_MH_mut$results
g0<-r1[which(r1$pval<0.001),Hugo_Symbol]
g0<-r1[1:10,Hugo_Symbol]
g1<-r1[1:10,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4C_MM_MH.pdf',sep = ''), width=12, height=3)
coOncoplot(m1 = MM_mut, m2 = MH_mut, m1Name = 'MM_mut', m2Name = 'MH_mut', genes = g, removeNonMutated = T)
dev.off()
r1<-ML_mut_vs_MH_mut$results
g0<-r1[which(r1$pval<0.001),Hugo_Symbol]
g0<-r1[1:10,Hugo_Symbol]
g1<-r1[1:10,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4C_ML_MH.pdf',sep = ''), width=12, height=3)
coOncoplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut', genes = g, removeNonMutated = T)
dev.off()

coBarplot(m1 = ML_mut, m2 = MH_mut, m1Name = 'ML_mut', m2Name = 'MH_mut')

#fig4F
####读取细胞系突变
library(stringr)
CCLE_mut <- read.csv('/database/depmap/突变信息/CCLE_mutations.csv')
CCLE_cell_line <- read.csv('/database/depmap/突变信息/sample_info.csv')
luad_cell_line <- CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1:3]
luad_cell_line_mut <- CCLE_mut[CCLE_mut$DepMap_ID%in%luad_cell_line$DepMap_ID,]

luad_cell_line_expr <- crispr

##对所有突变进行筛选(全细胞系)
#all_mut
all_mut_ddc <- data.frame()
sig_mut_list <- unique(LUAD_mut$Hugo_Symbol)
all_mut_table <- data.frame()
for (i in 1:length(sig_mut_list)) {
  all_mut_table[i,1] <- sig_mut_list[i]
  all_mut_table[i,2] <- length(unique(LUAD_mut$Tumor_Sample_Barcode[which(LUAD_mut$Hugo_Symbol==sig_mut_list[i])]))
}
names(all_mut_table) <- c('gene','num')
all_mut_table$percent <- all_mut_table$num/length(unique(LUAD_mut$Tumor_Sample_Barcode))
all_mut_table$type[all_mut_table$percent>=0.05] <- 'high'
all_mut_table$type[all_mut_table$percent<0.05] <- 'low'


for (i in 1:length(sig_mut_list)) {tryCatch({
  A=sig_mut_list[i]
  all_mut_ddc[i,1] <- A
  a <- unique(CCLE_mut$DepMap_ID[CCLE_mut$Hugo_Symbol==A])
  c <- luad_cell_line_expr[rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  d <- luad_cell_line_expr[!rownames(luad_cell_line_expr)%in%a,colnames(luad_cell_line_expr)==A]
  e <- t.test(c,d)
  all_mut_ddc[i,2] <- e$estimate[1]
  all_mut_ddc[i,3] <- e$estimate[2]
  all_mut_ddc[i,4] <- e$p.value
  all_mut_ddc[i,5] <- all_mut_ddc[i,2]-all_mut_ddc[i,3]
  all_mut_ddc[i,6] <- length(c)
  all_mut_ddc[i,7] <- length(d)
}, error = function(e) {print(i)})
}
A='KRAS'
colnames(all_mut_ddc) <- c('Gene','mut_cell_line','wt_cell_line','p_value','diff_ddc','mut_num','wt_num')
all_mut_ddc$p_adj <- p.adjust(all_mut_ddc$p_value)
all_mut_ddc$ddc_rate <- 2*all_mut_ddc$diff_ddc/(all_mut_ddc$mut_cell_line+all_mut_ddc$wt_cell_line)
effect_mut <- all_mut_ddc[!is.na(all_mut_ddc$p_value)&all_mut_ddc$p_value<0.05&abs(all_mut_ddc$diff_ddc)>0.01&abs(all_mut_ddc$ddc_rate)>0.10,]

####火山图展示有效突变基因
library(ggpubr)
library(ggplot2)
library(ggthemes)
library(ggrepel)
mut_gene_plot <- all_mut_ddc[!is.na(all_mut_ddc$p_value),]
mut_gene_plot$'-lg(pvalue)' <- -1*log10(mut_gene_plot$p_value)
mut_gene_plot$label <- NA
mut_gene_plot$label[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05]
mut_gene_plot$label[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05]
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&mut_gene_plot$Gene%in%all_mut_table[all_mut_table$type=='high',1]] <- 'effective_high'
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&mut_gene_plot$Gene%in%all_mut_table[all_mut_table$type=='low',1]] <- 'effective_low'
mut_gene_plot$group[!(abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05)] <- 'invalid'

mut_gene_plot <- mut_gene_plot[order(mut_gene_plot$`-lg(pvalue)`),]#对差异表达基因调整后的p值进行排序
mut_gene_plot$`-lg(pvalue)`[mut_gene_plot$`-lg(pvalue)`>25] <- 25

#添加特定基因label
p <- ggscatter(mut_gene_plot,x = "ddc_rate",y = "-lg(pvalue)",color = "group",
               palette = c('red','#399938','gray'),
               repel = T, ylab = "-lg(pvalue)", size = 1) + 
  theme_base()+
  theme(element_line(size = 0),element_rect(size = 1.5))+ #坐标轴线条大小设置
  scale_y_continuous(limits = c(0,26))+
  scale_x_continuous(limits = c(-2,2))+
  geom_point(aes(size=abs(diff_ddc),color=group))+
  geom_text_repel(data = mut_gene_plot,parse = F,
                  color="black",min.segment.length = 0,force = 1,max.iter = 3e3,
                  aes(label = label),
                  size = 4,segment.size=1,segment.colour='black')+
  geom_hline(yintercept = -log10(0.05),linetype = "dashed")+
  geom_vline(xintercept = c(-0.1,0.1),linetype = "dashed")#7cm*6cm

pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4F.pdf',sep = ''), width=6, height=7)
print(p,newpage = F)
dev.off()

####火山图展示有效突变基因，红色标注为前面算出来的差异突变
a <- as.data.frame(ML_mut_vs_MM_mut[[1]])
diff_gene_mut <- c(as.data.frame(ML_mut_vs_MM_mut[[1]])[ML_mut_vs_MM_mut[[1]]$pval<0.05,1],
                   as.data.frame(ML_mut_vs_MH_mut[[1]])[ML_mut_vs_MH_mut[[1]]$pval<0.05,1],
                   as.data.frame(MM_mut_vs_MH_mut[[1]])[MM_mut_vs_MH_mut[[1]]$pval<0.05,1])
diff_gene_mut <- diff_gene_mut[!duplicated(diff_gene_mut)]
library(ggpubr)
library(ggplot2)
library(ggthemes)
library(ggrepel)
mut_gene_plot <- all_mut_ddc[!is.na(all_mut_ddc$p_value),]
mut_gene_plot$'-lg(pvalue)' <- -1*log10(mut_gene_plot$p_value)
mut_gene_plot$label <- NA
mut_gene_plot$label[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc>0.3&mut_gene_plot$p_value<0.05]
mut_gene_plot$label[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05] <- mut_gene_plot$Gene[mut_gene_plot$diff_ddc< -0.2&mut_gene_plot$p_value<0.05]
# mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&mut_gene_plot$Gene%in%all_mut_table[all_mut_table$type=='high',1]] <- 'effective_high'
# mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&mut_gene_plot$Gene%in%all_mut_table[all_mut_table$type=='low',1]] <- 'effective_low'
# mut_gene_plot$group[!(abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05)] <- 'invalid'
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05] <- 'effective'
mut_gene_plot$group[abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05&(mut_gene_plot$Gene%in%diff_gene_mut)] <- 'effective(diff_mutation)'

mut_gene_plot$group[!(abs(mut_gene_plot$ddc_rate) > 0.1&mut_gene_plot$p_value<0.05)] <- 'invalid'


mut_gene_plot <- mut_gene_plot[order(mut_gene_plot$`-lg(pvalue)`),]#对差异表达基因调整后的p值进行排序
mut_gene_plot$`-lg(pvalue)`[mut_gene_plot$`-lg(pvalue)`>25] <- 25
mut_gene_plot <- mut_gene_plot[c(which(mut_gene_plot$group=='invalid'),
                                 which(mut_gene_plot$group=='effective'),
                                 which(mut_gene_plot$group=='effective(diff_mutation)')),]
#添加特定基因label
p <- ggscatter(mut_gene_plot,x = "ddc_rate",y = "-lg(pvalue)",color = "group",
               palette = c('#399938','red','gray'),
               repel = T, ylab = "-lg(pvalue)", size = 1,) + 
  theme_base()+
  theme(element_line(size = 0),element_rect(size = 1.5))+ #坐标轴线条大小设置
  scale_y_continuous(limits = c(0,26))+
  scale_x_continuous(limits = c(-2,2))+
  geom_point(aes(size=abs(diff_ddc),color=group))+
  geom_text_repel(data = mut_gene_plot,parse = F,
                  color="black",min.segment.length = 0,force = 1,max.iter = 3e3,
                  aes(label = label),
                  size = 4,segment.size=1,segment.colour='black')+
  geom_hline(yintercept = -log10(0.05),linetype = "dashed")+
  geom_vline(xintercept = c(-0.1,0.1),linetype = "dashed")#7cm*6cm#如果想要哪些点的图层放在最上层，把它们排序往后，因为是按照顺序画图层的

pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4F_1.pdf',sep = ''), width=7, height=7)
print(p,newpage = F)
dev.off()

#fig4G
#################替换为伯努利检验（二项检验）
####Nest定义每个病人
library(stats)
nest_pathway <- read.csv('/database/IAS/NeST Map - Main Model default node.csv')
nest_pathway_list <- list()
for (i in 1:nrow(nest_pathway)) {
  a <- nest_pathway[i,4]
  nest_pathway_list[[i]] <- str_split(a,' ',simplify = F)[[1]]
}
names(nest_pathway_list) <- nest_pathway$Annotation

path_num_cal <- function(x){
  x=nest_pathway_list[[x]]
  length(which(a%in%x))
}
patient_pathway <- list()
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  a <- a[a%in%ref_all_mut_ddc$Gene]
  b <- as.data.frame(names(nest_pathway_list))
  b[,2] <- apply(b, 1, path_num_cal)
  colnames(b) <- c('pathway_name','map_mut_num')
  patient_pathway[[i]] <- b
}
names(patient_pathway) <- patient_id

patient_pathway_table <- data.frame(names(nest_pathway_list))
rownames(patient_pathway_table) <- patient_pathway_table[,1]
for (i in 1:length(patient_pathway)) {
  patient_pathway_table[,i] <- patient_pathway[[i]][,2]
  patient_pathway_table[patient_pathway_table[,i]>0,i] <- 1
  patient_pathway_table[patient_pathway_table[,i]==0,i] <- 0
}
colnames(patient_pathway_table) <- names(patient_pathway)

patient_pathway_table <- patient_pathway_table[apply(patient_pathway_table, 1, sum)>0,]

result
b <- result
b[b[,1]=='1',1] <- 'MH'
b[b[,1]=='2',1] <- 'MM'
b[b[,1]=='3',1] <- 'ML'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
##画热图比较这两组样本的基因
hotmap <- cbind(patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='ML',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MM',3]],
                patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
##画瀑布图
diff_pathway_list <- data.frame(rownames(hotmap))
for (i in 1:nrow(diff_pathway_list)) {
  c <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='ML',3]])
  d <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='MM',3]])
  e <- as.numeric(hotmap[i,colnames(hotmap)%in%b[b[,1]=='MH',3]])
  diff_pathway_list[i,2] <- sum(c)
  diff_pathway_list[i,3] <- sum(d)
  diff_pathway_list[i,4] <- sum(e)
  diff_pathway_list[i,5] <- binom.test(x = sum(d),n = length(d),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value
  diff_pathway_list[i,6] <- binom.test(x = sum(e),n = length(e),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value
  diff_pathway_list[i,7] <- binom.test(x = sum(e),n = length(e),p = sum(d)/length(d),alternative = "two.sided",conf.level = 0.95)$p.value
}

binom.test(x = sum(d),n = length(d),p = sum(c)/length(c),alternative = "two.sided",conf.level = 0.95)$p.value

colnames(diff_pathway_list) <- c('pathway','ML','MM','MH','ML_MM','ML_MH','MM_MH')
c <- apply(hotmap, 1, sum)
c <- cbind(rownames(hotmap),c)
c <- as.data.frame(c)
colnames(c) <- c('nest','num')
c <- c[order(as.numeric(c[,2]),decreasing = F),]
for (i in 1:nrow(c)) {
  a <- as.data.frame(hotmap[i,])
  hotmap <- cbind(hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==1]],
                  hotmap[,colnames(hotmap)%in%colnames(a)[a[1,]==0]])
}
hotmap <- hotmap[rownames(c)[nrow(c):1],]
a <- pheatmap::pheatmap(hotmap,cluster_col = T,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- as.data.frame(cutree(a$tree_col,k=2))
hotmap <- cbind(hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==1]],
                hotmap[,colnames(hotmap)%in%rownames(a)[a[,1]==2]])

hotmap <- cbind(hotmap[,colnames(hotmap)%in%b[b[,1]=='ML',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MM',3]],
                hotmap[,colnames(hotmap)%in%b[b[,1]=='MH',3]])
hotmap <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[!(diff_pathway_list$ML_MM>0.05&diff_pathway_list$ML_MH>0.05&diff_pathway_list$MM_MH>0.05)],]


a <- pheatmap::pheatmap(hotmap,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$ML_MM<0.05],]
a <- hotmap[rownames(hotmap)%in%diff_pathway_list$pathway[diff_pathway_list$MM_MH<0.05],]
a <- pheatmap::pheatmap(a,cluster_rows = F,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        annotation_colors = ann_colors,color = c('white','#399938'))#4cm*8cm


diff_pathway_list$ML_specific <- ''
diff_pathway_list$MM_specific <- ''
diff_pathway_list$MH_specific <- ''
diff_pathway_list$ML_specific[(diff_pathway_list$ML/sum(colnames(hotmap)%in%b[b[,1]=='ML',3]))>(diff_pathway_list$MM/sum(colnames(hotmap)%in%b[b[,1]=='MM',3]))&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$ML/sum(colnames(hotmap)%in%b[b[,1]=='ML',3]))>(diff_pathway_list$MH/sum(colnames(hotmap)%in%b[b[,1]=='MH',3]))&diff_pathway_list$ML_MH<0.05] <- 1
diff_pathway_list$MM_specific[(diff_pathway_list$MM/sum(colnames(hotmap)%in%b[b[,1]=='MM',3]))>(diff_pathway_list$ML/sum(colnames(hotmap)%in%b[b[,1]=='ML',3]))&diff_pathway_list$ML_MM<0.05&
                                (diff_pathway_list$MM/sum(colnames(hotmap)%in%b[b[,1]=='MM',3]))>(diff_pathway_list$MH/sum(colnames(hotmap)%in%b[b[,1]=='MH',3]))&diff_pathway_list$MM_MH<0.05] <- 1
diff_pathway_list$MH_specific[(diff_pathway_list$MH/sum(colnames(hotmap)%in%b[b[,1]=='MH',3]))>(diff_pathway_list$ML/sum(colnames(hotmap)%in%b[b[,1]=='ML',3]))&diff_pathway_list$ML_MH<0.05&
                                (diff_pathway_list$MH/sum(colnames(hotmap)%in%b[b[,1]=='MH',3]))>(diff_pathway_list$MM/sum(colnames(hotmap)%in%b[b[,1]=='MM',3]))&diff_pathway_list$MM_MH<0.05] <- 1
write.csv(diff_pathway_list,'result/Figure/AI_plot_new/fig4/v5/样本差异突变通路_NEW.csv',row.names = F)
####验证结果
a <- patient_pathway_table[,colnames(patient_pathway_table)%in%b[b[,1]=='MH',3]]
colnames(a)[a["Proximal RTK signaling",]==1]

##画差异通路气泡图
# b <- result
# b[b[,1]=='1',1] <- 'MM'
# b[b[,1]=='2',1] <- 'ML'
# b[b[,1]=='3',1] <- 'MH'
# b$sample_id <- rownames(b)
# b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)
diff_pathway_plot <- diff_pathway_list
diff_pathway_plot$ML <- diff_pathway_plot$ML/sum(b$result=='ML')
diff_pathway_plot$MM <- diff_pathway_plot$MM/sum(b$result=='MM')
diff_pathway_plot$MH <- diff_pathway_plot$MH/sum(b$result=='MH')
diff_pathway_plot$ML_MM_log2FC <- log2(diff_pathway_plot$ML/diff_pathway_plot$MM)
diff_pathway_plot$ML_MH_log2FC <- log2(diff_pathway_plot$ML/diff_pathway_plot$MH)
diff_pathway_plot$MM_MH_log2FC <- log2(diff_pathway_plot$MM/diff_pathway_plot$MH)

diff_pathway_plot$ML_MH[is.nan(diff_pathway_plot$ML_MH)] <- 1
diff_pathway_plot$MM_MH[is.nan(diff_pathway_plot$MM_MH)] <- 1
diff_pathway_plot$ML_MM_log2FC[diff_pathway_plot$ML_MM_log2FC==Inf] <- 4
diff_pathway_plot$ML_MM_log2FC[diff_pathway_plot$ML_MM_log2FC==-Inf] <- -4
diff_pathway_plot$ML_MH_log2FC[diff_pathway_plot$ML_MH_log2FC==Inf] <- 4
diff_pathway_plot$ML_MH_log2FC[diff_pathway_plot$ML_MH_log2FC==-Inf] <- -4
diff_pathway_plot$MM_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==Inf] <- 4
diff_pathway_plot$MM_MH_log2FC[diff_pathway_plot$MM_MH_log2FC==-Inf] <- -4


diff_pathway_plot <- diff_pathway_plot[!(diff_pathway_plot$ML_MM>0.05&
                                           diff_pathway_plot$ML_MH>0.05&
                                           diff_pathway_plot$MM_MH>0.05),]
diff_pathway_plot <- diff_pathway_plot[!(abs(diff_pathway_plot$ML_MM_log2FC)<1&
                                           abs(diff_pathway_plot$ML_MH_log2FC)<1&
                                           abs(diff_pathway_plot$MM_MH_log2FC)<1),]
colnames(diff_pathway_plot)[1] <- 'Annotation'
diff_pathway_plot <- merge(diff_pathway_plot,nest_pathway[,c('Annotation','Size')],all=F,by='Annotation')
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Size<30&(
  diff_pathway_plot$ML>0.05|
    diff_pathway_plot$MM>0.05|
    diff_pathway_plot$MH>0.05),]
# diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Size<20&
#                                          (diff_pathway_plot$ML_MH<0.05),]

a <- c(diff_pathway_plot[order(diff_pathway_plot$ML_MM,decreasing = F),1],
       diff_pathway_plot[order(diff_pathway_plot$ML_MH,decreasing = F),1],
       diff_pathway_plot[order(diff_pathway_plot$MM_MH,decreasing = F),1])
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$Annotation%in%a,]

a <- pivot_longer(diff_pathway_plot[,c('Annotation','ML_MM','ML_MH','MM_MH')],cols = 2:4,
                  names_to = 'compare_object',values_to = 'p_value')
b <- pivot_longer(diff_pathway_plot[,c('Annotation','ML_MM_log2FC','ML_MH_log2FC','MM_MH_log2FC')],cols = 2:4,
                  names_to = 'compare_object',values_to = 'log2FC')
diff_pathway_plot <- cbind(a,b[,3]) 
diff_pathway_plot$p_value <- round(as.numeric(diff_pathway_plot$p_value),4)
diff_pathway_plot <- diff_pathway_plot[diff_pathway_plot$p_value<0.01,]
diff_pathway_plot <- diff_pathway_plot[abs(diff_pathway_plot$log2FC)>1,]
diff_pathway_plot$compare_object <- factor(diff_pathway_plot$compare_object,
                                           levels = c('ML_MM','MM_MH','ML_MH'))
a <- as.data.frame(unique(diff_pathway_plot$Annotation))
# write.csv(a,'result/Figure/AI_plot_new/fig4/V5/nest_annotation_v5.csv')
a <- read.csv('result/Figure/AI_plot_new/fig4/v5/nest_annotation_v5.csv')
a <- a[c(which(a$func=='Cell cycle'),
         which(a$func=='Other signaling processes'),
         which(a$func=='Cytoplasm and extracellular space')),]

c <- diff_pathway_plot
y_color <- as.data.frame(a)
colnames(y_color)[1] <- 'fuction'
# y_color[y_color[,1]=='Other biology process',3] <- 'black'
y_color <- y_color[!y_color[,1]=='Other biology process',]
c <- c[c$Annotation%in%a$pathway,]
c$Annotation <- factor(c$Annotation,levels = a$pathway[nrow(a):1])

y_color[y_color[,1]=='Cell cycle',3] <- 'red'
y_color[y_color[,1]=='Cytoplasm and extracellular space',3] <- 'black'
y_color[y_color[,1]=='Other signaling processes',3] <- 'blue'
colnames(y_color) <- c('type','pathway','color')
y_color$type <- factor(y_color$type,levels = c('Cytoplasm and extracellular space','Other signaling processes','Cell cycle'))
y_color$xmin <- -Inf
y_color$xmax <- Inf
rownames(y_color) <- 1:nrow(y_color)
y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

plot <- ggplot(c,aes(x=compare_object,y=Annotation))+
  geom_point(aes(size=abs(`log2FC`),color=`p_value`))+
  scale_color_gradient(high="#1E08F7",low="#F20808")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=0,hjust = 0.5,vjust=0.5),
        axis.text.y = element_text(color = y_color$color[c(which(a$func=='Cytoplasm and extracellular space'),
                                                           which(a$func=='Other signaling processes'),
                                                           which(a$func=='Cell cycle'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=c('red','blue','black'))+
  labs(x=NULL,y=NULL,title = 'the pathway of different cluster')#6cm*7cm

pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4G.pdf',sep = ''), width=8, height=6)
print(plot)
dev.off()


####先不关心突变，直接筛选药效好的药物，然后看这些药物的通路是否与周期蛋白和PIK3CA相关
####drug effection significance
####药物筛选
###fig5A
A549_drug_gdsc1 <- read.csv('result/Figure/table3_from_GDSC1_A549.csv')
A549_drug_gdsc1[,6] <- 'GDSC1'
A549_drug_gdsc1[,7] <- rownames(A549_drug_gdsc1)
A549_drug_gdsc2 <- read.csv('result/Figure/table3_from_GDSC2_A549.csv')
A549_drug_gdsc2[,6] <- 'GDSC2'
A549_drug_gdsc2[,7] <- rownames(A549_drug_gdsc2)
a <- rbind(A549_drug_gdsc1[,c(7,4,6)],A549_drug_gdsc2[,c(7,4,6)])
colnames(a) <- c('num','Z_score','version')
a[,1] <- as.numeric(a[,1])

plot <- ggplot(a, aes(x=num, y=Z_score,color=version)) + 
  ggtitle("GDSC_drug_screen")+
  geom_point(size=0.8,stroke =1)+
  theme_bw()+
  geom_hline(yintercept = c(-2,2),linetype = "dashed")+
  annotate('text',x=150,y=2.2,label=expression('resistant'),size=4,color='red')+
  annotate('text',x=50,y=-2.2,label=expression('sensitive'),size=4,color='blue')##画散点图5cm*8cm

pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig5A.pdf',sep = ''), width=8, height=5)
print(plot,newpage = F)
dev.off()
#fig5B
A549_drug_gene_res <- read.csv('/database/cMAP/A549_cell_drug_expr_data.csv')
library(clusterProfiler)
a <- bitr(A549_drug_gene_res[,1],fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
          toType = c('SYMBOL'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
colnames(A549_drug_gene_res)[1] <- 'ENTREZID'
A549_drug_gene_res <- merge(a,A549_drug_gene_res,by='ENTREZID',all=F)
rownames(A549_drug_gene_res) <- A549_drug_gene_res[,2]
A549_drug_gene_res <- A549_drug_gene_res[,-1:-2]
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]

# #提取cmap的A549数据
# luad <- cell_line_expr_drug[[8]][[7]]
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称

All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA

##画韦恩图
library(VennDiagram)
venn.plot <- venn.diagram(x = list(cMAP_A549=All_drug,GDSC_A549=gdsc_A549_drug),
                          category.names = c('cMAP_A549','GDSC_A549'),
                          filename = NULL,
                          scaled = F,
                          height = 1500, width = 1500, resolution =600,
                          alpha=c(0.6, 0.6),
                          fill=c(colors()[616], colors()[38]), 
                          lwd=rep(1,2), cex=0.45, 
                          fontfamily = "serif", fontface = "bold",
                          cat.dist=c(-0.07, -0.07),
                          output=TRUE,
                          area.vector = 0,
                          cat.pos=c(280, 80), #位置
                          cat.cex=0.45)##画韦恩图

pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig5B.pdf',sep = ''), width=2, height=2)
grid.draw(venn.plot)
dev.off()

#先用KEGG得到磷酸戊糖途径，然后画磷酸戊糖途径和有丝分裂在这三组之中的分析图,和PPP无关
b <- result
b[b[,1]=='1',1] <- 'MH'
b[b[,1]=='2',1] <- 'MM'
b[b[,1]=='3',1] <- 'ML'
b$sample_id <- rownames(b)
b$patient_id <- substring(text = b$sample_id,first = 1,last = 12)

diff_gene_set <- data.frame(row.names = rownames(expression[[8]]))
c <- expression[[8]][,colnames(expression[[8]])%in%b[b[,1]=='ML',2]]
d <- expression[[8]][,colnames(expression[[8]])%in%b[b[,1]=='MM',2]]
e <- expression[[8]][,colnames(expression[[8]])%in%b[b[,1]=='MH',2]]
for (i in 1:nrow(expression[[8]])) {
  diff_gene_set$gene[i] <- rownames(expression[[8]])[i]
  diff_gene_set$mean_all[i] <- mean(as.numeric(expression[[8]][i,]))
  diff_gene_set$mean_ML[i] <- mean(as.numeric(c[i,]))
  diff_gene_set$mean_MM[i] <- mean(as.numeric(d[i,]))
  diff_gene_set$mean_MH[i] <- mean(as.numeric(e[i,]))
  diff_gene_set$logFC_ML_MM[i] <- log2((diff_gene_set$mean_ML[i]/diff_gene_set$mean_MM[i]))
  diff_gene_set$logFC_MM_MH[i] <- log2((diff_gene_set$mean_MM[i]/diff_gene_set$mean_MH[i]))
  diff_gene_set$logFC_ML_MH[i] <- log2((diff_gene_set$mean_ML[i]/diff_gene_set$mean_MH[i]))
  diff_gene_set$pvalue_ML_MM[i] <- t.test(as.numeric(c[i,]),as.numeric(d[i,]))$p.value
  diff_gene_set$pvalue_MM_MH[i] <- t.test(as.numeric(d[i,]),as.numeric(e[i,]))$p.value
  diff_gene_set$pvalue_ML_MH[i] <- t.test(as.numeric(c[i,]),as.numeric(e[i,]))$p.value
}
diff_pathway_KEGG <- list()

a <- diff_gene_set[abs(diff_gene_set$logFC_ML_MM)>1&diff_gene_set$pvalue_ML_MM<0.05&diff_gene_set$mean_all>1,1]
a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
diff_pathway_KEGG[['ML_MM']] <- enrichKEGG(a[,2], #数据源
                                           organism = 'hsa', #物种
                                           keyType = 'kegg', #"kegg"/'ncbi-geneid'/'ncib-proteinid'/'uniprot'之一，KEGG就写kegg
                                           pvalueCutoff = 1,
                                           pAdjustMethod = 'BH',#P值校正方法
                                           qvalueCutoff = 1)

a <- diff_gene_set[abs(diff_gene_set$logFC_MM_MH)>1&diff_gene_set$pvalue_MM_MH<0.05&diff_gene_set$mean_all>1,1]
a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
diff_pathway_KEGG[['MM_MH']] <- enrichKEGG(a[,2], #数据源
                                           organism = 'hsa', #物种
                                           keyType = 'kegg', #"kegg"/'ncbi-geneid'/'ncib-proteinid'/'uniprot'之一，KEGG就写kegg
                                           pvalueCutoff = 1,
                                           pAdjustMethod = 'BH',#P值校正方法
                                           qvalueCutoff = 1)

a <- diff_gene_set[abs(diff_gene_set$logFC_ML_MH)>1&diff_gene_set$pvalue_ML_MH<0.05&diff_gene_set$mean_all>1,1]
a <- bitr(a,fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
diff_pathway_KEGG[['ML_MH']] <- enrichKEGG(a[,2], #数据源
                                           organism = 'hsa', #物种
                                           keyType = 'kegg', #"kegg"/'ncbi-geneid'/'ncib-proteinid'/'uniprot'之一，KEGG就写kegg
                                           pvalueCutoff = 1,
                                           pAdjustMethod = 'BH',#P值校正方法
                                           qvalueCutoff = 1)

#fig5c
##获取与gdsc有交集的cmap数据
a <- as.data.frame(t(A549_drug_gene_res))
b <- rownames(a)
b <- str_split(string = b,pattern = '[.]',simplify = T)
b <- paste(b[,2],b[,3],sep = '-')
drug_list <- read.csv('/database/cMAP/GSE92742_Broad_LINCS_pert_info_trt_cp.csv')
drug_list <- drug_list[,1:2]
drug_list[,2] <- tolower(drug_list[,2])
b <- as.data.frame(b)
colnames(b) <- 'pert_id'
a <- cbind(b,a)
for (i in 1:nrow(a)) {
  a[i,1] <- drug_list[drug_list[,1]==a[i,1],2]
}
luad <- a[,c(1,which(colnames(a)%in%hub_gene[[8]][,1]))]
gdsc_A549 <- gdsc_2[gdsc_2$CELL_LINE_NAME=='A549',]
gdsc_A549$DRUG_NAME <- tolower(gdsc_A549$DRUG_NAME)
for (i in 1:nrow(luad)) {
  a <- gdsc_A549[gdsc_A549$DRUG_NAME==luad[i,1],ncol(gdsc_2)]
  a <- min(a)
  luad$Z_score[i] <- a
}


luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集

pheatmap::pheatmap(luad_overlap[,2:11],clustering_method = 'ward.D2')
bk = unique(c(seq(-4,4, length=200)))
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:11]),
                             breaks = bk,show_rownames = T,
                             treeheight_row = 0,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2",
                             show_colnames = F,cluster_rows = T,cluster_cols = T)
cluster <- hotmap$tree_col
plot(cluster,hang = -1,cex=0.6,axes=FALSE,ann=FALSE)
cut <- as.data.frame(cutree(cluster,2))
annotation_row <- cut
colnames(annotation_row) <- 'cluster'
annotation_row[annotation_row[,1]==1,1] <- 'mitotic_inhibit'
annotation_row[annotation_row[,1]==2,1] <- 'mitotic_activate'
d <- factor(annotation_row[,1])
annotation_row[,1] <- d
ann_colors = list(cluster = c(mitotic_activate="#ED5163", mitotic_inhibit="#4498F2")) 
hotmap <- pheatmap::pheatmap(t(luad_overlap[,2:11]),
                             breaks = bk,show_rownames = T,
                             treeheight_row = 0,annotation_col = annotation_row,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2",
                             show_colnames = F,cluster_rows = T,cluster_cols = T,
                             annotation_colors = ann_colors,treeheight_col = 3)#6cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig5C.pdf',sep = ''), width=8, height=5)
grid.draw(hotmap)
dev.off()


#fig5D画sw1573和A549的突变相似图，药效双柱状图
##画柱状图
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)

gdsc2_A549 <- gdsc[gdsc$CELL_LINE_NAME=='A549',]
gdsc2_A549$drug_name <- tolower(gdsc2_A549$DRUG_NAME)
for (i in 1:nrow(luad)) {
  a <- gdsc2_A549[gdsc2_A549$drug_name==luad$pert_id[i],]
  if (sum(c('GDSC1','GDSC2')%in%a$DATASET)==2) {
    luad$IC50[i] <- min(a[a$DATASET=='GDSC2','Z_SCORE'])
  }else{
    luad$IC50[i] <- min(a[,'Z_SCORE'])
  }
}

drug_effection <- list()
drug_effection[[1]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==1],]
drug_effection[[2]] <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==2],]
names(drug_effection) <- c('mitotic_inhibit','mitotic_activate')
for (i in 1:2) {
  a <- aggregate(drug_effection[[i]][,12],by=list(drug_effection[[i]][,1]),FUN=mean)
  drug_effection[[i]] <- a
}
for (i in 1:2) {
  drug_effection[[i]] <- cbind(drug_effection[[i]],rep(c('mitotic_inhibit','mitotic_activate')[i],nrow(drug_effection[[i]])))
  colnames(drug_effection[[i]]) <- c('drug_name','IC50-Z_SCORE','cluster')
}
for (i in 1:2) {
  drug_effection[[i]] <- drug_effection[[i]][drug_effection[[i]][,2]!=Inf,]
}

# drug_effection[[1]] <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
a <- drug_effection[[1]][!drug_effection[[1]]$drug_name%in%drug_effection[[2]]$drug_name,]
# b <- drug_effection[[2]][!drug_effection[[2]]$drug_name%in%drug_effection[[1]]$drug_name,]
# drug_effection_plot <- rbind(a,b)

# drug_effection_plot <- rbind(drug_effection[[1]],
#                            drug_effection[[2]])
drug_effection_plot$cluster <- as.factor(drug_effection_plot$cluster)
colnames(drug_effection_plot)[2] <- 'IC50-Z_SCORE'

library(ggplot2)
library(ggpubr)

# p <- ggplot(drug_effection_plot, aes(x=cluster, y=`IC50-Z_SCORE`,fill=cluster)) +
#   geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
#   geom_jitter(shape=16, position = position_jitter(0.2))+
#   theme_classic()+
#   geom_signif(comparisons = list(c("mitotic_inhibit","mitotic_activate")),
#               map_signif_level = TRUE, test = t.test, y_position = c(1.1),
#               tip_length = c(0.02))#5cm*4cm
#
# pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig5D.pdf',sep = ''), width=4, height=5)
# print(p,newpage = F)
# dev.off()

#sfig5D


#fig5E
drug_info <- read.csv('/database/GDSC/drug_IC50/screened_compunds_rel_8.2.csv')
drug_info$name <- tolower(drug_info$DRUG_NAME)
effect_drug_info <- drug_info[drug_info$name%in%a[,1],]
##查看是否有相应的细胞系数据
#获取PIK3CA，KRAS突变细胞系名称
library(maftools)
# CCLE_cell_mut <- read.csv('/database/depmap/突变信息/CCLE_mutations.csv')
LUAD_cell_mut <- CCLE_cell_mut[CCLE_cell_mut$DepMap_ID%in%CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1],]
LUAD_cell_mut_sig <- data.frame(1:76)
LUAD_cell_mut_sig <- as.data.frame(t(LUAD_cell_mut_sig))
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='KRAS'])
P_K_mut_cell_line <- unique(LUAD_cell_mut$DepMap_ID[LUAD_cell_mut$Hugo_Symbol=='PIK3CA'&
                                                      LUAD_cell_mut$DepMap_ID%in%P_K_mut_cell_line])
CCLE_cell_line$stripped_cell_line_name[CCLE_cell_line$DepMap_ID%in%P_K_mut_cell_line]

A549_mut <- LUAD_cell_mut[LUAD_cell_mut$DepMap_ID=='ACH-000681',]
SW1573_mut <- LUAD_cell_mut[LUAD_cell_mut$DepMap_ID=='ACH-000677',]




gdsc_SW1573 <- gdsc[gdsc$CELL_LINE_NAME=='SW1573',]
gdsc_SW1573 <- gdsc_SW1573[gdsc_SW1573$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_SW1573 <- gdsc_SW1573[gdsc_SW1573$DATASET=='GDSC2',]
gdsc_A549 <- gdsc[gdsc$CELL_LINE_NAME=='A549',]
gdsc_A549 <- gdsc_A549[gdsc_A549$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_A549 <- gdsc_A549[gdsc_A549$DATASET=='GDSC2',]



c <- gdsc_A549[-8,c(5,9,19)]
c <- aggregate(c[,3],list(c$DRUG_NAME),min)
c$cell_line <- 'A549'
d <- gdsc_SW1573[-8,c(5,9,19)]
d <- aggregate(d[,3],list(d$DRUG_NAME),min)
d$cell_line <- 'SW1573'
# t.test(c[,2], d[,2], paired = TRUE)
a <- rbind(c,d)
colnames(a) <- c('drug','IC50_Z-SCORE','cell_line')

# 画散点图
p <- ggplot(a, aes(x = cell_line, y = `IC50_Z-SCORE`)) +
  geom_point(aes(colour = factor(drug)),size=6) +
  geom_line(aes(group = drug), color = 'gray', lwd = 0.5)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'cell_line', y = 'IC50_Z-SCORE', title = 'The effect of different mutations on drugs', subtitle = '')
p

# 
# 
# p <- ggplot(dat, aes(x = group1, y = MAP2)) +
#   geom_boxplot(aes(fill = group1), show.legend = FALSE, width = 0.6) +  #绘制箱线图
#   scale_fill_manual(values = c('#FE7280', '#AC88FF')) +  #箱线图的填充色
#   geom_point(size = 2) +  #绘制样本点
#   geom_line(aes(group = group2), color = 'gray', lwd = 0.5) +  #绘制配对样本间连线
#   ##以下是ggplot2的主题设置，修改边框、背景、标题、字体等
#   theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
#         plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
#         axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
#   labs(x = '', y = 'expression of MAP2', title = 'MAP2', subtitle = 'Tumor vs Normal')
# 
# p
# 
# ggplot(a, aes(fill=cell_line, y=`IC50_Z-SCORE`, x=drug))+
#   geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
#   theme_classic(base_size = 12)+
#   theme(legend.direction = "horizontal", legend.position = "top")+
#   labs(title = "", y="Surv-sig rate ", x = "Sample Size")+
#   stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
#                width = 0.5,position = position_dodge(1))+
#   scale_y_continuous(expand = c(0,0))+
#   theme(axis.text.x = element_text(size = 12))+
#   theme(axis.text.y = element_text(size = 12))+
#   theme(axis.title = element_text(size = 14))
# 
# p <- ggplot(a, aes(x=cell_line, y=`IC50_Z-SCORE`,fill=cell_line)) +
#   geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
#   geom_jitter(shape=16, position = position_jitter(0.2))+
#   theme_classic()+
#   stat_compare_means(method = "t.test",paired = T )+
#   geom_signif(comparisons = list(c("A549","SW1573")),
#               map_signif_level = TRUE, test = t.test, y_position = c(2.5),
#               tip_length = c(0.02))#5cm*4cm

pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig5E.pdf',sep = ''), width=6, height=8)
print(p,newpage = F)
dev.off()

#sfig5E
pik3ca_mut <- unique(CCLE_cell_mut$DepMap_ID[CCLE_cell_mut$Hugo_Symbol=='PIK3CA'])
pik3ca_wt <- unique(CCLE_cell_mut$DepMap_ID[!CCLE_cell_mut$DepMap_ID%in%pik3ca_mut])
pik3ca_mut <- cell_line$stripped_cell_line_name[cell_line$DepMap_ID%in%pik3ca_mut]
pik3ca_wt <- cell_line$stripped_cell_line_name[cell_line$DepMap_ID%in%pik3ca_wt]

gdsc_pik3ca_wt <- gdsc[gdsc$CELL_LINE_NAME%in%pik3ca_wt,]
gdsc_pik3ca_wt <- gdsc_pik3ca_wt[gdsc_pik3ca_wt$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_pik3ca_wt <- gdsc_pik3ca_wt[gdsc_pik3ca_wt$DATASET=='GDSC2',]

gdsc_pik3ca_mut <- gdsc[gdsc$CELL_LINE_NAME%in%pik3ca_mut,]
gdsc_pik3ca_mut <- gdsc_pik3ca_mut[gdsc_pik3ca_mut$DRUG_NAME%in%effect_drug_info$DRUG_NAME,]
gdsc_pik3ca_mut <- gdsc_pik3ca_mut[gdsc_pik3ca_mut$DATASET=='GDSC2',]

##画个热图比较一下
a <- rbind(gdsc_pik3ca_wt,gdsc_pik3ca_mut)
a <- a[!(a$DRUG_NAME=='Dactinomycin'&is.na(a$PUTATIVE_TARGET)),]
a <- a[,c(5,9,19)]
a <- pivot_wider(data = a,names_from = DRUG_NAME,values_from = Z_SCORE,values_fill = NA)
a <- as.data.frame(a)
rownames(a) <- a[,1]
a <- a[,-1]
p <- pheatmap::pheatmap(a)
a <- a[p[["tree_row"]][["order"]],]
a <- a[c(rownames(a)[rownames(a)%in%pik3ca_mut],rownames(a)[rownames(a)%in%pik3ca_wt]),]
p <- pheatmap::pheatmap(a,cluster_rows = F)
pdf(paste('result/Figure/AI_plot_new/fig5/V5/sfig5E.pdf',sep = ''), width=6, height=20)
print(p,newpage = F)
dev.off()





c <- gdsc_A549[-8,c(5,9,19)]
c <- aggregate(c[,3],list(c$DRUG_NAME),min)
c$cell_line <- 'A549'
d <- gdsc_SW1573[-8,c(5,9,19)]
d <- aggregate(d[,3],list(d$DRUG_NAME),min)
d$cell_line <- 'SW1573'
# t.test(c[,2], d[,2], paired = TRUE)
a <- rbind(c,d)
colnames(a) <- c('drug','IC50_Z-SCORE','cell_line')




####然后查询文献或临床试验中PI3K抑制剂与其他药物联用的效果
####联合用药预测(这部分可能还是得实验)
# drug_combine_raw <- read.csv('/database/DrugComb/summary_v_1_5.csv')
# drug_combine <- drug_combine_raw
# drug_combine$drug_row <- tolower(drug_combine$drug_row)
# drug_combine$drug_col <- tolower(drug_combine$drug_col)
# drug_combine <- drug_combine[c(which(drug_combine$drug_row%in%effect_drug_info$name),
#                                which(drug_combine$drug_col%in%effect_drug_info$name)),]


####BUB1B的解释
#BUB1B的基因依赖性
library(Hmisc)
luad_cell_line_expr[a[a%in%rownames(luad_cell_line_expr)],'BUB1B']
luad_cell_line_expr['ACH-002157','BUB1B']

a <- CCLE_cell_line[CCLE_cell_line$Subtype=='Non-Small Cell Lung Cancer (NSCLC), Adenocarcinoma',1]
a <- CCLE_mut[CCLE_mut$DepMap_ID%in%a,]

#计算在药物作用下与BUB1B相关性最强的基因群
# luad <- cell_line_expr_drug[[8]][[7]]
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
#提取A549_gdsc数据和药物名称
gdsc_A549 <- gdsc[gdsc[,5]=='A549',c(5,7,9:11,19)]
gdsc_A549_drug <- gdsc_A549$DRUG_NAME
gdsc_A549_drug <- tolower(gdsc_A549_drug)
gdsc_A549_drug <- gdsc_A549_drug[!is.na(gdsc_A549_drug)]
gdsc_A549_drug <- gdsc_A549_drug[!duplicated(gdsc_A549_drug)]
#提取cmap的A549数据
##获取cmap数据库作用于A549细胞系的药物名称
All_drug <- luad[,1][!duplicated(luad[,1])]##获取所有作用于A549的药物名称
All_drug <- tolower(All_drug)
All_drug <- All_drug[!is.na(All_drug)]##画韦恩图不能有NA

##获取与gdsc有交集的cmap数据
luad_overlap <- luad[luad[,1]%in%gdsc_A549_drug,]##获取药物处理后显著基因的表达量小于DMSO处理组表达量的药物的交集
# write.csv(luad_overlap,'result/A549_effect_drug_list.csv')
pheatmap::pheatmap(luad_overlap[,2:11],clustering_method = 'ward.D2')
bk = unique(c(seq(-4,4, length=200)))
hotmap <- pheatmap::pheatmap(luad_overlap[,2:10],breaks = bk,show_rownames = F,
                             color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             clustering_method = "ward.D2", show_colnames = T,cluster_rows = T,cluster_cols = T)
cluster <- hotmap$tree_row
plot(cluster,hang = -1,cex=0.6,axes=FALSE,ann=FALSE)
cut <- as.data.frame(cutree(cluster,2))
drug_inhibit_gene <- luad[rownames(luad)%in%rownames(cut)[cut[,1]==1],]
# for (i in 1:nrow(drug_inhibit_gene)) {
#   drug_inhibit_gene[i,12:14] <- min(drug_inhibit_gene[i,12:14][!is.na(drug_inhibit_gene[i,12:14])])
# }
colnames(drug_inhibit_gene)[c(1,13)] <- c('drug_name','IC50_Z-score')
# write.csv(drug_inhibit_gene[,1:10],'result/Figure/table1_effect_drug_gene_res.csv',row.names = T)
drug_inhibit_gene_name <- drug_inhibit_gene[!duplicated(drug_inhibit_gene[,1]),c(1,13)]
# write.csv(drug_inhibit_gene_name,'result/Figure/table2_effect_drug_name.csv',row.names = F)
pheatmap::pheatmap(rcorr(as.matrix(drug_inhibit_gene[,2:11]))[[1]])##画相关性图

#fig5F
####BUB1B相关性变化的气泡图
library(Hmisc)
library(ggplot2)
BUB1B_drug_spearman <- rcorr(as.matrix(drug_inhibit_gene[,2:11]))
a <- expression[[8]]
a <- t(a[rownames(a)%in%colnames(drug_inhibit_gene[,2:11]),])
BUB1B_tcga_spearman <- rcorr(a,type = 'spearman')
a <- cbind(rownames(BUB1B_tcga_spearman[[1]]),BUB1B_tcga_spearman[[1]][,'BUB1B'],BUB1B_tcga_spearman[[3]][,'BUB1B'],rep('TCGA',nrow(BUB1B_tcga_spearman[[1]])))
b <- cbind(rownames(BUB1B_drug_spearman[[1]]),BUB1B_drug_spearman[[1]][,'BUB1B'],BUB1B_drug_spearman[[3]][,'BUB1B'],rep('cMap',nrow(BUB1B_drug_spearman[[1]])))
BUB1B_spearman_plot <- rbind(a,b)
colnames(BUB1B_spearman_plot) <- c('gene','spearman','p_value','data_source')
BUB1B_spearman_plot <- as.data.frame(BUB1B_spearman_plot[BUB1B_spearman_plot[,1]!="BUB1B",])
BUB1B_spearman_plot$p_value <- -1*log10(as.numeric(BUB1B_spearman_plot$p_value)+0.0001)
BUB1B_spearman_plot$spearman <- round(as.numeric(BUB1B_spearman_plot$spearman),2)

ggplot(BUB1B_spearman_plot,aes(x=gene,y=data_source))+
  geom_point()
plot <- ggplot(BUB1B_spearman_plot,aes(x=gene,y=data_source))+
  geom_point(aes(size=`p_value`,color=`spearman`))+
  scale_color_gradient(high="#F20808",low="#1E08F7")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=90,hjust = 1,vjust=0.5))+
  labs(x=NULL,y=NULL,title = 'the correlation of BUB1B in different situations')#3.54cm*4.34cm

pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig5F.pdf',sep = ''), width=6, height=3)
print(plot,newpage = F)
dev.off()
# ggsave(plot = plot,filename = paste('result/Figure/AI_plot_new/fig5/V4/fig5F.pdf',sep = ''),width = 5,height = 2.5)
# 


#fig5G
####读取A549细胞系有效药物的基因表达数据
A549_drug_gene_res <- read.csv('/database/cMAP/A549_cell_drug_expr_data.csv')
library(clusterProfiler)
a <- bitr(A549_drug_gene_res[,1],fromType = 'ENTREZID', #数据源，fromtype是基因的id类型
          toType = c('SYMBOL'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
colnames(A549_drug_gene_res)[1] <- 'ENTREZID'
A549_drug_gene_res <- merge(a,A549_drug_gene_res,by='ENTREZID',all=F)
rownames(A549_drug_gene_res) <- A549_drug_gene_res[,2]
A549_drug_gene_res <- A549_drug_gene_res[,-1:-2]

cor_p_value <- function(x){cor.test(BUB1B_expr,as.numeric(x),method = 'spearman')$p.value}
cor_estimate <- function(x){cor.test(BUB1B_expr,as.numeric(x),method = 'spearman')$estimate}

BUB1B_expr <- as.numeric(A549_drug_gene_res['BUB1B',])
BUB1B_cor <- data.frame(rownames(A549_drug_gene_res))
BUB1B_cor$drug_cor <- apply(A549_drug_gene_res,1,cor_estimate)
BUB1B_cor$drug_p_value <- apply(A549_drug_gene_res,1,cor_p_value)
BUB1B_cor$drug_p_adj <- p.adjust(BUB1B_cor$drug_p_value)

LUAD_TCGA_expr <- expr_data_raw[[8]]
LUAD_TCGA_expr <- LUAD_TCGA_expr[rownames(LUAD_TCGA_expr)%in%rownames(A549_drug_gene_res),]
LUAD_TCGA_expr <- LUAD_TCGA_expr[rownames(A549_drug_gene_res),]
rownames(LUAD_TCGA_expr) <- rownames(A549_drug_gene_res)
LUAD_TCGA_expr <- as.matrix(LUAD_TCGA_expr)
LUAD_TCGA_expr[is.na(LUAD_TCGA_expr)] <- 0
BUB1B_expr <- as.numeric(LUAD_TCGA_expr['BUB1B',])


BUB1B_cor$TCGA_cor <- apply(LUAD_TCGA_expr,1,cor_estimate)
BUB1B_cor$TCGA_p_value <- apply(LUAD_TCGA_expr,1,cor_p_value)
BUB1B_cor$TCGA_p_adj <- p.adjust(BUB1B_cor$TCGA_p_value)

a <- BUB1B_cor[BUB1B_cor$drug_cor>0.5&BUB1B_cor$TCGA_cor>0.5,1]
a <- bitr(a,
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名
#可以看到，在正常状态下与药物作用下与BUB1B都高度相关的基因（>0.5），它富集到的普遍是DNA复制检查点和G2/M检查点，以此可以解释为什么BUB1B在药物作用下会升高
p <- barplot(a,label_format = 60)
pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig5G.pdf',sep = ''), width=8, height=3)
print(p,newpage = F)
dev.off()

#分析SW1573和A549的有丝分裂活性
library(stringr)
# cell_lines_backgroud <- read.table('/database/GDSC/backgroud_expression/Cell_line_RMA_proc_basalExp.txt',header = T,sep = '\t',fill=T)
cell_lines_backgroud <- read.csv('/database/GDSC/backgroud_expression/Cell_line_RMA_proc_basalExp.csv',header = T)
cell_lines_backgroud <- cell_lines_backgroud[cell_lines_backgroud[,1]!='',]
cell_lines_backgroud <- cell_lines_backgroud[!duplicated(cell_lines_backgroud[,1]),]
rownames(cell_lines_backgroud) <- cell_lines_backgroud[,1]
cell_lines_backgroud <- cell_lines_backgroud[,-1:-2]
cell_line_name <- read.table('/database/GDSC/backgroud_expression/E-MTAB-3610.sdrf.txt',sep = '\t',header = T)
a <- colnames(cell_lines_backgroud)
a <- str_split(a,'[.]',simplify = T)
for (i in 1:nrow(a)) {
  a[grep(pattern=a[i,2],cell_line_name[,1]),3] <- cell_line_name[i,3]
}
colnames(cell_lines_backgroud) <- a[,3]

#计算所有样本的normal_score,mitotic_score,immune_score
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

immune_gene <- read.csv('/database/genemarker/PMID31126321/immune_cell_marker.csv')
immune_gene <- immune_gene[immune_gene$B.cells>100|immune_gene$Macrophages.M2>100|
                             immune_gene$T.cells.CD8>100|immune_gene$Tregs>100,1]
# a <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic nuclear division.txt',sep = '\t')
mitotic_gene <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic nuclear division.txt',sep = '\t')
mitotic_gene <- unique(mitotic_gene$V1)
# colnames(geneset) <- 'EMT_score'
gs <- list()
gs[[1]] <- EMT_gene$Gene
gs[[2]] <- mitotic_gene
gs[[3]] <- immune_gene
names(gs) <- c('EMT_score','mitotic_score','immune_score')

library(GSVA)
a <- as.matrix(cell_lines_backgroud)
a <- gsva(a,
          gs, method = "ssgsea",
          kcdf="Gaussian",
          ssgsea.norm = TRUE,
          verbose = TRUE)
a <- as.data.frame(t(a))
a[c('SW1573','A549'),]





#fig6
####FIG6的修改
####LUAD的模型构建与验证
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据
lifetime <- list()
for (i in 1:15) {
  lifetime[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/',cancer_name[i],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[[i]][,6] <- gsub('-','.',lifetime[[i]][,6])
  expression_raw[[i]] <- expression_raw[[i]][,which(colnames(expression_raw[[i]]) %in% lifetime[[i]][,6])]
  lifetime[[i]] <- lifetime[[i]][which(lifetime[[i]][,6] %in% colnames(expression_raw[[i]])),]
  lifetime[[i]] <- lifetime[[i]][which(!duplicated(lifetime[[i]][,6])),]
  lifetime[[i]]$Sample.ID <- factor(lifetime[[i]]$Sample.ID, levels = colnames(expression_raw[[i]]))
  lifetime[[i]] <- lifetime[[i]][order(lifetime[[i]]$Sample.ID),]
  lifetime[[i]][which(lifetime[[i]][,2]=='Alive'),2] <- 0
  lifetime[[i]][which(lifetime[[i]][,2]=='Dead'),2] <- 1
}
names(lifetime) <- cancer_name
library('DESeq2')
library('survival')
library('survminer')
library('dplyr')
library('glmnet')
library('ggplot2')
library('GGally')
library('rms')
library('survivalROC')
library('plotROC')
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in 1:ncol(risk_score_table)){
    risk_score_table[,each_sig_gene] <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[colnames(risk_score_table)[each_sig_gene],1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
##对5年生存的预测
for (j in 8) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    names(y) <- c('time', 'status')
    y$time <- as.double(y$time)
    y$status <- as.double(y$status)
    y <- as.matrix(survival::Surv(y$time, y$status))
    x <- x[y[,1]>0,]
    y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    Active.Index <- which(as.numeric(coefficient) != 0)
    active.coefficients <- as.numeric(coefficient)[Active.Index]
    sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    #formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    #correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)#5cm*9cm
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      #scale_color_gradient(high="#F20808",low="#1E08F7")+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                           conf.int = F,    # 显示置信区间
                                           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                           add.all = F,     # 添加总患者生存曲线
                                           palette = "hue",    # 自定义调色板
                                           surv.median.line = "hv",     # 添加中位生存时间线
                                           risk.table = F,             # 添加风险表
                                           xlab = "Follow up time(d)", # 指定x轴标签
                                           legend = c(0.8,0.9),         # 指定图例位置
                                           title = c('LUAD_predict'),                 # 设置图例标题
                                           #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                           break.x.by = 365,# 设置x轴刻度间距
                                           pval.method=T)
    predict_effect[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点 #4cm*5cm
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证
ver_expr_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/tumor_CPTAC_LUAD_immune.csv',row.names = 1)
for (j in 8) {
  ##计算基因模型风险评分
  tryCatch({
    predict_effect_ver[[j]] <- list()
    gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
    expr_data <- ver_expr_data
    rownames(expr_data) <- gsub('-','_',rownames(expr_data))
    expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
    expr_data <- log2(expr_data+1)
    life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
    life_data[life_data[,2]=='Alive',2] <- 1
    life_data[life_data[,2]=='Dead',2] <- 0
    life_data <- life_data[,c(1,6,5,2)]
    life_data[,2] <- gsub('-','.',life_data[,2])
    life_data[,2] <- gsub(', ','..',life_data[,2])
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
    
    #calculate the risk score of each sample.
    candidate_genes_for_cox2 <- gene_list
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_Validation'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)
    predict_effect_ver[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect_ver[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点#4cm*5cm
  })
}


#fig8A
#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%hub_gene[[2]][,1]),]))
# for (i in 1:ncol(data)) {
#   data[,i] <- scale(as.numeric(data[,i]))
# }
data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = 'V1',all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IM'
annotation_col[annotation_col[,1]==2,1] <- 'IL'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm


a <- t(a)
# bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#E8C42B", LumB="#D64A16",Her2="#18499E",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "#86C18C",IM = '#4B8ECC',IH = "#DF5160")) 
# a <- t(data)
plot <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                           annotation_colors = ann_colors,
                           clustering_method = 'ward.D2', 
                           color = c(colorRampPalette(c("navy", "white"))(100),
                                     colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                           cluster_cols = F,cluster_rows = T,treeheight_row = 3,
                           annotation_col = annotation_col
                           # ,breaks = bk
)#5*8
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8A.pdf',sep = ''), width=8, height=5)
print(plot,newpage = F)
dev.off()
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
write.csv(annotation_col,'Table6.csv')

#聚类生存分析
library(survival)
library(survminer)
b <- lifetime_all[[2]]
b <- b[b[,6]%in%rownames(annotation_col),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.2,0.2),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#86C18C","#DF5160",'#4B8ECC'),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8C.pdf',sep = ''), width=5, height=4)
print(plot,newpage = F)
dev.off()

##画柱状图看统计情况堆叠柱状图
for (i in 1:nrow(b)) {
  b[i,8] <- annotation_col[rownames(annotation_col)==b[i,6],2]
}
library(tidyr)
subtype_sum <- data.frame()
for (i in 1:3) {
  subtype_sum[1,i] <- length(which(b[b[,7]==c('IH','IM','IL')[i],8]=='LumA'))
  subtype_sum[2,i] <- length(which(b[b[,7]==c('IH','IM','IL')[i],8]=='LumB'))
  subtype_sum[3,i] <- length(which(b[b[,7]==c('IH','IM','IL')[i],8]=='Her2'))
  subtype_sum[4,i] <- length(which(b[b[,7]==c('IH','IM','IL')[i],8]=='Basal'))
}
colnames(subtype_sum) <- c('IH','IM','IL')
rownames(subtype_sum) <- c('LumA','LumB','Her2','Basal')
subtype_sum <- apply(subtype_sum, 2, function(x){x/sum(x)})
subtype_sum <- as.data.frame(subtype_sum)
subtype_sum[1:4,4] <- rownames(subtype_sum)
colnames(subtype_sum)[4] <- 'subtype'
subtype_sum <- pivot_longer(data = subtype_sum,cols = 1:(ncol(subtype_sum)-1),
                            names_to = "cluster",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$subtype <- factor(subtype_sum$subtype,levels = c('LumA','LumB','Her2','Basal'))
subtype_sum$cluster <- factor(subtype_sum$cluster,levels = c('IL','IM','IH'))

p <- ggplot(subtype_sum, aes(x=cluster, y=percents,fill=subtype)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack",color="black", width=0.6,size=0.25)+
  scale_fill_manual(values=c("#F2CA20","#E24A0E","blue",'gray'))+
  labs(x = "",y = "Percent")+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()#6cm*5cm
p#6cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8E.pdf',sep = ''), width=5, height=6)
print(p,newpage = F)
dev.off() 

#亚型生存曲线
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime_all[[2]]
b <- b[b[,6]%in%rownames(annotation_col),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.2,0.2),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#18499E","gray","#E8C42B","#D64A16"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8B.pdf',sep = ''), width=5, height=4)
print(plot,newpage = F)
dev.off()

####分析主要是哪种免疫细胞在起作用





####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 1:15) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:10,])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%hub_gene[[i]][,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name

bk = unique(c(seq(-1,1, length=200)))
plot <- pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T,
                           treeheight_row = 8,treeheight_col = 8)#8cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8D.pdf',sep = ''), width=8, height=8)
print(plot,newpage = F)
dev.off()

#突变分析
library(scales)
#fig8D
##查看免疫浸润高低的突变差异
BRCA_mut_raw <- read.maf(maf = '/database/TCGA/BRCA/mutation/TCGA_BRCA_mutation.maf',clinicalData = '/database/TCGA/BRCA/mutation/clinical.tsv')
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

a <- rownames(annotation_col)
a <- substring(text = a,first = 1,last = 12)
IL_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IL'],]
IM_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IM'],]
IH_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IH'],]

write.table(IL_mut,'result/BRCA/mutation/IL_mut_new.maf',sep = '\t',quote = F,row.names = F)
write.table(IM_mut,'result/BRCA/mutation/IM_mut_new.maf',sep = '\t',quote = F,row.names = F)
write.table(IH_mut,'result/BRCA/mutation/IH_mut_new.maf',sep = '\t',quote = F,row.names = F)

IL_mut <- read.maf(maf ='result/BRCA/mutation/IL_mut_new.maf')
IM_mut <- read.maf(maf ='result/BRCA/mutation/IM_mut_new.maf')
IH_mut <- read.maf(maf ='result/BRCA/mutation/IH_mut_new.maf')
#突变负荷差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_mut)
TMB[[2]] <- tmb(maf = IM_mut)
TMB[[3]] <- tmb(maf = IH_mut)
names(TMB) <- c('IL_mut','IM_mut','IH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_mut',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_mut',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_mut','IM_mut','IH_mut'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

library(ggplot2)
library(ggpubr)
library(scales)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL_mut','IM_mut'),c('IM_mut','IH_mut'),c('IL_mut','IH_mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(7,7,8),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig8/V5/fig8F.pdf",width = 4,height = 5)
print(a,newpage = F)
dev.off()
#差异突变
IL_mut_vs_IM_mut <- mafCompare(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL_mut', m2Name = 'IM_mut', minMut = 2, useCNV =FALSE)
IM_mut_vs_IH_mut <- mafCompare(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
IL_mut_vs_IH_mut <- mafCompare(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)


forestPlot(mafCompareRes = IL_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
r1<-IL_mut_vs_IM_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V5/fig8G.pdf",width = 12,height = 3)
coOncoplot(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL', m2Name = 'IM', genes = g, removeNonMutated = T)
dev.off()

r1<-IM_mut_vs_IH_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V5/fig8H.pdf",width = 12,height = 3)
coOncoplot(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = T)
dev.off()

r1<-IL_mut_vs_IH_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V5/fig8I.pdf",width = 12,height = 3)
coOncoplot(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = T)
dev.off()

#对10种免疫细胞都做一下比较，看看是哪种细胞的浸润影响大
##fig8C
# 判断是什么免疫细胞
data <- expression_raw[[2]][1:10,]
# for (i in 1:10) {
#   data[,i] <- log2(as.numeric(data[,i])+1)
# }
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)

for (i in 1:10) {
  a <- data.frame(sample=colnames(data))
  a$immune_cell <- as.numeric(data[i,])
  a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
  a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IM']] <- 'IM'
  a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
  a <- a[!is.na(a$group),]
  a$immune_cell <- a$immune_cell*100
  a$group <- factor(a$group,levels = c('IL','IM','IH'))
  plot <- ggplot(a, aes(fill=group, y=immune_cell, x=group)) +
    geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
    labs(title = rownames(data)[i], y='immune_cell_rate(%)', x = 'cluster')+
    theme_classic()+
    scale_y_continuous(expand = c(0,0),limits = c(0,mean(a$immune_cell)+6))+
    geom_signif(comparisons = list(c("IL",'IM'),c("IM","IH"),c("IL","IH")), 
                map_signif_level = TRUE, test = t.test, y_position = c((mean(a$immune_cell)),(mean(a$immune_cell)),(mean(a$immune_cell)+1)),
                tip_length = c(0.003,0.003,0.003))#5cm*4cm
  pdf(paste('result/Figure/AI_plot_new/fig8/V5/sfig/sfig_',rownames(data)[i],'.pdf',sep = ''), width=6, height=4)
  print(plot,newpage = F)
  dev.off()
}
which(rownames(surv_data[[2]][[1]])=='CDH1')

#fig8B 肿瘤新抗原的生成
b <- annotation_col
b$sample_id <- rownames(b)
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
BRCA_newantigen <- read.table('/database/TCIA/BRCA/Neoantigens/TCIA-NeoantigensData.tsv',header = T)
BRCA_newantigen$patient <- gsub(pattern = '-',replacement = '.',x = BRCA_newantigen$patientBarcode)
for (i in 1:nrow(b)) {
  a <- BRCA_newantigen[BRCA_newantigen$patient==b$patient[i],]
  b$neoantigens[i] <- nrow(a)
}
b$cluster <- factor(b$cluster,levels = c('IL','IM','IH'))
b$neoantigens <- b$neoantigens+1
a <- ggplot(b, aes(x=cluster, y=neoantigens,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(12,12,13),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm



#fig8C TMB的比较
#突变负荷差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_mut)
TMB[[2]] <- tmb(maf = IM_mut)
TMB[[3]] <- tmb(maf = IH_mut)
names(TMB) <- c('IL_mut','IM_mut','IH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_mut',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_mut',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_mut','IM_mut','IH_mut'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

library(scales)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL_mut','IM_mut'),c('IM_mut','IH_mut'),c('IL_mut','IH_mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(7,7,8),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig8/V5/fig8F.pdf",width = 4,height = 5)
print(a,newpage = F)
dev.off()

#fig9A CDH1突变的差异对CDH1表达量的影响
a <- expression[[2]][c('CDH1','CDH2','VIM'),]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
a <- BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='CDH1']
b$CDH1_mut[b$patient%in%a] <- 'mut'
b$CDH1_mut[!b$patient%in%a] <- 'wt'

a <- ggplot(b, aes(x=CDH1_mut, y=CDH1,fill=CDH1_mut)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

#fig9B 分析CDH1表达量和免疫浸润的相关性
a <- expression_raw[[2]][1:11,]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
cor.test(b$CDH1,b$`T cell CD8+`,method = 'spearman')

a <- b
# a$CDH1 <- -1*a$CDH1
# a$CDH1 <- 1/a$CDH1

# ggscatter(a,x="CDH1",y="T cell CD8+",color = 'steelblue',add = "reg.line",conf.int = F)+
#   labs(y = "CDH1_expression",
#        x = "Days post-symptom onset")+
#   geom_point(color = "steelblue", size = 2)+
#   geom_smooth(color="red",method="lm",se=FALSE)+
#   stat_cor(label.x = 8, label.y = 0.2,method = 'spearman')+
#   scale_y_continuous(expand = c(0,0),n.breaks = 5)+scale_x_continuous(expand = c(0,0),n.breaks = 5)

ggplot(a, aes(x = CDH1, y = `T cell CD8+`)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'T cell CD8+', title = 'CDH1_CD8+', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,0.22))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 8, label.y = 0.2,method = 'spearman')

#fig9CD CDH1表达量与VIM和CDH2含量的相关性，猜测CDH1可能是通过EMT进行调控
cor.test(b$CDH1,b$CDH2,method = 'spearman')
cor.test(b$CDH1,b$VIM,method = 'spearman')
cor.test(b$CDH1[b$CDH1_mut=='mut'],b$CDH2[b$CDH1_mut=='mut'],method = 'spearman')
cor.test(b$CDH1[b$CDH1_mut=='mut'],b$VIM[b$CDH1_mut=='mut'],method = 'spearman')
cor.test(b$CDH1[b$CDH1_mut=='wt'],b$CDH2[b$CDH1_mut=='wt'],method = 'spearman')
cor.test(b$CDH1[b$CDH1_mut=='wt'],b$VIM[b$CDH1_mut=='wt'],method = 'spearman')
cor.test(b$CDH2[b$CDH1_mut=='wt'],b$VIM[b$CDH1_mut=='wt'],method = 'spearman')

p <- ggplot(a, aes(x=CDH1_mut, y=VIM,fill=CDH1_mut)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

p <- ggplot(a, aes(x=CDH1_mut, y=CDH2,fill=CDH1_mut)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

a$CDH1_level[a$CDH1>mean(a$CDH1)] <- 'high'
a$CDH1_level[a$CDH1<=mean(a$CDH1)] <- 'low'
p <- ggplot(a, aes(x=CDH1_level, y=CDH2,fill=CDH1_level)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('low','high')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

p <- ggplot(a, aes(x=CDH1_level, y=VIM,fill=CDH1_level)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('low','high')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

#fig9E 分析CDH1突变的细胞系中上皮基因表达的变化
#证明EMT可能是造成差异的原因之一

#fig9A
b <- annotation_col
b$sample_id <- rownames(b)
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
BRCA_newantigen <- read.table('/database/TCIA/BRCA/Neoantigens/TCIA-NeoantigensData.tsv',header = T)
BRCA_newantigen$patient <- gsub(pattern = '-',replacement = '.',x = BRCA_newantigen$patientBarcode)
for (i in 1:nrow(b)) {
  a <- BRCA_newantigen[BRCA_newantigen$patient==b$patient[i],]
  b$neoantigens[i] <- nrow(a)
}
b$cluster <- factor(b$cluster,levels = c('IL','IM','IH'))
b$neoantigens <- b$neoantigens+1

a <- expression_raw[[2]][1:11,]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
b$immune_score <- b$`B cell`+b$`Macrophage M2`+b$`T cell CD8+`

a <- ggplot(b, aes(x=cluster, y=immune_score,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  labs(x = 'cluster', y = 'immune_cell(%)', subtitle = '')+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1,1,1.1),
              tip_length = c(0,0,0))#5cm*4cm

a <- ggplot(b,aes(x=cluster, y=immune_score))+
  geom_violin(aes(fill=cluster),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#FB5554','#4B87BF','#84BB88'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'cluster', y = 'immune_cell_rate')+
  scale_y_continuous(expand = c(0,0),limits = c(0,1))+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.8,0.8,0.9),
              tip_length = c(0,0,0))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig9/V5/fig9A.pdf",width = 8,height = 10)
print(a,newpage = F)
dev.off()
#画出所有类型的免疫细胞比例
b <- annotation_col
b$sample_id <- rownames(b)
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
BRCA_newantigen <- read.table('/database/TCIA/BRCA/Neoantigens/TCIA-NeoantigensData.tsv',header = T)
BRCA_newantigen$patient <- gsub(pattern = '-',replacement = '.',x = BRCA_newantigen$patientBarcode)
for (i in 1:nrow(b)) {
  a <- BRCA_newantigen[BRCA_newantigen$patient==b$patient[i],]
  b$neoantigens[i] <- nrow(a)
}
b$cluster <- factor(b$cluster,levels = c('IL','IM','IH'))
b$neoantigens <- b$neoantigens+1

a <- expression_raw[[2]][1:11,]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
b$immune_score <- 1-b$`uncharacterized cell`

immune_cell_type <- colnames(a)[1:10]
for (i in 1:10) {
  plot <- b[,c(2,5+i)]
  colnames(plot)[2] <- 'immune_cell'
  plot <- ggplot(plot,aes(x=cluster, y=immune_cell))+
    geom_violin(aes(fill=cluster),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
    scale_fill_manual(values = c('#FB5554','#4B87BF','#84BB88'))+
    geom_boxplot(width=0.1,cex=1.2)+
    theme_classic(base_size = 20)+
    theme(axis.text = element_text(color = 'black'),
          legend.position = 'none')+
    labs(y = immune_cell_type[i])+
    scale_y_continuous(expand = c(0,0),limits = c(0,max(plot[,2])+0.3))+
    geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
                map_signif_level = TRUE, test = t.test, y_position = c(max(plot[,2])+0.1,max(plot[,2])+0.1,max(plot[,2])+0.2),
                tip_length = c(0,0,0))#5cm*4cm
  pdf(paste0("result/Figure/total Figure/sfig3/",immune_cell_type[i],'.pdf'),width = 6,height = 6)
  print(plot,newpage = F)
  dev.off()
}


#fig9B
a <- expression[[2]][c('CDH1','CDH2','VIM'),]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
a <- BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='CDH1']
b$CDH1_mut[b$patient%in%a] <- 'mut'
b$CDH1_mut[!b$patient%in%a] <- 'wt'
a <- ggplot(b, aes(x=CDH1_mut, y=CDH1,fill=CDH1_mut)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  labs(x = 'CDH1_type', y = 'CDH1_expression', title = '', subtitle = '')+
  theme_classic()+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(2000),
              tip_length = c(0))#5cm*4cm
b$CDH1_mut <- factor(x = b$CDH1_mut,levels = c('wt','mut'))
a <- ggplot(b, aes(x=CDH1_mut, y=CDH1))+
  geom_violin(aes(fill=CDH1_mut),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_type', y = 'CDH1_expression')+
  scale_y_continuous(expand = c(0,0),limits = c(0,2500))+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(2200),
              tip_length = c(0))#5cm*4cm
a <- ggplot(b, aes(x=CDH1_mut, y=CDH2))+
  geom_violin(aes(fill=CDH1_mut),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_type', y = 'CDH2_expression')+
  scale_y_continuous(expand = c(0,0),limits = c(0,600))+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(610),
              tip_length = c(0))#5cm*4cm
a <- ggplot(b, aes(x=CDH1_mut, y=VIM))+
  geom_violin(aes(fill=CDH1_mut),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_type', y = 'VIM_expression')+
  scale_y_continuous(expand = c(0,0),limits = c(0,2000))+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(2000),
              tip_length = c(0))#5cm*4cm
a <- ggplot(b, aes(x=CDH1_mut, y=EMT_score))+
  geom_violin(aes(fill=CDH1_mut),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_type', y = 'EMT_expression')+
  scale_y_continuous(expand = c(0,0),limits = c(0,2))+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.5),
              tip_length = c(0))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig9/V5/fig9B.pdf",width = 8,height = 10)
print(a,newpage = F)
dev.off()
'immune_cell(%)'

#fig9C
b$CDH1_level[b$CDH1>median(b$CDH1)] <- 'high'
b$CDH1_level[b$CDH1<=median(b$CDH1)] <- 'low'
# b$immune_score <- b$`B cell`+b$`Macrophage M2`+b$`T cell CD8+`
b$immune_score <- 1-b$`uncharacterized cell`

a <- ggplot(b, aes(x=CDH1_level, y=immune_score,fill=CDH1_level)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('high','low')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1),
              tip_length = c(0))#5cm*4cm
a <- ggplot(b, aes(x=CDH1_level, y=immune_score)) +
  geom_violin(aes(fill=CDH1_level),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_level', y = 'immune_cell_rate')+
  geom_signif(comparisons = list(c('high','low')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1),
              tip_length = c(0))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig9/V5/fig9C.pdf",width = 8,height = 10)
print(a,newpage = F)
dev.off()
#fig9D
b$VIM_log <- log2(b$VIM+1)
b$CDH1_log <- log2(b$CDH1+1)

a <- ggplot(b, aes(x = CDH1_log, y = VIM_log)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'VIM', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,13))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 2.5, label.y = 12,method = 'spearman')
pdf("result/Figure/AI_plot_new/fig9/V5/fig9D.pdf",width = 8,height = 8)
print(a,newpage = F)
dev.off()

#fig9E
b$CDH2_log <- log2(b$CDH2+1)
b$CDH1_log <- log2(b$CDH1+1)
a <- ggplot(b, aes(x = CDH1_log, y = CDH2_log)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'CDH2', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,8))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 2.5, label.y = 7.5,method = 'spearman')
pdf("result/Figure/AI_plot_new/fig9/V5/fig9E.pdf",width = 8,height = 8)
print(a,newpage = F)
dev.off()

#fig9F
library(GSVA)
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]
#单样本GSEA
geneset <- as.data.frame(EMT_gene$Gene)
colnames(geneset) <- 'EMT_score'
gs[[1]] <- gs[[1]][gs[[1]]%in%rownames(expression[[2]])]
gs <- as.list(geneset)

a <- as.matrix(log2(expression[[2]]+1))
a <- gsva(a,
          gs, method = "ssgsea", 
          kcdf="Gaussian",
          ssgsea.norm = TRUE, 
          verbose = TRUE)
a <- as.data.frame(t(a))
a$patient <- substring(text = rownames(a),first = 1,last = 12)
colnames(b)
b <- merge(b,a,by='patient',all=F)
b$EMT_score <- as.numeric(b$EMT_score)
a <- ggplot(b, aes(x = CDH1, y = EMT_score)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'EMT_score', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,1))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 0.5, label.y = 0.5,method = 'spearman')

a <- ggplot(b, aes(x = EMT_score, y = immune_score)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'EMT_score', y = 'immune_cell_rate', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,1))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 0.5, label.y = 0.5,method = 'spearman')

pdf("result/Figure/AI_plot_new/fig9/V5/fig9F.pdf",width = 8,height = 8)
print(a,newpage = F)
dev.off()

#fig9G/H用切片图像


#fig10
#通过对这两种特征突出的癌症进行分析，我们发现mitotic,间质,immune是重要的和预后相关的基因集合
#因此，我们认为可以尝试将这三个基因集合对所有癌症的预后进行量化预测，我们通过ssGSEA对所有癌症的
#的三个基因集评分进行计算，发现三种评分足以覆盖所有的癌症预后，因此我们使用他们对每一种癌症进行cox回归分析
#进行预后预测
#因此，用EMT基因集中的间质细胞marker作为基因集来计算

#计算所有样本的normal_score,mitotic_score,immune_score
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

immune_gene <- read.csv('/database/genemarker/PMID31126321/immune_cell_marker.csv')
immune_gene <- immune_gene[immune_gene$B.cells>100|immune_gene$Macrophages.M2>100|
                             immune_gene$T.cells.CD8>100|immune_gene$Tregs>100,1]

# a <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic nuclear division.txt',sep = '\t')
mitotic_gene <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic nuclear division.txt',sep = '\t')
mitotic_gene <- unique(mitotic_gene$V1)[-1]

# colnames(geneset) <- 'EMT_score'
gs <- list()
gs[[1]] <- EMT_gene$Gene
gs[[2]] <- mitotic_gene
gs[[3]] <- immune_gene
names(gs) <- c('EMT_score','mitotic_score','immune_score')
a <- data.frame()
a[1,1:173] <- gs[[1]]
a[2,1:176] <- gs[[2]]
a[3,1:50] <- gs[[3]]
rownames(a)[1:3] <- names(gs)
write.csv(a,'Table7.csv')

prog_marker <- list()
for (i in 1:15) {
  a <- as.matrix(log2(expression[[i]]+1))
  a <- gsva(a,
            gs, method = "ssgsea",
            kcdf="Gaussian",
            ssgsea.norm = TRUE,
            verbose = TRUE)
  a <- as.data.frame(t(a))
  prog_marker[[i]] <- a
}
names(prog_marker) <- cancer_name

for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- data.frame(row.names = rownames(a))
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'EMT_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'EMT_low'
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- data.frame(row.names = rownames(a))
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'immune_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'immune_low'
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- rownames(prog_marker[[i]])
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'mitotic_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'mitotic_low'
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_mitotic')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/',cancer_name[i],'.pdf',sep = ''), width=12, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#median

#TCGA33种癌症#取一种方法的结果进行展示，其他两种放supplymental
library(GSVA)
mitotic_gene <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic nuclear division.txt',sep = '\t')
# mitotic_gene <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/regulation of nuclear division.txt',sep = '\t')

mitotic_gene <- unique(mitotic_gene$V1)
mitotic_gene <- mitotic_gene[mitotic_gene%in%rownames(TCGA_expr[[1]])]
# mitotic_gene <- as.matrix(mitotic_gene)
# mitotic_gene <- as.character(mitotic_gene)
# mitotic_gene <- mitotic_gene[mitotic_gene!='']

TCGA_cancer <- read.csv('/database/TCGA/TCGA_new_version/TCGA_cancer.csv',row.names = 1)
gs <- list()
gs[[1]] <- EMT_gene$Gene
gs[[2]] <- mitotic_gene
gs[[3]] <- immune_gene
names(gs) <- c('EMT_score','mitotic_score','immune_score')
# TCGA_expr <- list()
prog_marker <- list()
surv_median <- data.frame(row.names = TCGA_cancer$x)
for (i in 1:33) {
  # TCGA_expr[[i]] <- read.csv(paste0('/database/TCGA/TCGA_new_version/Database/',TCGA_cancer[i,1],'/',TCGA_cancer[i,1],'_tumor.csv'),row.names = 1)
  prog_marker[[i]] <- gsva(as.matrix(TCGA_expr[[i]]),
                           gs, method = "ssgsea",
                           kcdf="Gaussian",
                           ssgsea.norm = TRUE,
                           verbose = TRUE)
  prog_marker[[i]] <- as.data.frame(t(prog_marker[[i]]))
  prog_marker[[i]]$patient <- substring(rownames(prog_marker[[i]]),1,12)
  b <- read.csv(paste0('/database/TCGA/TCGA_new_version/Database/',TCGA_cancer[i,1],'/',TCGA_cancer[i,1],'_survival.csv'))
  colnames(b)[2] <- 'patient'
  b$patient <- gsub(b$patient,pattern = '-',replacement = '.')
  b <- merge(b,prog_marker[[i]],by='patient',all=F)
  b$vital_status[which(b$OS_time > 3650)] <- 0
  b$OS_time[which(b$OS_time > 3650)] <- 3650
  
  b$level[b$EMT_score>median(b$EMT_score)] <- 'EMT_high'
  b$level[b$EMT_score<=median(b$EMT_score)] <- 'EMT_low'
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_median$EMT_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_EMT')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('EMT_low','EMT_high'))##对齐坐标轴原点#4cm*5cm
  
  b$level[b$mitotic_score>median(b$mitotic_score)] <- 'mitotic_high'
  b$level[b$mitotic_score<=median(b$mitotic_score)] <- 'mitotic_low'
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_median$mitotic_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_mitotic')),# 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5cm
  
  b$level[b$immune_score>median(b$immune_score)] <- 'immune_high'
  b$level[b$immune_score<=median(b$immune_score)] <- 'immune_low'
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_median$immune_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/median/',TCGA_cancer[i,1],'.pdf',sep = ''), width=15, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#median
names(prog_marker) <- TCGA_cancer
names(TCGA_expr) <- TCGA_cancer
surv_hierarchical <- data.frame(row.names = TCGA_cancer$x)
for (i in 1:33) {
  # TCGA_expr[[i]] <- read.csv(paste0('/database/TCGA/TCGA_new_version/Database/',TCGA_cancer[i,1],'/',TCGA_cancer[i,1],'_tumor.csv'),row.names = 1)
  # prog_marker <- gsva(as.matrix(TCGA_expr[[i]]),
  #                     gs, method = "ssgsea",
  #                     kcdf="Gaussian",
  #                     ssgsea.norm = TRUE,
  #                     verbose = TRUE)
  # prog_marker <- as.data.frame(t(prog_marker))
  # prog_marker$patient <- substring(rownames(prog_marker),1,12)
  prog_marker_score <- prog_marker[[i]]
  b <- read.csv(paste0('/database/TCGA/TCGA_new_version/Database/',TCGA_cancer[i,1],'/',TCGA_cancer[i,1],'_survival.csv'))
  colnames(b)[2] <- 'patient'
  b$patient <- gsub(b$patient,pattern = '-',replacement = '.')
  b <- merge(b,prog_marker_score,by='patient',all=F)
  b$vital_status[which(b$OS_time > 3650)] <- 0
  b$OS_time[which(b$OS_time > 3650)] <- 3650
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- substring(rownames(prog_marker[[i]]),1,12)
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'EMT_low'
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'EMT_high'
  }else{
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'EMT_low'
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'EMT_high'}
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_hierarchical$EMT_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_EMT')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('EMT_low','EMT_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- substring(rownames(prog_marker[[i]]),1,12)
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'mitotic_low'
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'mitotic_high'
  }else{
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'mitotic_low'
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'mitotic_high'}
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_hierarchical$mitotic_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_mitotic')),# 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- substring(rownames(prog_marker[[i]]),1,12)
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'immune_low'
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'immune_high'
  }else{
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'immune_low'
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'immune_high'}
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_hierarchical$immune_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/hierarchical/',TCGA_cancer[i,1],'.pdf',sep = ''), width=15, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#层次聚类 
surv_kmeans <- data.frame(row.names = TCGA_cancer$x)
for (i in 1:33) {
  # TCGA_expr[[i]] <- read.csv(paste0('/database/TCGA/TCGA_new_version/Database/',TCGA_cancer[i,1],'/',TCGA_cancer[i,1],'_tumor.csv'),row.names = 1)
  # prog_marker <- gsva(as.matrix(TCGA_expr[[i]]),
  #                     gs, method = "ssgsea",
  #                     kcdf="Gaussian",
  #                     ssgsea.norm = TRUE,
  #                     verbose = TRUE)
  # prog_marker <- as.data.frame(t(prog_marker))
  # prog_marker$patient <- substring(rownames(prog_marker),1,12)
  prog_marker_score <- prog_marker[[i]]
  b <- read.csv(paste0('/database/TCGA/TCGA_new_version/Database/',TCGA_cancer[i,1],'/',TCGA_cancer[i,1],'_survival.csv'))
  colnames(b)[2] <- 'patient'
  b$patient <- gsub(b$patient,pattern = '-',replacement = '.')
  b <- merge(b,prog_marker_score,by='patient',all=F)
  b$vital_status[which(b$OS_time > 3650)] <- 0
  b$OS_time[which(b$OS_time > 3650)] <- 3650
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- substring(rownames(prog_marker[[i]]),1,12)
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'EMT_low'
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'EMT_high'
  }else{
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'EMT_low'
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'EMT_high'}
  
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_kmeans$EMT_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_EMT')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('EMT_low','EMT_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- substring(rownames(prog_marker[[i]]),1,12)
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'mitotic_low'
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'mitotic_high'
  }else{
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'mitotic_low'
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'mitotic_high'}
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_kmeans$mitotic_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_mitotic')),# 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- substring(rownames(prog_marker[[i]]),1,12)
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'immune_low'
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'immune_high'
  }else{
    b$level[b$patient%in%rownames(result)[result[,1]==2]] <- 'immune_low'
    b$level[b$patient%in%rownames(result)[result[,1]==1]] <- 'immune_high'}
  c <- survdiff(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  surv_kmeans$immune_score[i] <- 1-pchisq(c$chisq,1)
  c <- survfit(Surv(b$OS_time,as.numeric(b$vital_status))~b$level, data=b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(TCGA_cancer[i,1],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_y_continuous(expand = c(0,0))+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#D64A16","#18499E"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/kmeans/',TCGA_cancer[i,1],'.pdf',sep = ''), width=15, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#kmeans

library(stringr)
library(tidyr)
#画图
a <- surv_median
a$cancer_type <- rownames(a)
a <- pivot_longer(data = a,cols = 1:3,names_to = 'bio_process',values_to = 'surv_pvalue')
a$surv_pvalue <- -log10(a$surv_pvalue)
c <- str_split(string = a$cancer_type,pattern = '-',simplify = T)
a$cancer_type <- c[,2]

plot <- ggplot(a,aes(x=cancer_type,y=surv_pvalue,fill = bio_process))+
  geom_point(aes(size=1,color=`bio_process`))+
  # scale_color_gradient(high="#F20808",low="#1E08F7")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=90,hjust = 1,vjust=0.5))+
  geom_hline(yintercept = c(-log10(0.05)),linetype = "dashed")+
  # annotate('text',x=150,y=2.2,label=expression('resistant'),size=4,color='red')+
  labs(x=NULL,y='-log10(p_value)',title = 'Survival analysis - Median grouping')#3.54cm*4.34cm
pdf(paste('result/Figure/AI_plot_new/fig10/V5/fig10A.pdf',sep = ''), width=15, height=5)
print(plot,newpage = F)
dev.off()

a <- surv_hierarchical
a$cancer_type <- rownames(a)
a <- pivot_longer(data = a,cols = 1:3,names_to = 'bio_process',values_to = 'surv_pvalue')
a$surv_pvalue[a$surv_pvalue==0] <- 10**(-16)
a$surv_pvalue <- -log10(a$surv_pvalue)
c <- str_split(string = a$cancer_type,pattern = '-',simplify = T)
a$cancer_type <- c[,2]
plot <- ggplot(a,aes(x=cancer_type,y=surv_pvalue,fill = bio_process))+
  geom_point(aes(size=1,color=`bio_process`))+
  # scale_color_gradient(high="#F20808",low="#1E08F7")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=90,hjust = 1,vjust=0.5))+
  geom_hline(yintercept = c(-log10(0.05)),linetype = "dashed")+
  # annotate('text',x=150,y=2.2,label=expression('resistant'),size=4,color='red')+
  labs(x=NULL,y='-log10(p_value)',title = 'Survival analysis - hierarchical grouping')#3.54cm*4.34cm
pdf(paste('result/Figure/AI_plot_new/fig10/V5/fig10B.pdf',sep = ''), width=15, height=5)
print(plot,newpage = F)
dev.off()

a <- surv_kmeans
a$cancer_type <- rownames(a)
a <- pivot_longer(data = a,cols = 1:3,names_to = 'bio_process',values_to = 'surv_pvalue')
a$surv_pvalue[a$surv_pvalue==0] <- 10**(-16)
a$surv_pvalue <- -log10(a$surv_pvalue)
c <- str_split(string = a$cancer_type,pattern = '-',simplify = T)
a$cancer_type <- c[,2]
plot <- ggplot(a,aes(x=cancer_type,y=surv_pvalue,fill = bio_process))+
  geom_point(aes(size=1,color=`bio_process`))+
  # scale_color_gradient(high="#F20808",low="#1E08F7")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=90,hjust = 1,vjust=0.5))+
  geom_hline(yintercept = c(-log10(0.05)),linetype = "dashed")+
  # annotate('text',x=150,y=2.2,label=expression('resistant'),size=4,color='red')+
  labs(x=NULL,y='-log10(p_value)',title = 'Survival analysis - kmeans grouping')#3.54cm*4.34cm
pdf(paste('result/Figure/AI_plot_new/fig10/V5/fig10C.pdf',sep = ''), width=15, height=5)
print(plot,newpage = F)
dev.off()

##kwok提出的点
#fig4G
#################替换为伯努利检验（二项检验）
####Nest定义每个病人
library(stats)
nest_pathway <- read.csv('/database/IAS/NeST Map - Main Model default node.csv')
nest_pathway_list <- list()
for (i in 1:nrow(nest_pathway)) {
  a <- nest_pathway[i,4]
  nest_pathway_list[[i]] <- str_split(a,' ',simplify = F)[[1]]
}
names(nest_pathway_list) <- nest_pathway$Annotation

path_num_cal <- function(x){
  x=nest_pathway_list[[x]]
  length(which(a%in%x))
}
patient_pathway <- list()
patient_id <- unique(LUAD_mut$Tumor_Sample_Barcode)
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]
ref_all_mut_ddc <- all_mut_ddc[all_mut_ddc$p_value<0.05&(!is.na(all_mut_ddc$p_value))&abs(all_mut_ddc$diff_ddc)>0.01,]

AR_signal_pathway <- nest_pathway_list[["Androgen receptor signaling pathway"]]
AR_regulate_pathway <- nest_pathway_list[["Regulation of androgen receptor signaling pathway"]]
ARS <- as.data.frame(t(data.frame(row.names = AR_signal_pathway)))
ARR <- as.data.frame(t(data.frame(row.names = AR_regulate_pathway)))

for (i in 1:length(patient_id)) {
  a <- unique(LUAD_mut$Hugo_Symbol[LUAD_mut$Tumor_Sample_Barcode==patient_id[i]])
  a <- a[a%in%ref_all_mut_ddc$Gene]
  ARS[i,colnames(ARS)%in%a] <- 1
  ARS[i,!colnames(ARS)%in%a] <- 0
  ARR[i,colnames(ARR)%in%a] <- 1
  ARR[i,!colnames(ARR)%in%a] <- 0
}
rownames(ARS) <- patient_id
rownames(ARR) <- patient_id

pheatmap::pheatmap(ARS)

patient_pathway_table <- data.frame(names(nest_pathway_list))
rownames(patient_pathway_table) <- patient_pathway_table[,1]
for (i in 1:length(patient_pathway)) {
  patient_pathway_table[,i] <- patient_pathway[[i]][,2]
  patient_pathway_table[patient_pathway_table[,i]>0,i] <- 1
  patient_pathway_table[patient_pathway_table[,i]==0,i] <- 0
}
colnames(patient_pathway_table) <- names(patient_pathway)

patient_pathway_table <- patient_pathway_table[apply(patient_pathway_table, 1, sum)>0,]




































#cox回归   
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据
lifetime <- list()
for (i in 1:15) {
  lifetime[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/',cancer_name[i],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[[i]][,6] <- gsub('-','.',lifetime[[i]][,6])
  expression_raw[[i]] <- expression_raw[[i]][,which(colnames(expression_raw[[i]]) %in% lifetime[[i]][,6])]
  lifetime[[i]] <- lifetime[[i]][which(lifetime[[i]][,6] %in% colnames(expression_raw[[i]])),]
  lifetime[[i]] <- lifetime[[i]][which(!duplicated(lifetime[[i]][,6])),]
  lifetime[[i]]$Sample.ID <- factor(lifetime[[i]]$Sample.ID, levels = colnames(expression_raw[[i]]))
  lifetime[[i]] <- lifetime[[i]][order(lifetime[[i]]$Sample.ID),]
  lifetime[[i]][which(lifetime[[i]][,2]=='Alive'),2] <- 0
  lifetime[[i]][which(lifetime[[i]][,2]=='Dead'),2] <- 1
}
names(lifetime) <- cancer_name
library('DESeq2')
library('survival')
library('survminer')
library('dplyr')
library('glmnet')
library('ggplot2')
library('GGally')
library('rms')
library('survivalROC')
library('plotROC')
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in 1:ncol(risk_score_table)){
    risk_score_table[,each_sig_gene] <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[colnames(risk_score_table)[each_sig_gene],1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
##对5年生存的预测
for (j in 1:15) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- as.data.frame(t(prog_marker[[j]]))
    # expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    # x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    # y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    # names(y) <- c('time', 'status')
    # y$time <- as.double(y$time)
    # y$status <- as.double(y$status)
    # y <- as.matrix(survival::Surv(y$time, y$status))
    # x <- x[y[,1]>0,]
    # y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    # lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    # coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    # Active.Index <- which(as.numeric(coefficient) != 0)
    # active.coefficients <- as.numeric(coefficient)[Active.Index]
    # sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    sig_gene_multi_cox <- gene_list
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    #formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    #correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)#5cm*9cm
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    # for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,10,0.2)), risk_score_table = risk_score_table_multi_cox2)
    for_multi_ROC <- multi_ROC(time_vector = c(3650), risk_score_table = risk_score_table_multi_cox2)
    
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      #scale_color_gradient(high="#F20808",low="#1E08F7")+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
    AUC_max_time <- 3650
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    # high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low <- risk_score_table_multi_cox2$total_risk_score
    high_low[risk_score_table_multi_cox2$total_risk_score > median(risk_score_table_multi_cox2$total_risk_score)] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[risk_score_table_multi_cox2$total_risk_score <= median(risk_score_table_multi_cox2$total_risk_score)] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                           conf.int = F,    # 显示置信区间
                                           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                           add.all = F,     # 添加总患者生存曲线
                                           palette = "hue",    # 自定义调色板
                                           surv.median.line = "hv",     # 添加中位生存时间线
                                           risk.table = F,             # 添加风险表
                                           xlab = "Follow up time(d)", # 指定x轴标签
                                           legend = c(0.8,0.9),         # 指定图例位置
                                           title = cancer_name[j],                 # 设置图例标题
                                           #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                           break.x.by = 365,# 设置x轴刻度间距
                                           pval.method=T)
    
    a <- predict_effect[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,3650,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点 #4cm*5cm
    pdf(paste0("result/Figure/AI_plot_new/fig10/V5/fig10F_",cancer_name[j],'.pdf'),width = 6,height = 5)
    print(a,newpage = F)
    dev.off()
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证
ver_expr_data <- list()
for (j in 8) {
  ##计算基因模型风险评分
  tryCatch({
    predict_effect_ver[[j]] <- list()
    gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
    expr_data <- ver_expr_data
    rownames(expr_data) <- gsub('-','_',rownames(expr_data))
    expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
    expr_data <- log2(expr_data+1)
    life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
    life_data[life_data[,2]=='Alive',2] <- 1
    life_data[life_data[,2]=='Dead',2] <- 0
    life_data <- life_data[,c(1,6,5,2)]
    life_data[,2] <- gsub('-','.',life_data[,2])
    life_data[,2] <- gsub(', ','..',life_data[,2])
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
    
    #calculate the risk score of each sample.
    candidate_genes_for_cox2 <- gene_list
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_Validation'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)
    predict_effect_ver[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect_ver[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点#4cm*5cm
  })
}

##对5年生存的预测
prog_marker[[j]]
train_data <- list()
test_data <- list()
for (i in 1:15) {
  train_data[[i]] <- prog_marker[[i]][sample(1:nrow(prog_marker[[i]]),round(nrow(prog_marker[[i]])*0.7)),]
  test_data[[i]] <- prog_marker[[i]][!rownames(prog_marker[[i]])%in%train_data[[i]],]
}
names(train_data) <- cancer_name
names(test_data) <- cancer_name

for (j in 1:15) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- as.data.frame(t(train_data[[j]]))
    # expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    # x <- as.matrix(survival_cancer[,gsub(gene_list, pattern = '-', replacement = '_')])
    # y <- survival_cancer[,c('overall_survival', 'censoring_status')]
    # names(y) <- c('time', 'status')
    # y$time <- as.double(y$time)
    # y$status <- as.double(y$status)
    # y <- as.matrix(survival::Surv(y$time, y$status))
    # x <- x[y[,1]>0,]
    # y <- y[y[,1]>0,]##生存时间不可以有0值，不然会报错
    # lasso_fit <- cv.glmnet(x, y, family='cox', type.measure = 'deviance')
    # coefficient <- coef(lasso_fit, s=lasso_fit$lambda.min)
    # Active.Index <- which(as.numeric(coefficient) != 0)
    # active.coefficients <- as.numeric(coefficient)[Active.Index]
    # sig_gene_multi_cox <- rownames(coefficient)[Active.Index]
    ###
    #使用合格的基因进行多变量cox回归。
    sig_gene_multi_cox <- gene_list
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    #formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    #correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)#5cm*9cm
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    # for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,10,1)), risk_score_table = risk_score_table_multi_cox2)
    for_multi_ROC <- multi_ROC(time_vector = c(3650), risk_score_table = risk_score_table_multi_cox2)
    
    AUC_max <- max(for_multi_ROC$AUC)
    # AUC_max_time <- max(for_multi_ROC$Time_point)
    AUC_max_time <- max(unique(for_multi_ROC$Time_point[for_multi_ROC$AUC==AUC_max]))
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      #scale_color_gradient(high="#F20808",low="#1E08F7")+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect[[j]][[1]] <- pROC
    
    # AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    # AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
    # AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
    # AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
    AUC_max_time <- 3650
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
    # cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    # high_low <- (risk_score_table_multi_cox2$total_risk_score > median(risk_score_table_multi_cox2$total_risk_score))##ROC曲线在对角线上方是>，下方是<
    high_low <- risk_score_table_multi_cox2$total_risk_score
    a <- risk_score_table_multi_cox2$total_risk_score[order(risk_score_table_multi_cox2$total_risk_score,decreasing = F)[round(length(risk_score_table_multi_cox2$total_risk_score)/3)]]
    b <- risk_score_table_multi_cox2$total_risk_score[order(risk_score_table_multi_cox2$total_risk_score,decreasing = F)[round(length(risk_score_table_multi_cox2$total_risk_score)/3*2)]]
    high_low[risk_score_table_multi_cox2$total_risk_score < a] <- 'low'
    high_low[risk_score_table_multi_cox2$total_risk_score >= a & risk_score_table_multi_cox2$total_risk_score <= b] <- 'median'
    high_low[risk_score_table_multi_cox2$total_risk_score > b] <- 'high'
    # high_low <- risk_score_table_multi_cox2$total_risk_score
    # high_low[risk_score_table_multi_cox2$total_risk_score > median(risk_score_table_multi_cox2$total_risk_score)] <- 'high'####ROC曲线在对角线上方是high，下方是low
    # high_low[risk_score_table_multi_cox2$total_risk_score <= median(risk_score_table_multi_cox2$total_risk_score)] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                           conf.int = F,    # 显示置信区间
                                           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                           add.all = F,     # 添加总患者生存曲线
                                           palette = "hue",    # 自定义调色板
                                           surv.median.line = "hv",     # 添加中位生存时间线
                                           risk.table = F,             # 添加风险表
                                           xlab = "Follow up time(d)", # 指定x轴标签
                                           legend = c(0.8,0.9),         # 指定图例位置
                                           title = cancer_name[j],                 # 设置图例标题
                                           #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                           break.x.by = 365,# 设置x轴刻度间距
                                           pval.method=T)
    
    # a <- predict_effect[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,3650,365))+
    # scale_colour_discrete(type = c("red","blue",'green'),
    # breaks = predict_effect[[j]][[2]]$plot$plot_env$legend.labs[c(2,1,3)],#图例位置
    # labels = c("low",'median',"high"))##对齐坐标轴原点 #4cm*5cm
    pdf(paste0("result/Figure/AI_plot_new/fig10/V5/fig10F_",cancer_name[j],'.pdf'),width = 6,height = 5)
    print(predict_effect[[j]][[2]],newpage = F)
    dev.off()
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证
ver_expr_data <- list()
for (j in 8) {
  ##计算基因模型风险评分
  tryCatch({
    predict_effect_ver[[j]] <- list()
    gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
    expr_data <- as.data.frame(t(train_data[[j]]))
    # expr_data <- log2(expr_data+1)
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
    
    #calculate the risk score of each sample.
    candidate_genes_for_cox2 <- gene_list
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_Validation'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)
    predict_effect_ver[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect_ver[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点#4cm*5cm
  })
}













# prog_marker <- list()
# for (i in 1:15) {
#   a <- as.matrix(log2(expression[[i]]+1))
#   a <- gsva(a,
#             gs, method = "ssgsea",
#             kcdf="Gaussian",
#             ssgsea.norm = TRUE,
#             verbose = TRUE)
#   a <- as.data.frame(t(a))
#   c <- as.data.frame(t(expression_raw[[i]][1:11,]))
#   c$immune_score <- c$`B cell`+c$`Macrophage M2`+c$`T cell CD8+`
#   sum(rownames(c)!=rownames(a))
#   a$immune_score <- c$immune_score
#   prog_marker[[i]] <- a
# }
# names(prog_marker) <- cancer_name

for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- rownames(prog_marker[[i]])
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'EMT_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'EMT_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'EMT_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'EMT_low'}
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- rownames(prog_marker[[i]])
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'mitotic_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'mitotic_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'mitotic_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'mitotic_low'}
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_mitotic')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5c
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- rownames(prog_marker[[i]])
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'immune_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'immune_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'immune_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'immune_low'}
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/',cancer_name[i],'.pdf',sep = ''), width=12, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#层次聚类
for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'EMT_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'EMT_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'EMT_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'EMT_low'}
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'immune_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'immune_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'immune_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'immune_low'}
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'mitotic_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'mitotic_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'mitotic_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'mitotic_low'}
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_mitotic')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/',cancer_name[i],'.pdf',sep = ''), width=12, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#Kmeans
for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- data.frame(row.names = rownames(a))
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'EMT_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'EMT_low'
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- data.frame(row.names = rownames(a))
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'immune_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'immune_low'
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- rownames(prog_marker[[i]])
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'mitotic_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'mitotic_low'
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_mitotic')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/',cancer_name[i],'.pdf',sep = ''), width=12, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#median

for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  a <- prog_marker[[i]][,1:3]
  
  result <- data.frame(row.names = rownames(a))
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  # result <- kmeans(a,centers = 2)
  # result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'EMT_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'EMT_low'
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
}#median

# EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
# EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]
# EMT_gene <- EMT_gene[EMT_gene$Gene%in%rownames(expression_raw[[2]]),]
# EMT_cor <- data.frame(row.names = EMT_gene$Gene)
# for (i in 1:nrow(EMT_cor)) {
#   c <- cor.test(as.numeric(expression_raw[[2]]['CDH1',]),as.numeric(expression_raw[[2]][rownames(EMT_cor)[i],]),method = 'spearman')
#   EMT_cor$CDH1[i] <- c$estimate
#   c <- cor.test(as.numeric(expression_raw[[2]]['T cell CD8+',]),as.numeric(expression_raw[[2]][rownames(EMT_cor)[i],]),method = 'spearman')
#   EMT_cor$CD8[i] <- c$estimate
# }


# CDH1_cor <- data.frame(row.names = rownames(expression[[2]]))
# a <- as.numeric(expression[[2]]['CDH1',])
# for (i in 1:nrow(expression[[2]])) {
#   c <- cor.test(a,as.numeric(expression[[2]][i,]),method = 'spearman')
#   CDH1_cor$cor[i] <- c$estimate
#   CDH1_cor$p_value[i] <- c$p.value
# }
# a <- bitr(rownames(CDH1_cor)[CDH1_cor$cor>0.5&!is.na(CDH1_cor$cor)],
#           fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
#           toType = c('ENTREZID'), #totype指需要转换成的ID类型
#           OrgDb='org.Hs.eg.db')
# a <- enrichGO(a[,2], #数据源
#               pvalueCutoff = 0.05, #P值阈值
#               qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
#               OrgDb = org.Hs.eg.db, #人类参考基因组
#               ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
#               readable = TRUE) #是否将基因ID转换为基因名

#fig10A 通过前面的分析我们发现mitotic/immune/EMT三类基因是影响预后的较大因素
#然后通过ssGSEA算法我们计算每一个样本的三种评分，发现三种评分可以显著预测预后
#接下来我们想知道这三种评分用来预测预后的适用范围，因此构建了对每一种癌症都进行
#cox回归，发现效果都不错，接下来将收集了腺癌和乳腺癌的其他数据集进行验证，发现效果都还行。
#




##高频突变中的CDH1提示EMT与免疫浸润的相关性 PMID：30332649
#验证CDH2和VIM在这三组中是否有差异

#通过TCGA切片图像发现，大多数IL组的切片都是含有大量成纤维细胞，而IH组主要为肿瘤细胞
#因此查看了间质细胞marker的指标，发现也支持这一结论
#可以画一下间质marker和CD8浸润的相关性散点图
#首先比较正常组织和肿瘤组织的间质marker和EMT_score
normal_expr <- list()
for (i in 1:15) {
  tryCatch({
    normal_expr[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/normal_TCGA_',cancer_name[i],'_immune.csv',sep = ''),row.names = 1)
    normal_expr[[i]] <- normal_expr[[i]][rownames(normal_expr[[i]])%in%rownames(expression[[i]]),]
  }, error = function(e) {print(i)})
}
names(normal_expr) <- cancer_name

#单样本基因集富集分析
library(GSVA)
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

#单样本GSEA
geneset <- as.data.frame(EMT_gene$Gene)
colnames(geneset) <- 'EMT_score'
gs <- as.list(geneset)
a <- as.matrix(log2(expression[[2]]+1))
a <- gsva(a,
          gs, method = "ssgsea", 
          kcdf="Gaussian",
          ssgsea.norm = TRUE, 
          verbose = TRUE)
a <- as.data.frame(t(a))
a$patient_id <- substring(text = rownames(a),first = 1,last = 12)

b <- as.matrix(log2(normal_expr[[2]]+1))
b <- gsva(b,
          gs, method = "ssgsea", 
          kcdf="Gaussian",
          ssgsea.norm = TRUE, 
          verbose = TRUE)
b <- as.data.frame(t(b))
b$patient_id <- substring(text = rownames(b),first = 1,last = 12)

emt_score <- merge(a,b,by='patient_id',all=F)
colnames(emt_score) <- c('patient_id','tumor_emt','normal_emt')
emt_score <- pivot_longer(emt_score,cols = 2:3,names_to = 'type',values_to = 'emt_score')

plot <- ggplot(emt_score, aes(x=patient_id, y=emt_score,color=type)) + 
  ggtitle("")+
  geom_point(size=1.2,stroke =1)+
  scale_y_continuous(expand = c(0,0),limits = c(0,mean(a$immune_cell)+6))+
  theme_bw()+
  theme(axis.ticks.x = element_blank(),axis.text.x = element_blank())
# geom_hline(yintercept = c(0,2),linetype = "dashed")##画散点图5cm*8cm

pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig10A.pdf',sep = ''), width=8, height=5)
print(plot,newpage = F)
dev.off()

#单样本GSEA
geneset <- as.data.frame(EMT_gene$Gene)
colnames(geneset) <- 'EMT_score'
gs <- as.list(geneset)
a <- as.matrix(log2(expression[[2]]+1))
a <- gsva(a,
          gs, method = "ssgsea", 
          kcdf="Gaussian",
          ssgsea.norm = TRUE, 
          verbose = TRUE)
a <- as.data.frame(t(a))
a$sample <- rownames(a)

emt_score <- merge(a,c,by='sample',all=F)
a <- expression_raw[[2]][1:10,]
a <- as.data.frame(t(a))
a$sample <- rownames(a)
a <- merge(emt_score,a,by='sample',all=F)
cor(a$VIM,a$CDH2,method = 'spearman')



plot <- ggplot(emt_score, aes(x=group, y=EMT_score,color=group)) + 
  ggtitle("")+
  geom_point(size=1.2,stroke =1)+
  scale_y_continuous(expand = c(0,0),limits = c(0,mean(a$immune_cell)+6))+
  theme_bw()+
  theme(axis.ticks.x = element_blank(),axis.text.x = element_blank())
ggplot(emt_score, aes(x=group, y=EMT_score,fill=group)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.5,1.5,1.6),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
# geom_hline(yintercept = c(0,2),linetype = "dashed")##画散点图5cm*8cm

pdf(paste('result/Figure/AI_plot_new/fig5/V5/fig5A.pdf',sep = ''), width=8, height=5)
print(plot,newpage = F)
dev.off()

#如何从乳腺癌关联到正常组织，发现CDH1在三个组中是有显著差异的，所以想到EMT是否也是影响预后的因素之一，
#于是使用EMT marker计算了EMT评分，但是我们发现EMT评分与VIM无相关性，与上皮细胞相关性极高，因此怀疑
#EMT评分实际上不是EMT，而是非肿瘤细胞含量，因此我们比较了正常组织和肿瘤组织的EMT评分，发现正常组织
#EMT评分极高，因此EMT实际上是肿瘤正常组织的含量得分，我们发现它与预后也是相关的，可以作为一个标志物
#
c$cluster <- factor(c$cluster,levels = c('IL','IM','IH'))
ggplot(c, aes(x=cluster, y=EMT_score,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.8,0.8,0.9),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
ggplot(c, aes(x=cluster, y=immune_score,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.5,0.5,0.6),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm

#fig10
#通过对这两种特征突出的癌症进行分析，我们发现mitotic,间质,immune是重要的和预后相关的基因集合
#因此，我们认为可以尝试将这三个基因集合对所有癌症的预后进行量化预测，我们通过ssGSEA对所有癌症的
#的三个基因集评分进行计算，发现三种评分足以覆盖所有的癌症预后，因此我们使用他们对每一种癌症进行cox回归分析
#进行预后预测
#因此，用EMT基因集中的间质细胞marker作为基因集来计算


#计算所有样本的normal_score,mitotic_score,immune_score
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

# CD8_cell_gene <- read.csv('/database/genemarker/PMID31126321/immune_cell_marker.csv')
# CD8_cell_gene <- CD8_cell_gene[CD8_cell_gene$T.cells.CD8>=10,1]

mitotic_gene <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic nuclear division.txt',sep = '\t')
mitotic_gene <- unique(mitotic_gene$V1)

# colnames(geneset) <- 'EMT_score'
gs <- list()
gs[[1]] <- EMT_gene$Gene
# gs[[2]] <- CD8_cell_gene
gs[[2]] <- mitotic_gene
names(gs) <- c('EMT_score','mitotic_score')

# colnames(c)[1] <- 'sample'
# d <- prog_marker[[2]]
# d$sample <- rownames(d)
# c <- merge(c,d,by='sample',all=F)


prog_marker <- list()
for (i in 1:15) {
  a <- as.matrix(log2(expression[[i]]+1))
  a <- gsva(a,
            gs, method = "ssgsea", 
            kcdf="Gaussian",
            ssgsea.norm = TRUE, 
            verbose = TRUE)
  a <- as.data.frame(t(a))
  c <- as.data.frame(t(expression_raw[[i]][11,]))
  c$immune_score <- 1-c$`uncharacterized cell`
  sum(rownames(c)!=rownames(a))
  a$immune_score <- c$immune_score
  prog_marker[[i]] <- a
}
names(prog_marker) <- cancer_name

for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- rownames(prog_marker[[i]])
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'EMT_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'EMT_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'EMT_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'EMT_low'}
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- rownames(prog_marker[[i]])
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'mitotic_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'mitotic_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'mitotic_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'mitotic_low'}
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_mitotic')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5c
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- rownames(prog_marker[[i]])
  dist.e <- dist(a,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'immune_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'immune_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'immune_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'immune_low'}
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/',cancer_name[i],'.pdf',sep = ''), width=12, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#层次聚类
for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'EMT_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'EMT_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'EMT_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'EMT_low'}
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'immune_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'immune_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'immune_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'immune_low'}
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- kmeans(a,centers = 2)
  result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  if (mean(a[rownames(a)%in%rownames(result)[result[,1]==1],1])<mean(a[rownames(a)%in%rownames(result)[result[,1]==2],1])) {
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'mitotic_low'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'mitotic_high'
  }else{
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'mitotic_high'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'mitotic_low'}
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_mitotic')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/',cancer_name[i],'.pdf',sep = ''), width=12, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#Kmeans
for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  
  a <- as.data.frame(prog_marker[[i]][,1])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- data.frame(row.names = rownames(a))
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  # result <- kmeans(a,centers = 2)
  # result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'EMT_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'EMT_low'
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,2])
  rownames(a) <- rownames(prog_marker[[i]])
  result <- data.frame(row.names = rownames(a))
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'immune_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'immune_low'
  
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_immune')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('immune_low','immune_high'))##对齐坐标轴原点#4cm*5cm
  
  a <- as.data.frame(prog_marker[[i]][,3])
  rownames(a) <- rownames(prog_marker[[i]])
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'mitotic_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'mitotic_low'
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_mitotic')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot3 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('mitotic_low','mitotic_high'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig10/V5/',cancer_name[i],'.pdf',sep = ''), width=12, height=5)
  print(plot1|plot2|plot3,newpage = F)
  dev.off()
}#median

for (i in 1:15) {
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(prog_marker[[i]]),]
  a <- prog_marker[[i]][,1:3]
  
  result <- data.frame(row.names = rownames(a))
  result$level[a[,1]>median(a[,1])] <- 'high'
  result$level[a[,1]<=median(a[,1])] <- 'low'
  # result <- kmeans(a,centers = 2)
  # result <- as.data.frame(result$cluster)
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]>=median(prog_marker[[i]][,1])],7] <- 'normal_high'
  # b[b[,6]%in%rownames(prog_marker[[i]])[prog_marker[[i]][,1]<=median(prog_marker[[i]][,1])],7] <- 'normal_low'
  b[b[,6]%in%rownames(result)[result[,1]=='high'],7] <- 'EMT_high'
  b[b[,6]%in%rownames(result)[result[,1]=='low'],7] <- 'EMT_low'
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Time(d)", # 指定x轴标签
                     legend = c(0.6,0.2),         # 指定图例位置
                     title = c(paste0(cancer_name[i],'_normal')),                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 1000,# 设置x轴刻度间距
                     pval.method=T)
  plot1 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#18499E","#D64A16"),
                          labels = c('normal_low','normal_high'))##对齐坐标轴原点#4cm*5cm
}#median
a <- total_result
for (i in 1:15) {
  for (j in 1:15) {
    if (as.numeric(a[j,i])>=0.05) {
      a[j,i] <- 'ns'
    }else{if (as.numeric(a[j,i])<0.05&as.numeric(a[j,i])>=0.005) {
      a[j,i] <- '*'
    }else{if (as.numeric(a[j,i])<0.005&as.numeric(a[j,i])>=0.0005) {
      a[j,i] <- '**'
    }else{if (as.numeric(a[j,i])<0.0005) {
      a[j,i] <- '***'
    }}}}
  }
}





#突变基因的通路富集
a <- IL_mut_vs_IH_mut$results[IL_mut_vs_IH_mut$results$pval<0.05,1]
a <- as.data.frame(a[,1])
a <- bitr(a[,1],
          fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
          toType = c('ENTREZID'), #totype指需要转换成的ID类型
          OrgDb='org.Hs.eg.db')
a <- enrichGO(a[,2], #数据源
              pvalueCutoff = 0.05, #P值阈值
              qvalueCutoff = 0.05, #qvalue是P值的校正值，P值会过滤掉很多，可以全部输出
              OrgDb = org.Hs.eg.db, #人类参考基因组
              ont = "ALL", #主要的分为三种，三个层面来阐述基因功能，生物学过程（BP），细胞组分（CC），分子功能（MF）
              readable = TRUE) #是否将基因ID转换为基因名

##单样本GSEA
#处理EMT基因集
#单样本基因集富集分析
library(GSVA)
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

#单样本GSEA
geneset <- as.data.frame(EMT_gene$Gene)
colnames(geneset) <- 'EMT_score'
gs <- as.list(geneset)
a <- as.matrix(log2(expression[[2]]+1))
ssgsea_score = gsva(a, 
                    gs, method = "ssgsea", 
                    kcdf="Gaussian",
                    ssgsea.norm = TRUE, 
                    verbose = TRUE)
ssgsea_score <- as.data.frame(t(ssgsea_score))
ssgsea_score$sample_id <- rownames(ssgsea_score)
#
b <- merge(a,ssgsea_score,by='sample_id',all=F)

##画图
plot1 <- b
plot1 <- ggplot(plot1, aes(x=cluster, y=EMT_score,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.5),
              tip_length = c(0.03))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8H.pdf',sep = ''), width=5, height=5)
print(plot1,newpage = F)
dev.off()
ks.test(b[b[,2]=='IL',5],b[b[,2]=='IH',5])

####准备ssGSEA数据
##单样本GSEA
#处理EMT基因集
#单样本基因集富集分析
library(GSVA)
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

PPP_gene <- read.table('/database/Gene Ontology/homo_sapiens/PPP/PPP.txt',sep = '\t')
PPP_gene <- PPP_gene[!duplicated(PPP_gene$V1),]

CD8_cell_gene <- read.csv('/database/genemarker/PMID31126321/immune_cell_marker.csv')
CD8_cell_gene <- CD8_cell_gene[CD8_cell_gene$T.cells.CD8>=10,1]

mitotic_gene <- read.table('/database/Gene Ontology/homo_sapiens/mitotic_cell_cycle/mitotic nuclear division.txt',sep = '\t')
mitotic_gene <- unique(mitotic_gene$V1)

#单样本GSEA

colnames(geneset) <- 'EMT_score'
gs <- list()
gs[[1]] <- EMT_gene$Gene
gs[[2]] <- PPP_gene$V1
gs[[3]] <- CD8_cell_gene
gs[[4]] <- mitotic_gene
names(gs) <- c('EMT_score','PPP_gene','CD8_cell_gene','mitotic_gene')

ssgsea_score <- list()
for (i in 1:15) {
  a <- as.matrix(log2(expression[[i]]+1))
  ssgsea_score[[i]] = gsva(a, 
                           gs, method = "ssgsea", 
                           kcdf="Gaussian",
                           ssgsea.norm = TRUE, 
                           verbose = TRUE)
  ssgsea_score[[i]] <- as.data.frame(t(ssgsea_score[[i]]))
  ssgsea_score[[i]]$sample_id <- rownames(ssgsea_score[[i]])
}
names(ssgsea_score) <- cancer_name
#
# a <- as.matrix(log2(expression[[4]]+1))
# ssgsea_score = gsva(a, 
#                     gs, method = "ssgsea", 
#                     kcdf="Gaussian",
#                     ssgsea.norm = TRUE, 
#                     verbose = TRUE)
# ssgsea_score <- as.data.frame(t(ssgsea_score))
# ssgsea_score$sample_id <- rownames(ssgsea_score)

#cluster analysis pathway
for (i in 1:15) {
  data <- ssgsea_score[[i]][,-5]
  # for (i in 1:ncol(data)) {
  #   data[,i] <- scale(as.numeric(data[,i]))
  # }
  # data <- log2(data+1)
  dist.e <- dist(data,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=2)#分类
  result <- as.data.frame(result)
  paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),sep = '')
  
  colnames(result) <- c('cluster')
  annotation_col <- result
  annotation_col[annotation_col[,1]==1,1] <- 'type1'
  # annotation_col[annotation_col[,1]==2,1] <- 'IM'
  annotation_col[annotation_col[,1]==2,1] <- 'type2'
  a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],])#4cm*8cm
  a <- t(a)
  # bk = unique(c(seq(-3,3, length=200)))
  ann_colors = list(cluster = c(type1 = "blue",type2 = "#E24A0E")) 
  str(a)
  plot <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                             annotation_colors = ann_colors,
                             clustering_method = 'ward.D2', 
                             color = c(colorRampPalette(c("navy", "white"))(100),
                                       colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                             cluster_cols = F,cluster_rows = T,treeheight_row = 3,
                             annotation_col = annotation_col
                             # ,breaks = bk
  )#5*8
  pdf(paste('result/Figure/AI_plot_new/fig8/V5/score_survival/',cancer_name[i],'_cluster.pdf',sep = ''), width=8, height=5)
  print(plot,newpage = F)
  dev.off()
  
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(annotation_col),]
  b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'type1'
  b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'type2'
  
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Follow up time(d)", # 指定x轴标签
                     legend = c(0.8,0.75),         # 指定图例位置
                     title = cancer_name[i],                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 365,# 设置x轴刻度间距
                     pval.method=T)
  
  plot <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
    scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,1)],#图例位置
                          type = c("#E24A0E","blue"),
                          labels = c('IL','IH'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig8/V5/score_survival/',cancer_name[i],'_survival.pdf',sep = ''), width=8, height=5)
  print(plot,newpage = F)
  dev.off()
}

####验证找到的四条通路是否与所有癌症相关
library(aplot)
library(patchwork)
library(survival)
library(survminer)
total_result <- data.frame(row.names = c('cancer_name',
                                         'EMT_type1_vs_type2','EMT_type2_vs_type3','EMT_type1_vs_type3',
                                         'PPP_type1_vs_type2','PPP_type2_vs_type3','PPP_type1_vs_type3',
                                         'CD8_type1_vs_type2','CD8_type2_vs_type3','CD8_type1_vs_type3',
                                         'mitotic_type1_vs_type2','mitotic_type2_vs_type3','mitotic_type1_vs_type3'))
total_result <- as.data.frame(t(total_result))

for (i in 1:15) {
  data <- as.matrix(t(expression[[i]][which(rownames(expression[[i]])%in%hub_gene[[i]][,1]),]))
  data <- log2(data+1)
  dist.e <- dist(data,method='euclidean')
  model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
  result <- cutree(model1,k=3)#分类
  result <- as.data.frame(result)
  paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
  a <- cbind(rownames(result),result)
  # colnames(a)[1] <- colnames(BRCA_subtype)[1]
  # a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
  b <- a[,1]
  a <- as.data.frame(a[,-1])
  rownames(a) <- b
  colnames(a) <- c('cluster')
  result <- a
  annotation_col <- result
  a <- data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]==1],]
  j1 <- mean(apply(a, 1, sum))
  a <- data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]==2],]
  j2 <- mean(apply(a, 1, sum))
  a <- data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]==3],]
  j3 <- mean(apply(a, 1, sum))
  # order(c(j1,j2,j3),decreasing = F)
  annotation_col[annotation_col[,1]==order(c(j1,j2,j3),decreasing = F)[1],1] <- 'type1'
  annotation_col[annotation_col[,1]==order(c(j1,j2,j3),decreasing = F)[2],1] <- 'type2'
  annotation_col[annotation_col[,1]==order(c(j1,j2,j3),decreasing = F)[3],1] <- 'type3'
  
  a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],],
             data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type3'],])#4cm*8cm
  a <- t(a)
  # a <- log2(t(a)+1)
  # bk = unique(c(seq(-3,3, length=200)))
  ann_colors = list(cluster = c(type1 = "blue",type2 = "#F2CA20", type3 = "#E24A0E")) 
  # a <- t(data)
  pheatmap::pheatmap(a)
  plot1 <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                              annotation_colors = ann_colors,
                              clustering_method = 'ward.D2', 
                              color = c(colorRampPalette(c("navy", "white"))(100),
                                        colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                              cluster_cols = F,cluster_rows = T,
                              annotation_col = annotation_col,
                              # breaks = bk
  )#5*8
  pdf(paste('result/Figure/AI_plot_new/fig8/V5/common/',cancer_name[i],'_hot.pdf',sep = ''), width=8, height=5)
  grid.draw(plot1)
  dev.off()
  
  b <- lifetime_all[[i]]
  b <- b[b[,6]%in%rownames(annotation_col),]
  b[b[,6]%in%rownames(result)[result[,1]==order(c(j1,j2,j3),decreasing = F)[1]],7] <- 'type1'
  b[b[,6]%in%rownames(result)[result[,1]==order(c(j1,j2,j3),decreasing = F)[2]],7] <- 'type2'
  b[b[,6]%in%rownames(result)[result[,1]==order(c(j1,j2,j3),decreasing = F)[3]],7] <- 'type3'
  b$vital_status[which(b$V5 > 3650)] <- 0
  b$V5[which(b$V5 > 3650)] <- 3650
  c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
  c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
  plot <- ggsurvplot(c,            # 创建的拟合对象
                     conf.int = F,    # 显示置信区间
                     pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                     add.all = F,     # 添加总患者生存曲线
                     palette = "hue",    # 自定义调色板
                     surv.median.line = "hv",     # 添加中位生存时间线
                     risk.table = TRUE,             # 添加风险表
                     xlab = "Follow up time(d)", # 指定x轴标签
                     legend = c(0.8,0.75),         # 指定图例位置
                     title = cancer_name[i],                 # 设置图例标题
                     #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                     break.x.by = 365,# 设置x轴刻度间距
                     pval.method=T)
  
  # plot2 <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  #   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
  #                         type = c("blue","#F2CA20","#E24A0E"),
  #                         labels = c('type1','type2','type3'))##对齐坐标轴原点#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig8/V5/common/',cancer_name[i],'_surv.pdf',sep = ''), width=7, height=5)
  grid.draw(plot$plot)
  dev.off()
  
  score_data <- ssgsea_score[[i]]
  score_data$cluster[score_data$sample_id%in%b[b$File.Name=='type1',6]] <- 'type1'
  score_data$cluster[score_data$sample_id%in%b[b$File.Name=='type2',6]] <- 'type2'
  score_data$cluster[score_data$sample_id%in%b[b$File.Name=='type3',6]] <- 'type3'
  
  a <- ggplot(score_data, aes(x=cluster, y=EMT_score,fill=cluster)) +
    # scale_y_continuous(trans = log2_trans(),
    #                    breaks = trans_breaks("log2", function(x) 2^x),
    #                    labels = trans_format("log2", math_format(2^.x))) +
    geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
    geom_jitter(shape=16, position = position_jitter(0.2))+
    theme_classic()+
    geom_signif(comparisons = list(c('type1','type2'),c('type2','type3'),c('type1','type3')), 
                map_signif_level = TRUE, test = t.test, y_position = c(0.9,0.9,1),
                tip_length = c(0.03,0.03,0.03))#5cm*4cm
  
  b <- ggplot(score_data, aes(x=cluster, y=PPP_gene,fill=cluster)) +
    # scale_y_continuous(trans = log2_trans(),
    #                    breaks = trans_breaks("log2", function(x) 2^x),
    #                    labels = trans_format("log2", math_format(2^.x))) +
    geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
    geom_jitter(shape=16, position = position_jitter(0.2))+
    theme_classic()+
    geom_signif(comparisons = list(c('type1','type2'),c('type2','type3'),c('type1','type3')), 
                map_signif_level = TRUE, test = t.test, y_position = c(0.9,0.9,1),
                tip_length = c(0.03,0.03,0.03))#5cm*4cm
  
  c <- ggplot(score_data, aes(x=cluster, y=CD8_cell_gene,fill=cluster)) +
    # scale_y_continuous(trans = log2_trans(),
    #                    breaks = trans_breaks("log2", function(x) 2^x),
    #                    labels = trans_format("log2", math_format(2^.x))) +
    geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
    geom_jitter(shape=16, position = position_jitter(0.2))+
    theme_classic()+
    geom_signif(comparisons = list(c('type1','type2'),c('type2','type3'),c('type1','type3')), 
                map_signif_level = TRUE, test = t.test, y_position = c(0.9,0.9,1),
                tip_length = c(0.03,0.03,0.03))#5cm*4cm
  
  d <- ggplot(score_data, aes(x=cluster, y=mitotic_gene,fill=cluster)) +
    # scale_y_continuous(trans = log2_trans(),
    #                    breaks = trans_breaks("log2", function(x) 2^x),
    #                    labels = trans_format("log2", math_format(2^.x))) +
    geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
    geom_jitter(shape=16, position = position_jitter(0.2))+
    theme_classic()+
    geom_signif(comparisons = list(c('type1','type2'),c('type2','type3'),c('type1','type3')), 
                map_signif_level = TRUE, test = t.test, y_position = c(0.9,0.9,1),
                tip_length = c(0.03,0.03,0.03))#5cm*4cm
  
  plot <- a|b|c|d
  pdf(paste('result/Figure/AI_plot_new/fig8/V5/common/',cancer_name[i],'_pathway.pdf',sep = ''), width=15, height=5)
  print(plot,newpage = F)
  dev.off()
  
  total_result[i,1] <- cancer_name[i]
  
  total_result[i,2] <- ks.test(score_data[score_data$cluster=='type1',1],
                               score_data[score_data$cluster=='type2',1])$p.value
  total_result[i,3] <- ks.test(score_data[score_data$cluster=='type2',1],
                               score_data[score_data$cluster=='type3',1])$p.value
  total_result[i,4] <- ks.test(score_data[score_data$cluster=='type1',1],
                               score_data[score_data$cluster=='type3',1])$p.value
  total_result[i,5] <- ks.test(score_data[score_data$cluster=='type1',2],
                               score_data[score_data$cluster=='type2',2])$p.value
  total_result[i,6] <- ks.test(score_data[score_data$cluster=='type2',2],
                               score_data[score_data$cluster=='type3',2])$p.value
  total_result[i,7] <- ks.test(score_data[score_data$cluster=='type1',2],
                               score_data[score_data$cluster=='type3',2])$p.value
  total_result[i,8] <- ks.test(score_data[score_data$cluster=='type1',3],
                               score_data[score_data$cluster=='type2',3])$p.value
  total_result[i,9] <- ks.test(score_data[score_data$cluster=='type2',3],
                               score_data[score_data$cluster=='type3',3])$p.value
  total_result[i,10] <- ks.test(score_data[score_data$cluster=='type1',3],
                                score_data[score_data$cluster=='type3',3])$p.value
  total_result[i,11] <- ks.test(score_data[score_data$cluster=='type1',4],
                                score_data[score_data$cluster=='type2',4])$p.value
  total_result[i,12] <- ks.test(score_data[score_data$cluster=='type2',4],
                                score_data[score_data$cluster=='type3',4])$p.value
  total_result[i,13] <- ks.test(score_data[score_data$cluster=='type1',4],
                                score_data[score_data$cluster=='type3',4])$p.value
}#

##









# for (i in 1:15) {
#   data <- ssgsea_score[[i]][,-5]
#   # for (i in 1:ncol(data)) {
#   #   data[,i] <- scale(as.numeric(data[,i]))
#   # }
#   # data <- log2(data+1)
#   dist.e <- dist(data,method='euclidean')
#   model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
#   result <- cutree(model1,k=3)#分类
#   result <- as.data.frame(result)
#   paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),sep = '')
#   
#   colnames(result) <- c('cluster')
#   annotation_col <- result
#   annotation_col[annotation_col[,1]==1,1] <- 'type1'
#   # annotation_col[annotation_col[,1]==2,1] <- 'IM'
#   annotation_col[annotation_col[,1]==2,1] <- 'type2'
#   annotation_col[annotation_col[,1]==3,1] <- 'type3'
#   a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type1'],],
#              data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type2'],],
#              data[rownames(data)%in%rownames(annotation_col)[annotation_col[,1]=='type3'],])#4cm*8cm
#   a <- t(a)
#   # bk = unique(c(seq(-3,3, length=200)))
#   ann_colors = list(cluster = c(type1 = "blue",type2 = "yellow",type3 = "red")) 
#   str(a)
#   plot <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
#                              annotation_colors = ann_colors,
#                              clustering_method = 'ward.D2', 
#                              color = c(colorRampPalette(c("navy", "white"))(100),
#                                        colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
#                              cluster_cols = F,cluster_rows = T,treeheight_row = 3,
#                              annotation_col = annotation_col
#                              # ,breaks = bk
#   )#5*8
#   pdf(paste('result/Figure/AI_plot_new/fig8/V5/score_survival/',cancer_name[i],'_cluster.pdf',sep = ''), width=8, height=5)
#   print(plot,newpage = F)
#   dev.off()
#   
#   b <- lifetime_all[[i]]
#   b <- b[b[,6]%in%rownames(annotation_col),]
#   b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'type1'
#   b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'type2'
#   b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'type3'
#   b$vital_status[which(b$V5 > 3650)] <- 0
#   b$V5[which(b$V5 > 3650)] <- 3650
#   c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
#   c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
#   plot <- ggsurvplot(c,            # 创建的拟合对象
#                      conf.int = F,    # 显示置信区间
#                      pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                      add.all = F,     # 添加总患者生存曲线
#                      palette = "hue",    # 自定义调色板
#                      surv.median.line = "hv",     # 添加中位生存时间线
#                      risk.table = TRUE,             # 添加风险表
#                      xlab = "Follow up time(d)", # 指定x轴标签
#                      legend = c(0.8,0.75),         # 指定图例位置
#                      title = cancer_name[i],                 # 设置图例标题
#                      #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                      break.x.by = 365,# 设置x轴刻度间距
#                      pval.method=T)
#   
#   plot <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#     scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(1,2,3)],#图例位置
#                           type = c("#E24A0E","blue"),
#                           labels = c('type1','type2','type3'))##对齐坐标轴原点#4cm*5cm
#   pdf(paste('result/Figure/AI_plot_new/fig8/V5/score_survival/',cancer_name[i],'_survival.pdf',sep = ''), width=8, height=5)
#   print(plot,newpage = F)
#   dev.off()
# }
# a <- annotation_col
# a$sample <- substring(rownames(a),1,12)
# a$sample_id <- rownames(a)

#
b <- merge(a,ssgsea_score,by='sample_id',all=F)
####LUAD的模型构建与验证
# lifetime_all <- list()
# for (j in 1:15) {
#   lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
#   lifetime[,6] <- gsub('-','.',lifetime[,6])
#   lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
#   lifetime[which(lifetime[,2]=='Alive'),2] <- 0
#   lifetime[which(lifetime[,2]=='Dead'),2] <- 1
#   lifetime_all[[j]] <- lifetime
# }##读取临床与生存数据
names(lifetime_all) <- cancer_name
cancer_malignancy <- data.frame(cancer_name=cancer_name,sample_size='',death='',mortality_rate='',GEAR_num='')
for (i in 1:15) {
  cancer_malignancy[i,1] <- cancer_name[i]
  cancer_malignancy[i,2] <- as.numeric(nrow(lifetime_all[[i]]))
  cancer_malignancy[i,3] <- as.numeric(sum(lifetime_all[[i]][,2]==1))
  cancer_malignancy[i,4] <- sum(lifetime_all[[i]][,2]==1)/nrow(lifetime_all[[i]])
  cancer_malignancy[i,5] <- nrow(surv_data_sig_V2[[i]][[1]])
}


lifetime <- list()
for (i in 1:15) {
  lifetime[[i]] <- read.csv(paste('/database/TCGA/',cancer_name[i],'/',cancer_name[i],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[[i]][,6] <- gsub('-','.',lifetime[[i]][,6])
  expression_raw[[i]] <- expression_raw[[i]][,which(colnames(expression_raw[[i]]) %in% lifetime[[i]][,6])]
  lifetime[[i]] <- lifetime[[i]][which(lifetime[[i]][,6] %in% colnames(expression_raw[[i]])),]
  lifetime[[i]] <- lifetime[[i]][which(!duplicated(lifetime[[i]][,6])),]
  lifetime[[i]]$Sample.ID <- factor(lifetime[[i]]$Sample.ID, levels = colnames(expression_raw[[i]]))
  lifetime[[i]] <- lifetime[[i]][order(lifetime[[i]]$Sample.ID),]
  lifetime[[i]][which(lifetime[[i]][,2]=='Alive'),2] <- 0
  lifetime[[i]][which(lifetime[[i]][,2]=='Dead'),2] <- 1
}
names(lifetime_all) <- cancer_name
library('DESeq2')
library('survival')
library('survminer')
library('dplyr')
library('glmnet')
library('ggplot2')
library('GGally')
library('rms')
library('survivalROC')
library('plotROC')
uni_cox_in_bulk <- function(gene_list, survival_info_df){
  library('survival')
  gene_list <- gsub(gene_list, pattern = '-', replacement = '_')
  uni_cox <- function(single_gene){
    formula <- as.formula(paste0('Surv(overall_survival, censoring_status)~', single_gene))
    surv_uni_cox <- summary(coxph(formula, data = survival_cancer))
    ph_hypothesis_p <- cox.zph(coxph(formula, data = survival_cancer))$table[1,3]
    if (surv_uni_cox$coefficients[,5]<0.05 & ph_hypothesis_p>0.05){  #get the pvalue
      single_cox_report <- data.frame('uni_cox_sig_genes'=single_gene,
                                      'beta'=surv_uni_cox$coefficients[,1],
                                      'Hazard_Ratio'=exp(surv_uni_cox$coefficients[,1]),
                                      'z_pvalue'=surv_uni_cox$coefficients[,5],
                                      'Wald_pvalue'=as.numeric(surv_uni_cox$waldtest[3]),
                                      'Likelihood_pvalue'=as.numeric(surv_uni_cox$logtest[3]))
      single_cox_report
    }
  }
  uni_cox_list <- lapply(gene_list, uni_cox)
  do.call(rbind, uni_cox_list)
}
riskscore <- function(survival_cancer_df, candidate_genes_for_cox, cox_report) {
  library('dplyr')
  risk_score_table <- survival_cancer_df[,candidate_genes_for_cox]
  for(each_sig_gene in 1:ncol(risk_score_table)){
    risk_score_table[,each_sig_gene] <- risk_score_table[,each_sig_gene]*(summary(cox_report)$coefficients[colnames(risk_score_table)[each_sig_gene],1])
  }
  risk_score_table <- cbind(risk_score_table, 'total_risk_score'=exp(rowSums(risk_score_table))) %>%
    cbind(survival_cancer_df[,c('Sample.ID','overall_survival','censoring_status')])
  risk_score_table <- risk_score_table[,c('Sample.ID','overall_survival','censoring_status', candidate_genes_for_cox, 'total_risk_score')]
  risk_score_table
}
##对5年生存的预测
for (j in 1:15) {
  tryCatch({
    predict_effect[[j]] <- list()
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_dgree[[j]][,1],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%rownames(surv_data_sig[[j]][[1]]),]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],]##读取训练数据集
    # expr_data <- expression[[j]][rownames(expression[[j]])%in%c(surv_sig_inter[[8]][!duplicated(surv_sig_inter[[j]][,3]),3],surv_sig_dgree[[j]][,1]),]##读取训练数据集
    expr_data <- as.data.frame(t(ssgsea_score[[j]]))
    expr_data <- expr_data[-5,]
    life_data <- lifetime[[j]][,c(1,6,5,2)]
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    colnames(survival_cancer) <- gsub(colnames(survival_cancer), pattern = '-', replacement = '_')
    str(survival_cancer)
    survival_cancer$censoring_status <- as.numeric(survival_cancer$censoring_status)##censoring_status必须是numeric格式
    survival_cancer[survival_cancer$overall_survival>3650,3] <- 0
    survival_cancer[survival_cancer$overall_survival>3650,2] <- 3650
    gene_list <- colnames(DESeq_norm_vst_for_survival)
    uni_cox_df <- uni_cox_in_bulk(gene_list = gene_list, survival_info_df = survival_cancer)
    ##lasso筛选
    #about glmnet: x should be in format of matrix, and time&status in y should be in double format.
    sig_gene_multi_cox <- colnames(DESeq_norm_vst_for_survival)
    ###
    #使用合格的基因进行多变量cox回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(sig_gene_multi_cox, sep = '', collapse = '+')))
    multi_variate_cox <- coxph(formula_for_multivariate, data = survival_cancer)
    #检查PH假设是否支持方差。
    ph_hypo_multi <- cox.zph(multi_variate_cox)
    #表的最后一行记录了GLOBAL模型上的测试结果。删除它。
    ph_hypo_table <- ph_hypo_multi$table[-nrow(ph_hypo_multi$table),]
    #去除ph值假设不支持的方差，进行第二次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    #去除vif值不支持的共线性方差，进行第三次回归。
    formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]], sep = '', collapse = '+')))
    #formula_for_multivariate <- as.formula(paste0('Surv(overall_survival, censoring_status)~', paste(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]], sep = '', collapse = '+')))
    multi_variate_cox_2 <- coxph(formula_for_multivariate, data = survival_cancer)
    multi_variate_cox_gene[[j]] <- multi_variate_cox_2
    
    #check the co-linearity between samples.
    correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], method = 'pearson')
    #correlation <- cor(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[1:5]]], method = 'pearson')
    library('GGally')
    ggpairs(survival_cancer[,rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif) < 2]]], 
            axisLabels = 'show')+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())
    library('rms')
    vif <- rms::vif(multi_variate_cox_2)
    #Some people said if the square root of VIF >2, they might be co-linear.
    sqrt(vif) < 2
    vif <- as.data.frame(vif)
    
    ###森林图
    ggforest(model = multi_variate_cox_2, data = survival_cancer, main = 'Hazard ratios of candidate genes', fontsize = 1)#5cm*9cm
    C_index <- multi_variate_cox_2$concordance['concordance']
    if(C_index >= 0.9){
      print('High accuracy')
    }else{ 
      if(C_index < 0.9 & C_index >= 0.7){
        print('Medium accuracy')
      }else{
        print('Low accuracy')
      }
    }
    #calculate the risk score of each sample.
    single_genelist[[j]] <- rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]]
    candidate_genes_for_cox2 <- c(rownames(ph_hypo_table)[ph_hypo_table[,3]>0.05&rownames(ph_hypo_table)%in%rownames(vif)[sqrt(vif[,1]) < 2]])
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线s
    # multi_ROC <- function(time_vector, risk_score_table){
    #   library('survivalROC')
    #   single_ROC <- function(single_time){
    #     for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
    #                            status = risk_score_table$censoring_status,
    #                            marker = risk_score_table$total_risk_score,
    #                            predict.time = single_time, method = 'KM')
    #     data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
    #                'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
    #                'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
    #   }
    #   multi_ROC_list <- lapply(time_vector, single_ROC)
    #   do.call(rbind, multi_ROC_list)
    # }
    # #We evaluate 11 AUCs between 3-10 years.
    # for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,10,0.2)), risk_score_table = risk_score_table_multi_cox2)
    # AUC_max <- max(for_multi_ROC$AUC)
    # AUC_max_time <- max(for_multi_ROC$Time_point)
    # #visualization of the ROC curves of multiple time points.
    # pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
    #   geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
    #   geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
    #   theme_bw()+
    #   #scale_color_gradient(high="#F20808",low="#1E08F7")+
    #   theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
    #         panel.grid = element_blank())+
    #   annotate("text",x = 0.75, y = 0.15,
    #            label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    # pdf(paste('result/Figure/AI_plot_new/fig8/V5/cox/',cancer_name[j],'_roc.pdf',sep = ''), width=5, height=5)
    # print(pROC,newpage = F)
    # dev.off()
    # 
    # predict_effect[[j]][[1]] <- pROC
    
    # AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    # 
    # #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    # AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]##取AUC最大值
    # AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]##取AUC最大值
    # AUC_max_time <- AUC_max_time[length(AUC_max_time)]##取AUC最大值
    # AUC_max_time <- 3650
    # for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    # optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]##提取AUC最大的时间数据
    # cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    # high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    # high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    # high_low[high_low == FALSE] <- 'low'
    # risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    # predict_effect[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    # gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    # #KM_plot generation.
    # library('survminer')
    # #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    # risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    # risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    
    risk_score_table_multi_cox2$risk_type[risk_score_table_multi_cox2$total_risk_score>median(risk_score_table_multi_cox2$total_risk_score)] <- 'high'
    risk_score_table_multi_cox2$risk_type[risk_score_table_multi_cox2$total_risk_score<=median(risk_score_table_multi_cox2$total_risk_score)] <- 'low'
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~risk_type, data = risk_score_table_multi_cox2)
    predict_effect[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                           conf.int = F,    # 显示置信区间
                                           pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                           add.all = F,     # 添加总患者生存曲线
                                           palette = "hue",    # 自定义调色板
                                           surv.median.line = "hv",     # 添加中位生存时间线
                                           risk.table = F,             # 添加风险表
                                           xlab = "Follow up time(d)", # 指定x轴标签
                                           legend = c(0.8,0.9),         # 指定图例位置
                                           title = cancer_name[j],                 # 设置图例标题
                                           #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                           break.x.by = 1000,# 设置x轴刻度间距
                                           pval.method=T)
    plot <- predict_effect[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,3650,1000))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点 #4cm*5cm
    pdf(paste('result/Figure/AI_plot_new/fig8/V5/cox/',cancer_name[j],'_surv.pdf',sep = ''), width=5, height=5)
    print(plot,newpage = F)
    dev.off()
  }, error = function(e) {print('error')})
}
names(predict_effect) <- cancer_name
names(single_genelist) <- cancer_name
##验证集验证
ver_expr_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/tumor_CPTAC_LUAD_immune.csv',row.names = 1)
for (j in 8) {
  ##计算基因模型风险评分
  tryCatch({
    predict_effect_ver[[j]] <- list()
    gene_list <- rownames(as.data.frame(multi_variate_cox_gene[[j]]$coefficients))
    expr_data <- ver_expr_data
    rownames(expr_data) <- gsub('-','_',rownames(expr_data))
    expr_data <- expr_data[rownames(expr_data)%in%gene_list,]
    expr_data <- log2(expr_data+1)
    life_data <- read.csv('/database/CPTAC/LUAD/RNA_seq/LUAD_clinical_lifetime.csv',row.names = 1)
    life_data[life_data[,2]=='Alive',2] <- 1
    life_data[life_data[,2]=='Dead',2] <- 0
    life_data <- life_data[,c(1,6,5,2)]
    life_data[,2] <- gsub('-','.',life_data[,2])
    life_data[,2] <- gsub(', ','..',life_data[,2])
    life_data <- life_data[life_data[,2]%in%colnames(expr_data),]
    colnames(life_data)[3:4] <- c('overall_survival','censoring_status')
    DESeq_norm_vst_for_survival <- as.data.frame(t(expr_data))
    # DESeq_norm_vst_for_survival <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)%in%life_data[,2],]
    # life_data <- life_data[life_data[i,2]%in%rownames(DESeq_norm_vst_for_survival),]
    for (i in 1:nrow(life_data)) {
      life_data[i,5:(ncol(DESeq_norm_vst_for_survival)+4)] <- DESeq_norm_vst_for_survival[rownames(DESeq_norm_vst_for_survival)==life_data[i,2],]
    }
    for (k in 3:ncol(life_data)) {
      life_data[,k] <- as.numeric(life_data[,k])
    }
    survival_cancer <- life_data
    
    #使用合格的基因进行多变量cox回归。
    multi_variate_cox_2 <- multi_variate_cox_gene[[j]]
    
    #calculate the risk score of each sample.
    candidate_genes_for_cox2 <- gene_list
    risk_score_table_multi_cox2 <- riskscore(survival_cancer_df=survival_cancer, 
                                             candidate_genes_for_cox=candidate_genes_for_cox2, 
                                             cox_report=multi_variate_cox_2)
    ###ROC曲线
    multi_ROC <- function(time_vector, risk_score_table){
      library('survivalROC')
      single_ROC <- function(single_time){
        for_ROC <- survivalROC(Stime = risk_score_table$overall_survival,
                               status = risk_score_table$censoring_status,
                               marker = risk_score_table$total_risk_score,
                               predict.time = single_time, method = 'KM')
        data.frame('True_positive'=for_ROC$TP, 'False_positive'=for_ROC$FP, 
                   'Cut_values'=for_ROC$cut.values, 'Time_point'=rep(single_time, length(for_ROC$TP)),
                   'AUC'=rep(for_ROC$AUC, length(for_ROC$TP)))
      }
      multi_ROC_list <- lapply(time_vector, single_ROC)
      do.call(rbind, multi_ROC_list)
    }
    #We evaluate 11 AUCs between 3-5 years.
    for_multi_ROC <- multi_ROC(time_vector = c(365*seq(3,5,0.2)), risk_score_table = risk_score_table_multi_cox2)
    AUC_max <- max(for_multi_ROC$AUC)
    AUC_max_time <- max(for_multi_ROC$Time_point)
    #visualization of the ROC curves of multiple time points.
    pROC<-ggplot(for_multi_ROC, aes(x = False_positive, y = True_positive, label = Cut_values, color = Time_point)) + 
      geom_roc(labels = F, stat = 'identity', n.cuts = 0) + 
      geom_abline(slope = 1, intercept = 0, color = 'red', linetype = 2)+
      theme_bw()+
      theme(panel.background = element_rect(colour = 'black', size=1, fill = 'white'), 
            panel.grid = element_blank())+
      annotate("text",x = 0.75, y = 0.15,
               label = paste("AUC max = ", round(AUC_max, 2), '\n', 'AUC max time = ', AUC_max_time, ' days', sep = ''))
    pROC
    predict_effect_ver[[j]][[1]] <- pROC
    
    AUC_max <- max(for_multi_ROC$AUC)##ROC曲线在对角线上方是max，下方是min
    
    #maybe AUCs are identical in different time points. So select the last time point indicating longer survival.
    AUC_max_time <- for_multi_ROC$Time_point[which(for_multi_ROC$AUC == AUC_max)]
    AUC_max_time <- AUC_max_time[!duplicated(AUC_max_time)]
    AUC_max_time <- AUC_max_time[length(AUC_max_time)]
    AUC_max_time <- 1825
    for_multi_ROC$Time_point <- as.factor(for_multi_ROC$Time_point)
    #find the optimal cutoff value within the ROC curve of the optimal time point.
    optimal_time_ROC_df <- for_multi_ROC[which(for_multi_ROC$Time_point == AUC_max_time),]
    cut.off <- optimal_time_ROC_df$Cut_values[which.max(optimal_time_ROC_df$True_positive-optimal_time_ROC_df$False_positive)]##ROC曲线在对角线上方是which.max，下方是which.min
    high_low <- (risk_score_table_multi_cox2$total_risk_score > cut.off)##ROC曲线在对角线上方是>，下方是<
    high_low[high_low == TRUE] <- 'high'####ROC曲线在对角线上方是high，下方是low
    high_low[high_low == FALSE] <- 'low'
    risk_score_table_multi_cox2 <- cbind(risk_score_table_multi_cox2, high_low)
    predict_effect_ver[[j]][[3]] <- survdiff(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2[,c(2,3,7)])
    gene_score[[j]] <- risk_score_table_multi_cox2[,c(1,(ncol(risk_score_table_multi_cox2)-1))]
    #KM_plot generation.
    library('survminer')
    #first edit the status of patients with OS > AUC max time. (censoring status=0 (Alive), OS=365*5 days)
    risk_score_table_multi_cox2$censoring_status[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- 0
    risk_score_table_multi_cox2$overall_survival[which(risk_score_table_multi_cox2$overall_survival > AUC_max_time)] <- AUC_max_time
    fit_km <- survfit(Surv(overall_survival, censoring_status) ~high_low, data = risk_score_table_multi_cox2)     
    predict_effect_ver[[j]][[2]] <- ggsurvplot(fit_km,            # 创建的拟合对象
                                               conf.int = F,    # 显示置信区间
                                               pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                                               add.all = F,     # 添加总患者生存曲线
                                               palette = "hue",    # 自定义调色板
                                               surv.median.line = "hv",     # 添加中位生存时间线
                                               risk.table = TRUE,             # 添加风险表
                                               xlab = "Follow up time(d)", # 指定x轴标签
                                               legend = c(0.8,0.9),         # 指定图例位置
                                               title = c('LUAD_Validation'),                 # 设置图例标题
                                               #legend.labs = c(''), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                                               break.x.by = 365,# 设置x轴刻度间距
                                               pval.method=T)
    predict_effect_ver[[j]][[2]]$plot+scale_x_continuous(expand = c(0,0),breaks = seq(0,1825,365))+
      scale_colour_discrete(type = c("red","blue"),
                            breaks = predict_effect_ver[[j]][[2]]$plot$plot_env$legend.labs[c(2,1)],#图例位置
                            labels = c("low","high"))##对齐坐标轴原点#4cm*5cm
  })
}







# library(ggplot2)
# data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%surv_sig_dgree[[2]][1:9,1]),]))
# # for (i in 1:ncol(data)) {
# #   data[,i] <- scale(as.numeric(data[,i]))
# # }
# data <- log2(data+1)
# dist.e <- dist(data,method='euclidean')
# model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
# result <- cutree(model1,k=3)#分类
# result <- as.data.frame(result)
# paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
# a <- cbind(rownames(result),result)
# colnames(a)[1] <- colnames(BRCA_subtype)[1]
# a <- merge(a,BRCA_subtype[,c(1,3)],by = colnames(a)[1],all = F)
# rownames(a) <- a[,1]
# a <- a[,-1]
# colnames(a) <- c('cluster','subtype')
# result <- a
# annotation_col <- result
# annotation_col[annotation_col[,1]==1,1] <- 'IL'
# annotation_col[annotation_col[,1]==2,1] <- 'IM'
# annotation_col[annotation_col[,1]==3,1] <- 'IH'
# a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
#            data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
#            data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
#            data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
# a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
#            a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
#            a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm
# 
# 
# a <- t(a)
# bk = unique(c(seq(-1,1, length=200)))
# ann_colors = list(subtype = c(LumA="#ED5163", LumB="#4498F2",Her2="#72FCA0",Basal="gray"), #连续数值型分组可设置成渐变  
#                   cluster = c(IL = "blue",IM = "#F2CA20", IH = "#E24A0E",IS = 'red')) 
# # a <- t(data)
# pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
#                    annotation_colors = ann_colors,
#                    clustering_method = 'ward.D2', 
#                    color = c(colorRampPalette(c("navy", "white"))(100),
#                              colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
#                    cluster_cols = F,cluster_rows = T,
#                    annotation_col = annotation_col,
#                    breaks = bk)#5*8
# 
# paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
#亚型与不同聚类的生存曲线
# b <- lifetime_all[[2]]
# b <- b[b[,6]%in%rownames(annotation_col),]
# b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IL'
# b[b[,6]%in%rownames(result)[result[,1]%in%2:3],7] <- 'IH'
# # b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'
# # b[b[,6]%in%rownames(result)[result[,1]%in%2:3],7] <- 'IH'
# b$vital_status[which(b$V5 > 3650)] <- 0
# b$V5[which(b$V5 > 3650)] <- 3650
# c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
# c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
# plot <- ggsurvplot(c,            # 创建的拟合对象
#                    conf.int = F,    # 显示置信区间
#                    pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                    add.all = F,     # 添加总患者生存曲线
#                    palette = "hue",    # 自定义调色板
#                    surv.median.line = "hv",     # 添加中位生存时间线
#                    risk.table = TRUE,             # 添加风险表
#                    xlab = "Follow up time(d)", # 指定x轴标签
#                    legend = c(0.8,0.75),         # 指定图例位置
#                    title = c('BRCA_cluster'),                 # 设置图例标题
#                    #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                    break.x.by = 365,# 设置x轴刻度间距
#                    pval.method=T)
# 
# plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
#                         type = c("#E24A0E","blue","#F2CA20"),
#                         labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm

##亚型生存曲线
# all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
# BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
# BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
# #BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
# a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
# a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
# BRCA_subtype[,1] <- a
# annotation_row <- BRCA_subtype
# annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
# b <- annotation_row[,1]
# annotation_row <- as.data.frame(annotation_row[,3])
# rownames(annotation_row) <- b
# colnames(annotation_row) <- 'BRCA_subtype'
# 
# b <- lifetime_all[[2]]
# b <- b[b[,6]%in%rownames(annotation_col),]
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
# 
# b$vital_status[which(b$V5 > 3650)] <- 0
# b$V5[which(b$V5 > 3650)] <- 3650
# c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
# c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
# plot <- ggsurvplot(c,            # 创建的拟合对象
#                    conf.int = F,    # 显示置信区间
#                    pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                    add.all = F,     # 添加总患者生存曲线
#                    palette = "hue",    # 自定义调色板
#                    surv.median.line = "hv",     # 添加中位生存时间线
#                    risk.table = TRUE,             # 添加风险表
#                    xlab = "Follow up time(d)", # 指定x轴标签
#                    legend = c(0.8,0.75),         # 指定图例位置
#                    title = c('BRAD_subtype'),                 # 设置图例标题
#                    #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                    break.x.by = 365,# 设置x轴刻度间距
#                    pval.method=T)
# 
# plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
#                         type = c("#4498F2","gray","#ED5163","#72FCA0"),
#                         labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm
# 
# ####查看不同亚型下免疫low与median的区别
# b <- lifetime_all[[2]]
# b <- b[b[,6]%in%rownames(annotation_col),]
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
# 
# annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
# b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IL']] <- 'IL_LumA'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IM']] <- 'IM_LumA'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='LumA'&annotation_col$cluster=='IH']] <- 'IH_LumA'
# b_IM <- b[!is.na(b$cluster_subtype),]
# 
# b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
# b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
# c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
# c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
# plot <- ggsurvplot(c,            # 创建的拟合对象
#                    conf.int = F,    # 显示置信区间
#                    pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                    add.all = F,     # 添加总患者生存曲线
#                    palette = "hue",    # 自定义调色板
#                    surv.median.line = "hv",     # 添加中位生存时间线
#                    risk.table = TRUE,             # 添加风险表
#                    xlab = "Follow up time(d)", # 指定x轴标签
#                    legend = c(0.8,0.75),         # 指定图例位置
#                    title = c('BRCA_immune_LumA'),                 # 设置图例标题
#                    #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                    break.x.by = 365,# 设置x轴刻度间距
#                    pval.method=T)
# plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
#                         type = c('#22BA4D','red','blue'),
#                         labels = c('IL_LumA','IM_LumA','IH_LumA'))##对齐坐标轴原点#4cm*5cm
# 
# b <- lifetime_all[[2]]
# b <- b[b[,6]%in%rownames(annotation_col),]
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
# b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"
# 
# annotation_col$case_id <- substring(text = rownames(annotation_col),first = 1,last = 12)
# b$case_id <- gsub(pattern = '-',replacement = '.',x = b$case_id)
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IL']] <- 'IL_Basal'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IM']] <- 'IM_Basal'
# b$cluster_subtype[b$case_id%in%annotation_col$case_id[annotation_col$subtype=='Basal'&annotation_col$cluster=='IH']] <- 'IH_Basal'
# 
# b_IM <- b[!is.na(b$cluster_subtype),]
# 
# b_IM$vital_status[which(b_IM$V5 > 3650)] <- 0
# b_IM$V5[which(b_IM$V5 > 3650)] <- 3650
# c <- survdiff(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
# c <- survfit(Surv(b_IM[,5],as.numeric(b_IM[,2]))~b_IM[,8], data = b_IM)
# plot <- ggsurvplot(c,            # 创建的拟合对象
#                    conf.int = F,    # 显示置信区间
#                    pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
#                    add.all = F,     # 添加总患者生存曲线
#                    palette = "hue",    # 自定义调色板
#                    surv.median.line = "hv",     # 添加中位生存时间线
#                    risk.table = TRUE,             # 添加风险表
#                    xlab = "Follow up time(d)", # 指定x轴标签
#                    legend = c(0.8,0.75),         # 指定图例位置
#                    title = c('BRCA_immune_Basal'),                 # 设置图例标题
#                    #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
#                    break.x.by = 365,# 设置x轴刻度间距
#                    pval.method=T)
# plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
#   scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
#                         type = c('#22BA4D','red','blue'),
#                         labels = c('IL_Basal','IM_Basal','IH_Basal'))##对齐坐标轴原点#4cm*5cm

####分析主要是哪种免疫细胞在起作用
####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 1:15) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:10,])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%surv_sig_dgree[[i]][1:9,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name

bk = unique(c(seq(-1,1, length=200)))
plot <- pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T,
                           treeheight_row = 8,treeheight_col = 8)#8cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8B.pdf',sep = ''), width=8, height=8)
print(plot,newpage = F)
dev.off()

##fig8C
# 判断是什么免疫细胞
data <- expression_raw[[2]][1:10,]
# for (i in 1:10) {
#   data[,i] <- log2(as.numeric(data[,i])+1)
# }
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
a <- data.frame(sample=colnames(data))
a$immune_cell <- as.numeric(data[8,])
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
a <- a[!is.na(a$group),]
a$immune_cell <- a$immune_cell*100
a$group <- factor(a$group,levels = c('IL','IH'))
plot <- ggplot(a, aes(fill=group, y=immune_cell, x=group)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL","IH")), 
              map_signif_level = TRUE, test = t.test, y_position = c(19),
              tip_length = c(0.02))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8C.pdf',sep = ''), width=4, height=5)
print(plot,newpage = F)
dev.off()

#fig8D
##查看免疫浸润高低的突变差异
BRCA_mut_raw <- read.maf(maf = '/database/TCGA/BRCA/mutation/TCGA_BRCA_mutation.maf',clinicalData = '/database/TCGA/BRCA/mutation/clinical.tsv')
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

a <- rownames(annotation_col)
a <- substring(text = a,first = 1,last = 12)
IL_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IL'],]
IH_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IH'],]

write.table(IL_mut,'result/BRCA/mutation/IL_mut_new.maf',sep = '\t',quote = F,row.names = F)
write.table(IH_mut,'result/BRCA/mutation/IH_mut_new.maf',sep = '\t',quote = F,row.names = F)

IL_mut <- read.maf(maf ='result/BRCA/mutation/IL_mut_new.maf')
IH_mut <- read.maf(maf ='result/BRCA/mutation/IH_mut_new.maf')
#突变负荷差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_mut)
TMB[[2]] <- tmb(maf = IH_mut)
names(TMB) <- c('IL_mut','IH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IH_mut',nrow(TMB[[2]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_mut','IH_mut'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL_mut','IH_mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2,0.21),
              tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig8/V4/fig8E.pdf",width = 4,height = 5)
print(a,newpage = F)
dev.off()
#差异突变
IL_mut_vs_IH_mut <- mafCompare(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
forestPlot(mafCompareRes = IL_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
r1<-IL_mut_vs_IH_mut$results
g0<-r1[order(r1$IL_mut,decreasing = T)[1:10],Hugo_Symbol]
g1<-r1[order(r1$IL_mut,decreasing = T)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V4/fig8D.pdf",width = 15,height = 3)
coOncoplot(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = T)
dev.off()

#发现GATA3突变集中在IL组，然后这个GATA3可以调控CXCL1的转录，CXCL1可以诱导CD8+细胞
##fig8F

data <- expression_raw[[2]][c('CXCL1','GATA3'),]
rcorr(t(data),type = 'spearman')
annotation_col 

library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(scales)
a <- data.frame(sample=colnames(data))
a$CXCL1 <- as.numeric(data[1,])
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
a <- a[!is.na(a$group),]
# a$immune_cell <- a$immune_cell*100
a$group <- factor(a$group,levels = c('IL','IH'))
plot <- ggplot(a, aes(fill=group, y=CXCL1, x=group)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_signif(comparisons = list(c("IL","IH")), 
              map_signif_level = TRUE, test = t.test, y_position = c(19),
              tip_length = c(0.02))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8F.pdf',sep = ''), width=4, height=5)
print(plot,newpage = F)
dev.off()

a <- data.frame(sample=colnames(data))
a$GATA3 <- as.numeric(data[2,])
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
a <- a[!is.na(a$group),]
# a$immune_cell <- a$immune_cell*100
a$group <- factor(a$group,levels = c('IL','IH'))
plot <- ggplot(a, aes(fill=group, y=GATA3, x=group)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_signif(comparisons = list(c("IL","IH")), 
              map_signif_level = TRUE, test = t.test, y_position = c(19),
              tip_length = c(0.02))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8F.pdf',sep = ''), width=4, height=5)
print(plot,newpage = F)
dev.off()

#取出GATA3突变的患者
a <- data.frame(sample=colnames(data))
a$CXCL1 <- as.numeric(data[1,])
a$sample <- substring(a$sample,1,12)
a <- a[a$sample%in%BRCA_mut$Tumor_Sample_Barcode,]
a$group[a$sample%in%BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='GATA3']] <- 'mut'
a$group[is.na(a$group)] <- 'wt'
a <- a[!is.na(a$group),]
# a$immune_cell <- a$immune_cell*100
a$group <- factor(a$group,levels = c('wt','mut'))
plot <- ggplot(a, aes(fill=group, y=CXCL1, x=group)) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_signif(comparisons = list(c("wt","mut")), 
              map_signif_level = TRUE, test = t.test, y_position = c(19),
              tip_length = c(0.02))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8F.pdf',sep = ''), width=4, height=5)
print(plot,newpage = F)
dev.off()

#此处已证明GATA3突变与CXCL1的表达降低相关
#接下来证明与CD8浸润相关的chemokine中，相关的有哪些
chemokine <- chemokine
CD8_chemokine <- chemokine$`T cell CD8+`
CD8_chemokine <- unique(CD8_chemokine)
data <- as.matrix(t(expression_raw[[2]][which(rownames(expression_raw[[2]])%in%c(CD8_chemokine,rownames(expression_raw[[2]])[8])),]))
a <- rcorr(data,type = 'spearman')[[1]]
a <- pheatmap::pheatmap(a)

pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8G.pdf',sep = ''), width=8, height=6)
grid.draw(a)
dev.off()


#然后接下来取出GATA3调控表达的几个基因作为辅助证明GATA3突变功能会丧失
data <- expression_raw[[2]][rownames(expression_raw[[2]])%in%human_TF[human_TF$TF=='GATA3',2],]
for (i in 1:37) {
  data[i,] <- scale(as.numeric(data[i,]))
}
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(scales)
a <- as.data.frame(t(data))
a$sample <- substring(rownames(a),1,12)
a <- a[a$sample%in%BRCA_mut$Tumor_Sample_Barcode,]
a$group[a$sample%in%BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='GATA3']] <- 'mut'
a$group[is.na(a$group)] <- 'wt'
a <- a[!is.na(a$group),]
a <- rbind(a[a$group=='wt',],a[a$group=='mut',])
bk = unique(c(seq(-1,1, length=200)))
plot <- pheatmap::pheatmap(a[,1:37],cluster_cols = T,show_rownames = F,breaks = bk,cluster_rows = F,
                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)))


plot <- pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = ,cluster_cols = T,
                           treeheight_row = 8,treeheight_col = 8)#8cm*8cm
GATA3 <- data.frame(gene <- colnames(a)[1:37])
for (i in 1:37) {
  GATA3$wt_mean[i] <- mean(a[a$group=='wt',i])
  GATA3$mut_mean[i] <- mean(a[a$group=='mut',i])
  GATA3$p_value[i] <- t.test(a[a$group=='wt',i],a[a$group=='mut',i])$p.value
}

pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8H.pdf',sep = ''), width=9, height=5)
grid.draw(plot)
dev.off()
#然后用maftools比较IL和IH组里面GATA3的突变结构域的差异

#ccle
library(stringr)
CCLE_expr <- read.csv('/database/depmap/CCLE_expression.csv',row.names = 1)
a <- colnames(CCLE_expr)
a <- str_split(a,'[.][.]',simplify = T)
colnames(CCLE_expr) <- a[,1]
CCLE_expr <- as.data.frame(t(CCLE_expr))
CCLE_expr <- 2**CCLE_expr
normalized_func <- function(x){x/sum(x)*1000000}
a <- as.data.frame(apply(CCLE_expr, 2, normalized_func))
CCLE_expr <- a
data <- CCLE_expr[rownames(CCLE_expr)%in%c(human_TF[human_TF$TF=='GATA3',2],'GATA3'),]
for (i in 1:37) {
  data[i,] <- scale(as.numeric(data[i,]))
}
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(scales)
a <- as.data.frame(t(data))
a$sample <- rownames(a)

a$group[a$sample%in%CCLE_mut[CCLE_mut$Hugo_Symbol=='GATA3','DepMap_ID']] <- 'mut'
a$group[is.na(a$group)] <- 'wt'
a <- a[!is.na(a$group),]
a <- rbind(a[a$group=='wt',],a[a$group=='mut',])
bk = unique(c(seq(-1,1, length=200)))

GATA3_cell <- data.frame(gene <- colnames(a)[1:36])
for (i in 1:36) {
  GATA3_cell$wt_mean[i] <- mean(a[a$group=='wt',i])
  GATA3_cell$mut_mean[i] <- mean(a[a$group=='mut',i])
  GATA3_cell$p_value[i] <- t.test(a[a$group=='wt',i],a[a$group=='mut',i])$p.value
}


pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8H.pdf',sep = ''), width=9, height=5)
grid.draw(plot)
dev.off()

##单样本GSEA
#处理EMT基因集
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

#单样本基因集富集分析
library(GSVA)
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]

#单样本GSEA
geneset <- as.data.frame(EMT_gene$Gene)
colnames(geneset) <- 'EMT_score'
gs <- as.list(geneset)
a <- as.matrix(log2(expression_raw[[2]]+1))
ssgsea_score = gsva(a, 
                    gs, method = "ssgsea", 
                    kcdf="Gaussian",
                    ssgsea.norm = TRUE, 
                    verbose = TRUE)
ssgsea_score <- as.data.frame(t(ssgsea_score))
ssgsea_score$sample_id <- rownames(ssgsea_score)

#
# a <- as.data.frame(colnames(expression_raw[[2]]))
# a$sample <- substring(a[,1],1,12)
# a <- a[a$sample%in%BRCA_mut$Tumor_Sample_Barcode,]
# a$group[a$sample%in%BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='GATA3']] <- 'mut'
# a$group[is.na(a$group)] <- 'wt'
# a <- a[!is.na(a$group),]
# a <- rbind(a[a$group=='wt',],a[a$group=='mut',])
# colnames(a)[1] <- 'sample_id'
a <- annotation_col
a$sample <- substring(rownames(a),1,12)
a$sample_id <- rownames(a)

#
b <- merge(a,ssgsea_score,by='sample_id',all=F)

##画图
plot1 <- b
plot1 <- ggplot(plot1, aes(x=cluster, y=EMT_score,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.5),
              tip_length = c(0.03))#5cm*4cm
pdf(paste('result/Figure/AI_plot_new/fig8/V4/fig8I.pdf',sep = ''), width=5, height=5)
print(plot1,newpage = F)
dev.off()





plot2 <- b[b$N.Stage%in%c('group1','group2'),]
plot2 <- ggplot(plot2, aes(x=N.Stage, y=VIM,fill=N.Stage)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('group1','group2')), 
              map_signif_level = TRUE, test = t.test, y_position = c(12.5),
              tip_length = c(0.03))#5cm*4cm

plot2 <- b[b$N.Stage%in%c('group1','group2'),]
plot2 <- ggplot(plot2, aes(x=N.Stage, y=VIM,fill=N.Stage)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('group1','group2')), 
              map_signif_level = TRUE, test = t.test, y_position = c(12.5),
              tip_length = c(0.03))#5cm*4cm

plot3 <- b[b$N.Stage%in%c('group1','group2'),]
plot3 <- ggplot(plot3, aes(x=N.Stage, y=CDH2,fill=N.Stage)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('group1','group2')), 
              map_signif_level = TRUE, test = t.test, y_position = c(10),
              tip_length = c(0.03))#5cm*12cm

library(patchwork)
plot1|plot2|plot3




####阳性对照
b$VIM_level[b$VIM>median(b$VIM)] <- 'high'
b$VIM_level[b$VIM<=median(b$VIM)] <- 'low'
plot4 <- b[b$N.Stage%in%c('group1','group2'),]
ggplot(b, aes(x=VIM_level, y=EMT_score,fill=VIM_level)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('high','low')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.5),
              tip_length = c(0.03))#5cm*5cm



# 判断是什么免疫细胞
r1<-LumA_IL_mut_vs_IM_mut$results
r1<-LumA_IL_mut_vs_IH_mut$results
r1<-LumA_IM_mut_vs_IH_mut$results
r1<-Basal_IL_mut_vs_IM_mut$results
g0 <- r1[order(r1$pval,decreasing = F)[1:40],Hugo_Symbol]
g0<-r1[which(r1$pval<0.05),Hugo_Symbol]
g1<-r1[,Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
coOncoplot(m1 = IL_basal_mut, m2 = IM_basal_mut, m1Name = 'IL', m2Name = 'IM', genes = g, removeNonMutated = F)
coOncoplot(m1 = IM_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = F)
coOncoplot(m1 = IL_LumA_mut, m2 = IH_LumA_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = F)
#3cm*10cm







########分析LumA和Basal种CD8 T和Treg的含量差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)

names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('IL_Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('IM_Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('IH_Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_LumA','IM_LumA','IH_LumA','IL_Basal','IM_Basal','IH_Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

a <-ggplot(TMB_plot, aes(x=cluster, y=`T cell CD8+`,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("IL_LumA","IM_LumA"),c("IM_LumA","IH_LumA"),c("IL_Basal","IM_Basal"),c("IM_Basal","IH_Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.2,0.21,0.2,0.21),
              tip_length = c(0.01,0.01,0.01,0.01))#5cm*4cm
a

####分析T细胞激活marker
##分析PD1,PDL1的水平LumA和Basal的差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_LumA_mut)
TMB[[2]] <- tmb(maf = IM_LumA_mut)
TMB[[3]] <- tmb(maf = IH_LumA_mut)
TMB[[4]] <- tmb(maf = IL_basal_mut)
TMB[[5]] <- tmb(maf = IM_basal_mut)
TMB[[6]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('LumA',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
                  cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
                  cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]][c('IGLC7','IGHV3-43','CD79A','IGAN2','IGAN1','FCGR2A','FCGR3A','GSDME','GSDMD','BCL2L1','CASP3','XIAP','TRAF1','HTRA2','BIRC7','BIRC5','BIRC2','BIRC3','TGIF1','HIF1A','IL10','TNFRSF9','IL21','CD8A','PDCD1','CD274','CTLA4','GZMA','GZMB','PRF1','PRF2'),]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

# plot <- TMB_plot[,c('Tumor_Sample_Barcode','cluster','GZMA','GZMB','PRF1')]
# plot <- pivot_longer(plot,cols = 3:5,names_to = 'gene',values_to = 'expr')
# plot$cluster <- factor(plot$cluster)
# plot$gene <- factor(plot$gene)
TMB_plot$IGLC7 <- TMB_plot$IGLC7+1
ggplot(TMB_plot, aes(x=cluster, y=`IGLC7`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
a <-ggplot(TMB_plot, aes(x=cluster, y=`IGLC7`,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
b <-ggplot(TMB_plot, aes(x=cluster, y=GZMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm
c <-ggplot(TMB_plot, aes(x=cluster, y=PRF1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

##分析免疫检查点
TMB_plot$PDCD1 <- TMB_plot$PDCD1+1
TMB_plot$CD274 <- TMB_plot$CD274+1
TMB_plot$CTLA4 <- TMB_plot$CTLA4+1
a <-ggplot(TMB_plot, aes(x=cluster, y=PDCD1,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

b <-ggplot(TMB_plot, aes(x=cluster, y=CD274,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

c <-ggplot(TMB_plot, aes(x=cluster, y=CTLA4,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c("LumA","Basal")), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.03))#5cm*4cm

library(patchwork)
a|b|c#5*10

####GSEA分析
TMB <- list()
TMB[[1]] <- tmb(maf = IM_LumA_mut)
TMB[[2]] <- tmb(maf = IH_LumA_mut)
TMB[[3]] <- tmb(maf = IM_basal_mut)
TMB[[4]] <- tmb(maf = IH_basal_mut)
names(TMB) <- c('IM_LumA_mut','IH_LumA_mut','IM_basal_mut','IH_basal_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('Basal',nrow(TMB[[3]]))),
                  cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))))
colnames(TMB_plot)[5] <- 'cluster'
# TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
# TMB <- list()
# TMB[[1]] <- tmb(maf = IL_LumA_mut)
# TMB[[2]] <- tmb(maf = IM_LumA_mut)
# TMB[[3]] <- tmb(maf = IH_LumA_mut)
# TMB[[4]] <- tmb(maf = IL_basal_mut)
# TMB[[5]] <- tmb(maf = IM_basal_mut)
# TMB[[6]] <- tmb(maf = IH_basal_mut)
# names(TMB) <- c('IL_LumA_mut','IM_LumA_mut','IH_LumA_mut','IL_basal_mut','IM_basal_mut','IH_basal_mut')
# ##画箱线图
# TMB_plot <- rbind(cbind(TMB[[1]],rep('LumA',nrow(TMB[[1]]))),
#                   cbind(TMB[[2]],rep('LumA',nrow(TMB[[2]]))),
#                   cbind(TMB[[3]],rep('LumA',nrow(TMB[[3]]))),
#                   cbind(TMB[[4]],rep('Basal',nrow(TMB[[4]]))),
#                   cbind(TMB[[5]],rep('Basal',nrow(TMB[[5]]))),
#                   cbind(TMB[[6]],rep('Basal',nrow(TMB[[6]]))))
# colnames(TMB_plot)[5] <- 'cluster'
# TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('LumA','Basal'))
data <- as.data.frame(t(expr_data_raw[[2]]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)
group_list <- TMB_plot[,c(1,5)]
TMB_plot <- TMB_plot[,17:ncol(TMB_plot)]
TMB_plot <- as.data.frame(t(TMB_plot))
colnames(TMB_plot) <- group_list$Tumor_Sample_Barcode
library(GSEABase)
library(limma) 
library(clusterProfiler)
library(enrichplot)
dat <- TMB_plot
group_list <- factor(group_list$cluster,ordered = F)
design <- model.matrix(~factor( group_list ))
fit=lmFit(dat,design)
fit=eBayes(fit)
options(digits = 4)
topTable(fit,coef=2,adjust='BH')
deg=topTable(fit,coef=2,adjust='BH',number = Inf)
a <- TMB_plot[rownames(deg),group_list=='LumA']
deg$LumA_mean <- apply(a,1,mean)
a <- TMB_plot[rownames(deg),group_list=='Basal']
deg$Basal_mean <- apply(a,1,mean)
deg$gene <- rownames(deg)
head(deg)
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c5.go.v7.5.1.symbols.gmt")
geneset <- read.gmt("/database/GSEA/human_pathway_gmt/c7.immunesigdb.v7.5.1.symbols.gmt")
geneList <- deg$logFC
names(geneList) <- toupper(rownames(deg))
geneList <- sort(geneList,decreasing = T)
gsea_results <- GSEA(geneList = geneList,
                     TERM2GENE = geneset,
                     verbose = F,minGSSize = 0,maxGSSize = 500,
                     eps=0,pvalueCutoff = 1)

gsea_results_immune <- GSEA(geneList = geneList,
                            TERM2GENE = geneset,
                            verbose = F,minGSSize = 0,maxGSSize = 500,
                            eps=0,pvalueCutoff = 1)
class(gsea_results)
gseaplot2(x=gsea_results,geneSetID=c('GOBP_B_CELL_MEDIATED_IMMUNITY')) #3*5cm

# for (i in 1:length(list)) {
#   p <- gseaplot2(x=gsea_results,geneSetID=paste("HALLMARK_",list[i],sep="")) 
#   d <- paste("./",list[i],".pdf",sep="")
#   pdf(file=d,
#       family = "Times",width=10,height = 6)
#   print(p)
#   dev.off()
# }
gsea_results@result$core_enrichment[1]

##证明top1000
##修正数据
###################################从头开始画图
####读取算到的数据
#1去除网络计算结果中的RNA等
library(clusterProfiler)
surv_data_clean <- list()
expression <- list()
gene_protein <- read.csv('/database/gene_name_id_data/gene_protein_ID.txt',header = T)
gene_protein <- gene_protein[gene_protein[,3]!='',]
for (i in 1:15) {
  surv_data_clean[[i]] <- list()
  for (j in 1:3) {
    surv_data_clean[[i]][[j]] <- surv_data[[i]][[j]]
    surv_data_clean[[i]][[j]] <- surv_data_clean[[i]][[j]][rownames(surv_data_clean[[i]][[j]])%in%unique(gene_protein$Gene.name),]
  }
  names(surv_data_clean[[i]]) <- c('surv_t','surv_up','surv_down')
  expression[[i]] <- expression_raw[[i]]
  colnames(expression[[i]]) <- gsub(x = colnames(expression[[i]]),pattern = '-',replacement = '.')
  expression[[i]] <- expression[[i]][rownames(expression[[i]])%in%unique(gene_protein$Gene.name),]
}
names(surv_data_clean) <- cancer_name
names(expression) <- cancer_name

##extract top1000
gradient <- c(250,500,1000,2000,4000,8000)
surv_sig_inter_gradient <- list()
hub_gene_gradient <- list()
surv_sig_dgree_gradient <- list()
for (j in 1:6) {
  surv_sig_inter <- list()
  for (i in 1:15) {
    surv_sig_inter[[i]] <- read.csv(paste('result/network/raw_data/',cancer_name[i],'_surv_sig_inter.csv',sep = ''),header = T)
    colnames(surv_sig_inter[[i]]) <- c('gene1','value','gene2')
    a <- surv_sig_inter[[i]][order(surv_sig_inter[[i]][,2],decreasing = T)[gradient[j]],2]
    surv_sig_inter[[i]] <- surv_sig_inter[[i]][surv_sig_inter[[i]][,2]>=a,]
    # write.csv(surv_sig_inter[[i]],paste('result/network/top1000/',cancer_name[i],'_surv_sig_inter_top1000.csv',sep = ''),quote = F,row.names = F)
  }
  names(surv_sig_inter) <- cancer_name
  # surv_sig_inter[[3]] <- read.csv('result/CESC/inter_probality/surv_sig_inter_new.csv')
  #计算度
  hub_gene <- list()
  surv_sig_dgree <- list()
  for (i in 1:15) {
    a <- unique(c(surv_sig_inter[[i]][,1],surv_sig_inter[[i]][,3]))
    b <- c(surv_sig_inter[[i]][,1],surv_sig_inter[[i]][,3])
    surv_sig_dgree[[i]] <- data.frame()
    for (x in 1:length(a)) {
      surv_sig_dgree[[i]][x,1] <- a[x]
      surv_sig_dgree[[i]][x,2] <- sum(b==a[x])
    }
    surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][order(surv_sig_dgree[[i]][,2],decreasing = T),]
    surv_sig_dgree[[i]] <- surv_sig_dgree[[i]][surv_sig_dgree[[i]][,1]%in%rownames(surv_data_sig[[i]][[1]]),]
    colnames(surv_sig_dgree[[i]]) <- c('gene','degree')
    a <- surv_sig_dgree[[i]][surv_sig_dgree[[i]][,1]%in%rownames(expression[[i]])[apply(expression[[i]], 1, mean)>10],]
    a <- a[a[,1]%in%rownames(surv_data_sig[[i]][[1]]),]
    hub_gene[[i]] <- a[1:10,]
    # write.csv(surv_sig_dgree[[i]],paste('result/network/top1000/',cancer_name[i],'_surv_sig_dgree.csv',sep = ''),quote = F,row.names = F)
  }
  names(surv_sig_dgree) <- cancer_name
  names(hub_gene) <- cancer_name
  surv_sig_inter_gradient[[j]] <- surv_sig_inter
  hub_gene_gradient[[j]] <- hub_gene
  surv_sig_dgree_gradient[[j]] <- surv_sig_dgree
}
names(hub_gene_gradient) <- gradient
names(surv_sig_inter_gradient) <- gradient
names(surv_sig_dgree_gradient) <- gradient

#检测不同大小的网络中hub gene的效果验证
library('ggplot2')
library('survival')
library('survminer')
lifetime_all <- list()
for (j in 1:15) {
  lifetime <- read.csv(paste('/database/TCGA/',cancer_name[[j]],'/',cancer_name[[j]],'_clinical_lifetime.csv',sep = ''),row.names = 1)
  lifetime[,6] <- gsub('-','.',lifetime[,6])
  lifetime <- lifetime[which(!duplicated(lifetime[,6])),]
  lifetime[which(lifetime[,2]=='Alive'),2] <- 0
  lifetime[which(lifetime[,2]=='Dead'),2] <- 1
  lifetime_all[[j]] <- lifetime
}##读取临床与生存数据
names(lifetime_all) <- cancer_name
surv_pvalue_gradient <- data.frame()
for (j in 1:6) {
  for (i in 1:15) {
    data <- as.matrix(t(expression[[i]][which(rownames(expression[[i]])%in%hub_gene_gradient[[j]][[i]][,1]),]))
    data <- log2(data+1)
    dist.e <- dist(data,method='euclidean')
    model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
    result <- cutree(model1,k=3)#分类
    result <- as.data.frame(result)
    b <- lifetime_all[[i]]
    b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'M'
    b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'L'
    b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'H'
    c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
    surv_pvalue_gradient[i,j] <- 1-pchisq(c$chisq,length(c$n)-1)
  }
}
colnames(surv_pvalue_gradient) <- gradient
rownames(surv_pvalue_gradient) <- cancer_name

#画折线图
library(tidyr)
library(ggthemes)
surv_pvalue_gradient$cancer_name <- rownames(surv_pvalue_gradient)
surv_pvalue_gradient <- pivot_longer(data = surv_pvalue_gradient,cols = 1:(dim(surv_pvalue_gradient)[2]-1),
                                     names_to = "gradient",##这一个参数是将列名命名为sample_size
                                     values_to = "p_value")
surv_pvalue_gradient$gradient <- factor(surv_pvalue_gradient$gradient,levels = gradient)

plot <- ggplot(surv_pvalue_gradient, aes(x=gradient, y=p_value, colour=cancer_name,group=cancer_name))+
  theme_base()+
  geom_line(size=1)#size是线的宽度
# ggplot(sig_gene_add, aes(x=sample_size, y=count, colour=cancer_name,group=cancer_name))+
#   geom_line(size=1)#size是线的宽度
pdf(paste('result/Figure/AI_plot_new/fig1/V5/sfig2b.pdf',sep = ''), width=10, height=5)
print(plot,newpage = FALSE)
dev.off()




summary(c)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.1,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)
p <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#ED5163", "#4498F2","#89C890"),
                        breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        labels = c("L","M","H"))##对齐坐标轴原点#4cm*5cm

data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%surv_sig_dgree[[8]][1:10,1]),]))
data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),'/',length(which(result[,1]==5)),sep = '')
a <- cbind(rownames(result),result)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- luad_subtype
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'ML'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'MH'

##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,8]=='PI',6],],data[rownames(data)%in%b[b[,8]=='PP',6],],data[rownames(data)%in%b[b[,8]=='TRU',6],])
hotmap <- rbind(hotmap[rownames(hotmap)%in%b[b[,7]=='ML',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MM',6],],hotmap[rownames(hotmap)%in%b[b[,7]=='MH',6],])
annotation_col <- rbind(b[b[,7]=='ML',7:8],b[b[,7]=='MM',7:8],b[b[,7]=='MH',7:8])
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster','subtype')
rownames(annotation_col) <- c(b[b[,7]=='ML',6],b[b[,7]=='MM',6],b[b[,7]=='MH',6])
ann_colors = list(subtype = c(PI="blue", PP="#F2CA20",TRU="#E24A0E"), #连续数值型分组可设置成渐变  
                  cluster = c(ML="#89C890",MM="#4498F2", MH="#ED5163")) 
# hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
bk = unique(c(seq(-3,3, length=100)))
plot <- pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,
                           show_colnames = F,breaks = bk,treeheight_row = 4,
                           color = c(colorRampPalette(c("navy","white"))(50),colorRampPalette(c("white","red"))(50)),
                           annotation_colors = ann_colors)#4cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig3/V4/fig3D.pdf',sep = ''), width=8, height=4)
print(plot,newpage = F)
dev.off()
##画柱状图看统计情况堆叠柱状图
library(tidyr)
subtype_sum <- data.frame()
for (i in 1:3) {
  subtype_sum[1,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='PI'))
  subtype_sum[2,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='PP'))
  subtype_sum[3,i] <- length(which(b[b[,7]==c('MM','ML','MH')[i],8]=='TRU'))
}
colnames(subtype_sum) <- c('MM','ML','MH')
rownames(subtype_sum) <- c('PI','PP','TRU')
subtype_sum <- apply(subtype_sum, 2, function(x){x/sum(x)})
subtype_sum <- as.data.frame(subtype_sum)
subtype_sum[1:3,4] <- rownames(subtype_sum)
colnames(subtype_sum)[4] <- 'subtype'
subtype_sum <- pivot_longer(data = subtype_sum,cols = 1:(ncol(subtype_sum)-1),
                            names_to = "cluster",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$subtype <- factor(subtype_sum$subtype)
subtype_sum$cluster <- factor(subtype_sum$cluster,levels = c('ML','MM','MH'))

p <- ggplot(subtype_sum, aes(x=cluster, y=percents,fill=subtype)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack",color="black", width=0.6,size=0.25)+
  scale_fill_manual(values=c("blue","#F2CA20","#E24A0E"))+
  labs(x = "",y = "Percent")+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()#6cm*5cm
p#6cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig3/V4/fig3E.pdf',sep = ''), width=5, height=6)
print(p,newpage = F)
dev.off()
##生存分析分组状况
#聚类分组
library('survival')
library('survminer')
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(4000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(4000,1)#P值方法文本坐标
)












b <- lifetime[[j]]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'X'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'Y'
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
p_value[[3]][[j]][nrow(p_value[[3]][[j]]),4] <- 1-pchisq(c$chisq,1)


##绘制点状分布图
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(RColorBrewer)
library(SuppDists) #提供rJohnson()函数
library(ggbeeswarm)
library(scales)
for (i in 1:15) {
  A <- surv_data_clean[[i]][[1]]
  for (j in 1:ncol(A)) {
    colnames(A)[j] <- as.character(substring(colnames(A)[j],2,nchar(colnames(A)[j])))
  }
  a <- surv_p_all[[i]][rownames(surv_p_all[[i]])%in%rownames(A),2]
  # sum(rownames(a)==rownames(A))
  A$group <- a
  A$Gene <- rownames(A)
  A <- pivot_longer(data = A,cols = 1:(dim(A)[2]-2),
                    names_to = "Type",values_to = "count")
  str_sort(unique(A$Type),numeric = T)
  A$Type <- factor(A$Type, levels = str_sort(unique(A$Type),numeric = T))
  A$Type <- as.factor(A$Type)
  A$Type <- fct_inorder(A$Type)
  A$group <- factor(A$group,levels = c('non-sig','sig'))
  A$sig_gene[A$Gene%in%rownames(surv_data_sig[[i]][[1]])] <- A$Gene[A$Gene%in%rownames(surv_data_sig[[i]][[1]])]
  A$sig_gene[is.na(A$sig_gene)] <- 1:sum(is.na(A$sig_gene))
  # A$group <- fct_inorder(A$group)
  plot <- ggplot(A, aes(x=Type, y=count,fill=group))+
    geom_jitter(aes(fill = group),position = position_jitter(0.3),shape=21, size = 0.001,color = "#FFDADC00")+
    # scale_fill_manual(values=c(brewer.pal(7,"Set2")[c(1,2,4,5,6,7,8,9,10)]))+
    theme_classic()+
    theme(legend.direction = "horizontal", legend.position = "top")+
    labs(title = cancer_name[i], y="Probability of significance", x = "Sample Size")+
    scale_y_continuous(limits = c(-0.001,1.001),expand = c(0,0))+
    geom_hline(yintercept = 0.8,linetype = "dashed")+
    theme(panel.background=element_rect(fill="white",colour="black",size=0.25),
          axis.line=element_line(colour="black",size=0.25),
          axis.title=element_text(size=13,face="plain",color="black"),
          axis.text = element_text(size=12,face="plain",color="black"),
          legend.position="none")+
    geom_line(aes(group = sig_gene), color = 'gray', lwd = 0.01) +  #绘制配对样本间连线
    theme(axis.title = element_text(size = 14))
  #蜂群图
  # plot <-ggplot(A[1:1000,], aes(x=Type, y=count,fill=group))+
  # geom_beeswarm(aes(fill = group),shape=21,colour="black",size=0.001,cex=2)+
  # scale_fill_manual(values= c(brewer.pal(7,"Set2")[c(1,2,4,5,6,7,8,9,10)]))+ 
  # xlab("sample size")+
  # ylab("significant probability")+
  # theme_classic()+
  # theme(panel.background=element_rect(fill="white",colour="black",size=0.25),
  #       axis.line=element_line(colour="black",size=0.25),
  #       axis.title=element_text(size=13,face="plain",color="black"),
  #       axis.text = element_text(size=12,face="plain",color="black"),
  #       legend.position="none"
  # )
  # pdf(paste('result/Figure/AI_plot_new/fig1/V5/s_fig1/',cancer_name[i],'_v2.pdf',sep = ''), width=6, height=5)
  # print(plot,newpage = FALSE)
  # dev.off()
  # plot <- ggplot(A, aes(fill=group, y=count, x=Type))+
  #   geom_bar(position=position_dodge(),stat="summary",colour = "black",size=1)+
  #   theme_classic(base_size = 12)+
  #   theme(legend.direction = "horizontal", legend.position = "top")+
  #   labs(title = cancer_name[i], y="Surv-sig rate ", x = "Sample Size")+
  #   stat_summary(fun.data = 'mean_se', geom = "errorbar", colour = "black",
  #                width = 0.5,position = position_dodge(1))+
  #   scale_y_continuous(limits = c(0,1),expand = c(0,0))+
  #   theme(axis.text.x = element_text(size = 12))+
  #   theme(axis.text.y = element_text(size = 12))+
  #   theme(axis.title = element_text(size = 14))
  pdf(paste('result/Figure/AI_plot_new/fig1/V5/s_fig1/',cancer_name[i],'_v3.pdf',sep = ''), width=6, height=5)
  print(plot,newpage = FALSE)
  dev.off()
}

mean(as.numeric(expression[['STAD']][rownames(expression[['STAD']])=='SORCS2',]))

#Fig3A-C
for (i in 1:15) {
  a <- mitotic_gene_expr_crispr[[i]]##LGG
  b <- apply(a, 1, mean)
  a <- a[order(b,decreasing = F),]
  annotation_row <- as.data.frame(rownames(a))
  rownames(annotation_row) <- annotation_row[,1]
  annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
  annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
  colnames(annotation_row) <- 'function'
  d <- factor(annotation_row[,1])
  annotation_row[,1] <- d
  bk = unique(c(seq(0,1, length=100)))
  ann_colors = list('function' = c(mitotic = "#AD0723", other = "gray"))
  a <- pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,main = cancer_name[i],
                          color = c(colorRampPalette(c("white","#AD0723"))(100)),
                          clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                          cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                          annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm
  pdf(paste('result/Figure/AI_plot_new/fig3/V5/crispr/v5/','fig3_',cancer_name[i],'.pdf',sep = ''), width=5, height=4.1)
  print(a,newpage = F)
  dev.off()
}

#突变图
IL_mut <- read.maf(maf ='result/BRCA/mutation/IL_mut_new.maf')
IM_mut <- read.maf(maf ='result/BRCA/mutation/IM_mut_new.maf')
IH_mut <- read.maf(maf ='result/BRCA/mutation/IH_mut_new.maf')
#突变负荷差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_mut)
TMB[[2]] <- tmb(maf = IM_mut)
TMB[[3]] <- tmb(maf = IH_mut)
names(TMB) <- c('IL_mut','IM_mut','IH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_mut',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_mut',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_mut','IM_mut','IH_mut'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

library(ggplot2)
library(ggpubr)
library(scales)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL_mut','IM_mut'),c('IM_mut','IH_mut'),c('IL_mut','IH_mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(7,7,8),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig8/V5/fig8F.pdf",width = 4,height = 5)
print(a,newpage = F)
dev.off()
#差异突变
IL_mut_vs_IM_mut <- mafCompare(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL_mut', m2Name = 'IM_mut', minMut = 2, useCNV =FALSE)
IM_mut_vs_IH_mut <- mafCompare(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
IL_mut_vs_IH_mut <- mafCompare(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)


forestPlot(mafCompareRes = IL_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
r1<-IL_mut_vs_IM_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V6/fig8C.pdf",width = 12,height = 3)
coOncoplot(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL', m2Name = 'IM', genes = g, 
           removeNonMutated = T)
dev.off()

r1<-IM_mut_vs_IH_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V6/fig8D.pdf",width = 12,height = 3)
coOncoplot(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = T)
dev.off()

r1<-IL_mut_vs_IH_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V6/fig8E.pdf",width = 12,height = 3)
coOncoplot(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = T)
dev.off()

#fig6A
library(tidyr)
library(stringr)
library(ggplot2)
a <- surv_median
a$cancer_type <- rownames(a)
a <- pivot_longer(data = a,cols = 1:3,names_to = 'bio_process',values_to = 'surv_pvalue')
a$surv_pvalue <- -log10(a$surv_pvalue)
c <- str_split(string = a$cancer_type,pattern = '-',simplify = T)
a$cancer_type <- c[,2]
a <- a[a$bio_process!='EMT_score',]
a$bio_process <- factor(a$bio_process,levels = c('mitotic_score','immune_score'))
plot <- ggplot(a,aes(x=cancer_type,y=surv_pvalue,fill = bio_process))+
  geom_point(aes(size=1,color=`bio_process`))+
  # scale_color_gradient(high="#F20808",low="#1E08F7")+
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text.x=element_text(angle=90,hjust = 1,vjust=0.5))+
  geom_hline(yintercept = c(-log10(0.05)),linetype = "dashed")+
  # annotate('text',x=150,y=2.2,label=expression('resistant'),size=4,color='red')+
  labs(x=NULL,y='-log10(p_value)',title = 'Survival analysis - Median grouping')#3.54cm*4.34cm
pdf(paste('result/Figure/AI_plot_new/fig10/V6/fig10A.pdf',sep = ''), width=15, height=5)
print(plot,newpage = F)
dev.off()

##乳腺癌分析
#fig8A
#先看看整体BRCA的分类情况
####BRCA层次聚类
library(ggplot2)
data <- as.matrix(t(expression[[2]][which(rownames(expression[[2]])%in%hub_gene[[2]][,1]),]))
# for (i in 1:ncol(data)) {
#   data[,i] <- scale(as.numeric(data[,i]))
# }
data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),'/',length(which(result[,1]==4)),sep = '')
a <- cbind(rownames(result),result)
colnames(a)[1] <- colnames(BRCA_subtype)[1]
a <- merge(a,BRCA_subtype[,c(1,3)],by = 'V1',all = F)
rownames(a) <- a[,1]
a <- a[,-1]
colnames(a) <- c('cluster','subtype')
result <- a
annotation_col <- result
annotation_col[annotation_col[,1]==1,1] <- 'IM'
annotation_col[annotation_col[,1]==2,1] <- 'IL'
annotation_col[annotation_col[,1]==3,1] <- 'IH'
a <- rbind(data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumA'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='LumB'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Her2'],],
           data[rownames(data)%in%rownames(annotation_col)[annotation_col[,2]=='Basal'],])
a <- rbind(a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IL'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IM'],],
           a[rownames(a)%in%rownames(annotation_col)[annotation_col[,1]=='IH'],])#4cm*8cm


a <- t(a)
bk = unique(c(seq(-3,3, length=200)))
ann_colors = list(subtype = c(LumA="#E8C42B", LumB="#D64A16",Her2="#18499E",Basal="gray"), #连续数值型分组可设置成渐变  
                  cluster = c(IL = "#86C18C",IM = '#4B8ECC',IH = "#DF5160")) 
# a <- t(data)
plot <- pheatmap::pheatmap(a,show_colnames = F,show_rownames = T,
                           annotation_colors = ann_colors,
                           clustering_method = 'ward.D2', 
                           color = c(colorRampPalette(c("navy", "white"))(100),
                                     colorRampPalette(c("white",rgb(0.8,0,0)))(100)),
                           cluster_cols = F,cluster_rows = T,treeheight_row = 3,
                           annotation_col = annotation_col
                           # ,breaks = bk
)#5*8
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8A.pdf',sep = ''), width=8, height=5)
print(plot,newpage = F)
dev.off()
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
write.csv(annotation_col,'Table6.csv')

#聚类生存分析
library(survival)
library(survminer)
b <- lifetime_all[[2]]
b <- b[b[,6]%in%rownames(annotation_col),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'IM'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'IL'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'IH'

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.2,0.2),         # 指定图例位置
                   title = c('BRCA_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        type = c("#86C18C","#DF5160",'#4B8ECC'),
                        labels = c('IL','IM','IH'))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8C.pdf',sep = ''), width=5, height=4)
print(plot,newpage = F)
dev.off()

##画柱状图看统计情况堆叠柱状图
for (i in 1:nrow(b)) {
  b[i,8] <- annotation_col[rownames(annotation_col)==b[i,6],2]
}
library(tidyr)
subtype_sum <- data.frame()
for (i in 1:3) {
  subtype_sum[1,i] <- length(which(b[b[,7]==c('IH','IM','IL')[i],8]=='LumA'))
  subtype_sum[2,i] <- length(which(b[b[,7]==c('IH','IM','IL')[i],8]=='LumB'))
  subtype_sum[3,i] <- length(which(b[b[,7]==c('IH','IM','IL')[i],8]=='Her2'))
  subtype_sum[4,i] <- length(which(b[b[,7]==c('IH','IM','IL')[i],8]=='Basal'))
}
colnames(subtype_sum) <- c('IH','IM','IL')
rownames(subtype_sum) <- c('LumA','LumB','Her2','Basal')
subtype_sum <- apply(subtype_sum, 2, function(x){x/sum(x)})
subtype_sum <- as.data.frame(subtype_sum)
subtype_sum[1:4,4] <- rownames(subtype_sum)
colnames(subtype_sum)[4] <- 'subtype'
subtype_sum <- pivot_longer(data = subtype_sum,cols = 1:(ncol(subtype_sum)-1),
                            names_to = "cluster",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$subtype <- factor(subtype_sum$subtype,levels = c('LumA','LumB','Her2','Basal'))
subtype_sum$cluster <- factor(subtype_sum$cluster,levels = c('IL','IM','IH'))

p <- ggplot(subtype_sum, aes(x=cluster, y=percents,fill=subtype)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack",color="black", width=0.6,size=0.25)+
  scale_fill_manual(values=c("#F2CA20","#E24A0E","blue",'gray'))+
  labs(x = "",y = "Percent")+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()#6cm*5cm
p#6cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8E.pdf',sep = ''), width=5, height=6)
print(p,newpage = F)
dev.off() 

#亚型生存曲线
all_subtype <- read.table('/database/TCGA/BRCA/subtype/TCGASubtype.20170308.tsv')
BRCA_subtype <- all_subtype[all_subtype[,2]=='BRCA',1:3]
BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]!='Normal',]
#BRCA_subtype <- BRCA_subtype[BRCA_subtype[,3]=='Basal',]##三阴性
a <- as.data.frame(str_split(BRCA_subtype[,1],pattern = '-',simplify = T))
a <- apply(a, 1, function(x){paste(x[1],x[2],x[3],x[4],sep = '.')})
BRCA_subtype[,1] <- a
annotation_row <- BRCA_subtype
annotation_row <- annotation_row[annotation_row[,1]%in%rownames(data),]
b <- annotation_row[,1]
annotation_row <- as.data.frame(annotation_row[,3])
rownames(annotation_row) <- b
colnames(annotation_row) <- 'BRCA_subtype'

b <- lifetime_all[[2]]
b <- b[b[,6]%in%rownames(annotation_col),]
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumA"],7] <- "LumA"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="LumB"],7] <- "LumB"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Basal"],7] <- "Basal"
b[b[,6]%in%rownames(annotation_row)[annotation_row[,1]=="Her2"],7] <- "Her2"

b$vital_status[which(b$V5 > 3650)] <- 0
b$V5[which(b$V5 > 3650)] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   add.all = F,     # 添加总患者生存曲线
                   palette = "hue",    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = TRUE,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.2,0.2),         # 指定图例位置
                   title = c('BRAD_subtype'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 365,# 设置x轴刻度间距
                   pval.method=T)

plot <- plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_colour_discrete(breaks = plot$plot$plot_env$legend.labs[c(3,4,2,1)],#图例位置
                        type = c("#18499E","gray","#E8C42B","#D64A16"),
                        labels = c("LumA","LumB","Basal","Her2"))##对齐坐标轴原点#4cm*5cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8B.pdf',sep = ''), width=5, height=4)
print(plot,newpage = F)
dev.off()

####分析主要是哪种免疫细胞在起作用





####计算显著基因与免疫浸润和激活的相关性
library(Hmisc)
names(expr_data_raw) <- cancer_name
sig_gene_immune_analysis <- list()
for (i in 1:15) {
  immune <- as.matrix(t(rbind(expr_data_raw[[i]][1:10,])))
  a <- as.matrix(t(expr_data_raw[[i]][rownames(expr_data_raw[[i]])%in%hub_gene[[i]][,1],]))
  immune_cor <- rcorr(a,immune,type = 'spearman')
  r <- as.data.frame(immune_cor$r)
  r <- r[colnames(r)%in%colnames(immune),rownames(r)%in%colnames(a)]
  sig_gene_immune_analysis[[i]] <- r
}
names(sig_gene_immune_analysis) <- cancer_name

bk = unique(c(seq(-1,1, length=200)))
plot <- pheatmap::pheatmap(sig_gene_immune_analysis[[2]],breaks = bk,show_rownames = T,
                           color = c(colorRampPalette(c("navy", "white"))(100),colorRampPalette(c("white","red"))(100)),
                           clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,cluster_cols = T,
                           treeheight_row = 8,treeheight_col = 8)#8cm*8cm
pdf(paste('result/Figure/AI_plot_new/fig8/V5/fig8D.pdf',sep = ''), width=8, height=8)
print(plot,newpage = F)
dev.off()

#突变分析
library(scales)
#fig8D
##查看免疫浸润高低的突变差异
BRCA_mut_raw <- read.maf(maf = '/database/TCGA/BRCA/mutation/TCGA_BRCA_mutation.maf',clinicalData = '/database/TCGA/BRCA/mutation/clinical.tsv')
BRCA_mut <- BRCA_mut_raw@data
BRCA_mut$Tumor_Sample_Barcode <- gsub(BRCA_mut$Tumor_Sample_Barcode,pattern = '-',replacement = '.')

a <- rownames(annotation_col)
a <- substring(text = a,first = 1,last = 12)
IL_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IL'],]
IM_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IM'],]
IH_mut <- BRCA_mut[BRCA_mut$Tumor_Sample_Barcode%in%a[annotation_col$cluster=='IH'],]

write.table(IL_mut,'result/BRCA/mutation/IL_mut_new.maf',sep = '\t',quote = F,row.names = F)
write.table(IM_mut,'result/BRCA/mutation/IM_mut_new.maf',sep = '\t',quote = F,row.names = F)
write.table(IH_mut,'result/BRCA/mutation/IH_mut_new.maf',sep = '\t',quote = F,row.names = F)

IL_mut <- read.maf(maf ='result/BRCA/mutation/IL_mut_new.maf')
IM_mut <- read.maf(maf ='result/BRCA/mutation/IM_mut_new.maf')
IH_mut <- read.maf(maf ='result/BRCA/mutation/IH_mut_new.maf')
#突变负荷差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_mut)
TMB[[2]] <- tmb(maf = IM_mut)
TMB[[3]] <- tmb(maf = IH_mut)
names(TMB) <- c('IL_mut','IM_mut','IH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_mut',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_mut',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_mut','IM_mut','IH_mut'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

library(ggplot2)
library(ggpubr)
library(scales)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  scale_y_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x),
                     labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL_mut','IM_mut'),c('IM_mut','IH_mut'),c('IL_mut','IH_mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(7,7,8),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig8/V5/fig8F.pdf",width = 4,height = 5)
print(a,newpage = F)
dev.off()
#差异突变
IL_mut_vs_IM_mut <- mafCompare(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL_mut', m2Name = 'IM_mut', minMut = 2, useCNV =FALSE)
IM_mut_vs_IH_mut <- mafCompare(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)
IL_mut_vs_IH_mut <- mafCompare(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL_mut', m2Name = 'IH_mut', minMut = 2, useCNV =FALSE)


forestPlot(mafCompareRes = IL_mut_vs_IH_mut, pVal = 0.05, color = c('royalblue', 'maroon'), geneFontSize = 0.8)
r1<-IL_mut_vs_IM_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V5/fig8G.pdf",width = 12,height = 3)
coOncoplot(m1 = IL_mut, m2 = IM_mut, m1Name = 'IL', m2Name = 'IM', genes = g, removeNonMutated = T)
dev.off()

r1<-IM_mut_vs_IH_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V5/fig8H.pdf",width = 12,height = 3)
coOncoplot(m1 = IM_mut, m2 = IH_mut, m1Name = 'IM', m2Name = 'IH', genes = g, removeNonMutated = T)
dev.off()

r1<-IL_mut_vs_IH_mut$results
g0<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
g1<-r1[order(r1$pval,decreasing = F)[1:10],Hugo_Symbol]
l<-length(g0)
ifelse(l>5,g<-g0,g<-g1)
pdf("result/Figure/AI_plot_new/fig8/V5/fig8I.pdf",width = 12,height = 3)
coOncoplot(m1 = IL_mut, m2 = IH_mut, m1Name = 'IL', m2Name = 'IH', genes = g, removeNonMutated = T)
dev.off()

#对10种免疫细胞都做一下比较，看看是哪种细胞的浸润影响大
##fig8C
# 判断是什么免疫细胞
data <- expression_raw[[2]][1:10,]
# for (i in 1:10) {
#   data[,i] <- log2(as.numeric(data[,i])+1)
# }
library(ggplot2)
library(forcats)
library(tidyr)
library(tidyverse)
library(ggthemes)

for (i in 1:10) {
  a <- data.frame(sample=colnames(data))
  a$immune_cell <- as.numeric(data[i,])
  a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IL']] <- 'IL'
  a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IM']] <- 'IM'
  a$group[a$sample%in%rownames(annotation_col)[annotation_col$cluster=='IH']] <- 'IH'
  a <- a[!is.na(a$group),]
  a$immune_cell <- a$immune_cell*100
  a$group <- factor(a$group,levels = c('IL','IM','IH'))
  plot <- ggplot(a, aes(fill=group, y=immune_cell, x=group)) +
    geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
    labs(title = rownames(data)[i], y='immune_cell_rate(%)', x = 'cluster')+
    theme_classic()+
    scale_y_continuous(expand = c(0,0),limits = c(0,mean(a$immune_cell)+6))+
    geom_signif(comparisons = list(c("IL",'IM'),c("IM","IH"),c("IL","IH")), 
                map_signif_level = TRUE, test = t.test, y_position = c((mean(a$immune_cell)),(mean(a$immune_cell)),(mean(a$immune_cell)+1)),
                tip_length = c(0.003,0.003,0.003))#5cm*4cm
  pdf(paste('result/Figure/AI_plot_new/fig8/V5/sfig/sfig_',rownames(data)[i],'.pdf',sep = ''), width=6, height=4)
  print(plot,newpage = F)
  dev.off()
}
which(rownames(surv_data[[2]][[1]])=='CDH1')

#fig8B 肿瘤新抗原的生成
b <- annotation_col
b$sample_id <- rownames(b)
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
BRCA_newantigen <- read.table('/database/TCIA/BRCA/Neoantigens/TCIA-NeoantigensData.tsv',header = T)
BRCA_newantigen$patient <- gsub(pattern = '-',replacement = '.',x = BRCA_newantigen$patientBarcode)
for (i in 1:nrow(b)) {
  a <- BRCA_newantigen[BRCA_newantigen$patient==b$patient[i],]
  b$neoantigens[i] <- nrow(a)
}
b$cluster <- factor(b$cluster,levels = c('IL','IM','IH'))
b$neoantigens <- b$neoantigens+1
a <- ggplot(b, aes(x=cluster, y=neoantigens,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(12,12,13),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm



#fig8C TMB的比较
#突变负荷差异
TMB <- list()
TMB[[1]] <- tmb(maf = IL_mut)
TMB[[2]] <- tmb(maf = IM_mut)
TMB[[3]] <- tmb(maf = IH_mut)
names(TMB) <- c('IL_mut','IM_mut','IH_mut')
##画箱线图
TMB_plot <- rbind(cbind(TMB[[1]],rep('IL_mut',nrow(TMB[[1]]))),
                  cbind(TMB[[2]],rep('IM_mut',nrow(TMB[[2]]))),
                  cbind(TMB[[3]],rep('IH_mut',nrow(TMB[[3]]))))
colnames(TMB_plot)[5] <- 'cluster'
TMB_plot$cluster <- factor(TMB_plot$cluster,levels=c('IL_mut','IM_mut','IH_mut'))
data <- as.data.frame(t(expr_data_raw[[2]][1:11,]))
a <- rownames(data)
a <- substring(text = a,first = 1,last = 12)
data$Tumor_Sample_Barcode <- a
data <- data[!data$Tumor_Sample_Barcode%in%data$Tumor_Sample_Barcode[duplicated(data$Tumor_Sample_Barcode)],]
TMB_plot <- merge(TMB_plot,data,by = 'Tumor_Sample_Barcode',all = F)

library(scales)
a <-ggplot(TMB_plot, aes(x=cluster, y=total_perMB,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('IL_mut','IM_mut'),c('IM_mut','IH_mut'),c('IL_mut','IH_mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(7,7,8),
              tip_length = c(0.02,0.02,0.02))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig8/V5/fig8F.pdf",width = 4,height = 5)
print(a,newpage = F)
dev.off()

#fig9A CDH1突变的差异对CDH1表达量的影响
a <- expression[[2]][c('CDH1','CDH2','VIM'),]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
a <- BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='CDH1']
b$CDH1_mut[b$patient%in%a] <- 'mut'
b$CDH1_mut[!b$patient%in%a] <- 'wt'

a <- ggplot(b, aes(x=CDH1_mut, y=CDH1,fill=CDH1_mut)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

#fig9B 分析CDH1表达量和免疫浸润的相关性
a <- expression_raw[[2]][1:11,]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
cor.test(b$CDH1,b$`T cell CD8+`,method = 'spearman')

a <- b
# a$CDH1 <- -1*a$CDH1
# a$CDH1 <- 1/a$CDH1

# ggscatter(a,x="CDH1",y="T cell CD8+",color = 'steelblue',add = "reg.line",conf.int = F)+
#   labs(y = "CDH1_expression",
#        x = "Days post-symptom onset")+
#   geom_point(color = "steelblue", size = 2)+
#   geom_smooth(color="red",method="lm",se=FALSE)+
#   stat_cor(label.x = 8, label.y = 0.2,method = 'spearman')+
#   scale_y_continuous(expand = c(0,0),n.breaks = 5)+scale_x_continuous(expand = c(0,0),n.breaks = 5)

ggplot(a, aes(x = CDH1, y = `T cell CD8+`)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'T cell CD8+', title = 'CDH1_CD8+', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,0.22))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 8, label.y = 0.2,method = 'spearman')

#fig9CD CDH1表达量与VIM和CDH2含量的相关性，猜测CDH1可能是通过EMT进行调控
cor.test(b$CDH1,b$CDH2,method = 'spearman')
cor.test(b$CDH1,b$VIM,method = 'spearman')
cor.test(b$CDH1[b$CDH1_mut=='mut'],b$CDH2[b$CDH1_mut=='mut'],method = 'spearman')
cor.test(b$CDH1[b$CDH1_mut=='mut'],b$VIM[b$CDH1_mut=='mut'],method = 'spearman')
cor.test(b$CDH1[b$CDH1_mut=='wt'],b$CDH2[b$CDH1_mut=='wt'],method = 'spearman')
cor.test(b$CDH1[b$CDH1_mut=='wt'],b$VIM[b$CDH1_mut=='wt'],method = 'spearman')
cor.test(b$CDH2[b$CDH1_mut=='wt'],b$VIM[b$CDH1_mut=='wt'],method = 'spearman')

p <- ggplot(a, aes(x=CDH1_mut, y=VIM,fill=CDH1_mut)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

p <- ggplot(a, aes(x=CDH1_mut, y=CDH2,fill=CDH1_mut)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

a$CDH1_level[a$CDH1>mean(a$CDH1)] <- 'high'
a$CDH1_level[a$CDH1<=mean(a$CDH1)] <- 'low'
p <- ggplot(a, aes(x=CDH1_level, y=CDH2,fill=CDH1_level)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('low','high')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

p <- ggplot(a, aes(x=CDH1_level, y=VIM,fill=CDH1_level)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('low','high')), 
              map_signif_level = TRUE, test = t.test, y_position = c(8),
              tip_length = c(0.02))#5cm*4cm

#fig9E 分析CDH1突变的细胞系中上皮基因表达的变化
#证明EMT可能是造成差异的原因之一

#fig9A
b <- annotation_col
b$sample_id <- rownames(b)
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
BRCA_newantigen <- read.table('/database/TCIA/BRCA/Neoantigens/TCIA-NeoantigensData.tsv',header = T)
BRCA_newantigen$patient <- gsub(pattern = '-',replacement = '.',x = BRCA_newantigen$patientBarcode)
for (i in 1:nrow(b)) {
  a <- BRCA_newantigen[BRCA_newantigen$patient==b$patient[i],]
  b$neoantigens[i] <- nrow(a)
}
b$cluster <- factor(b$cluster,levels = c('IL','IM','IH'))
b$neoantigens <- b$neoantigens+1

a <- expression_raw[[2]][1:11,]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
b$immune_score <- b$`B cell`+b$`Macrophage M2`+b$`T cell CD8+`
library(ggplot2)
library(forcats)
library(ggpubr)
library(tidyverse)
library(ggthemes)
a <- ggplot(b, aes(x=cluster, y=immune_score,fill=cluster)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  labs(x = 'cluster', y = 'immune_cell(%)', subtitle = '')+
  theme_classic()+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1,1,1.1),
              tip_length = c(0,0,0))#5cm*4cm

a <- ggplot(b,aes(x=cluster, y=immune_score))+
  geom_violin(aes(fill=cluster),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#FB5554','#4B87BF','#84BB88'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'cluster', y = 'immune_cell_rate')+
  scale_y_continuous(expand = c(0,0),limits = c(0,1))+
  geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
              map_signif_level = TRUE, test = t.test, y_position = c(0.8,0.8,0.9),
              tip_length = c(0,0,0))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig9/V5/fig9A.pdf",width = 8,height = 10)
print(a,newpage = F)
dev.off()
#画出所有类型的免疫细胞比例
b <- annotation_col
b$sample_id <- rownames(b)
b$patient <- substring(text = b$sample_id,first = 1,last = 12)
BRCA_newantigen <- read.table('/database/TCIA/BRCA/Neoantigens/TCIA-NeoantigensData.tsv',header = T)
BRCA_newantigen$patient <- gsub(pattern = '-',replacement = '.',x = BRCA_newantigen$patientBarcode)
for (i in 1:nrow(b)) {
  a <- BRCA_newantigen[BRCA_newantigen$patient==b$patient[i],]
  b$neoantigens[i] <- nrow(a)
}
b$cluster <- factor(b$cluster,levels = c('IL','IM','IH'))
b$neoantigens <- b$neoantigens+1

a <- expression_raw[[2]][1:11,]
colnames(a) <- gsub(x=colnames(a),pattern = '-',replacement = '.')
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
b$immune_score <- 1-b$`uncharacterized cell`
apply(b[b$cluster=='IH',6:17], 2, mean)
apply(b[b$cluster=='IM',6:17], 2, mean)
apply(b[b$cluster=='IL',6:17], 2, mean)
immune_cell_type <- colnames(a)[1:10]
for (i in 1:10) {
  plot <- b[,c(2,5+i)]
  colnames(plot)[2] <- 'immune_cell'
  plot <- ggplot(plot,aes(x=cluster, y=immune_cell))+
    geom_violin(aes(fill=cluster),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
    scale_fill_manual(values = c('#FB5554','#4B87BF','#84BB88'))+
    geom_boxplot(width=0.1,cex=1.2)+
    theme_classic(base_size = 20)+
    theme(axis.text = element_text(color = 'black'),
          legend.position = 'none')+
    labs(y = immune_cell_type[i])+
    scale_y_continuous(expand = c(0,0),limits = c(0,max(plot[,2])+0.3))+
    geom_signif(comparisons = list(c('IL','IM'),c('IM','IH'),c('IL','IH')), 
                map_signif_level = TRUE, test = t.test, y_position = c(max(plot[,2])+0.1,max(plot[,2])+0.1,max(plot[,2])+0.2),
                tip_length = c(0,0,0))#5cm*4cm
  pdf(paste0("result/Figure/total Figure/sfig3/",immune_cell_type[i],'.pdf'),width = 6,height = 6)
  print(plot,newpage = F)
  dev.off()
}


#fig9B
a <- expression[[2]][c('CDH1','CDH2','VIM','SNAI1','SNAI2','TWIST1','TWIST2',
                       'ZEB1'),]
a <- as.data.frame(t(a))
a$sample_id <- rownames(a)
b <- merge(b,a,by='sample_id',all=F)
a <- BRCA_mut$Tumor_Sample_Barcode[BRCA_mut$Hugo_Symbol=='CDH1']
b$CDH1_mut[b$patient%in%a] <- 'mut'
b$CDH1_mut[!b$patient%in%a] <- 'wt'
a <- ggplot(b, aes(x=CDH1_mut, y=CDH1,fill=CDH1_mut)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  labs(x = 'CDH1_type', y = 'CDH1_expression', title = '', subtitle = '')+
  theme_classic()+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(2000),
              tip_length = c(0))#5cm*4cm
b$CDH1_mut <- factor(x = b$CDH1_mut,levels = c('wt','mut'))
a <- ggplot(b, aes(x=CDH1_mut, y=CDH1))+
  geom_violin(aes(fill=CDH1_mut),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_type', y = 'CDH1_expression')+
  scale_y_continuous(expand = c(0,0),limits = c(0,2500))+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(2200),
              tip_length = c(0))#5cm*4cm
a <- ggplot(b, aes(x=CDH1_mut, y=CDH2))+
  geom_violin(aes(fill=CDH1_mut),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_type', y = 'CDH2_expression')+
  scale_y_continuous(expand = c(0,0),limits = c(0,600))+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(610),
              tip_length = c(0))#5cm*4cm
a <- ggplot(b, aes(x=CDH1_mut, y=VIM))+
  geom_violin(aes(fill=CDH1_mut),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_type', y = 'VIM_expression')+
  scale_y_continuous(expand = c(0,0),limits = c(0,2000))+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(2000),
              tip_length = c(0))#5cm*4cm
a <- ggplot(b, aes(x=CDH1_mut, y=EMT_score))+
  geom_violin(aes(fill=CDH1_mut),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_type', y = 'EMT_expression')+
  scale_y_continuous(expand = c(0,0),limits = c(0,2))+
  geom_signif(comparisons = list(c('wt','mut')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1.5),
              tip_length = c(0))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig9/V5/fig9B.pdf",width = 8,height = 10)
print(a,newpage = F)
dev.off()
'immune_cell(%)'

#fig9C
b$CDH1_level[b$CDH1>median(b$CDH1)] <- 'high'
b$CDH1_level[b$CDH1<=median(b$CDH1)] <- 'low'
# b$immune_score <- b$`B cell`+b$`Macrophage M2`+b$`T cell CD8+`
b$immune_score <- 1-b$`uncharacterized cell`

a <- ggplot(b, aes(x=CDH1_level, y=immune_score,fill=CDH1_level)) +
  # scale_y_continuous(trans = log2_trans(),
  #                    breaks = trans_breaks("log2", function(x) 2^x),
  #                    labels = trans_format("log2", math_format(2^.x))) +
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,varwidth = TRUE)+
  geom_jitter(shape=16, position = position_jitter(0.2))+
  theme_classic()+
  geom_signif(comparisons = list(c('high','low')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1),
              tip_length = c(0))#5cm*4cm
a <- ggplot(b, aes(x=CDH1_level, y=immune_score)) +
  geom_violin(aes(fill=CDH1_level),cex=1.2)+  #根据Ancestry的不同因子使用不同颜色，其实用R默认颜色也不错，这里只是展示一下如何提取喜欢的图片颜色。
  scale_fill_manual(values = c('#F8766D','#00BFC4'))+
  geom_boxplot(width=0.1,cex=1.2)+
  theme_classic(base_size = 20)+
  theme(axis.text = element_text(color = 'black'),
        legend.position = 'none')+
  labs(x = 'CDH1_level', y = 'immune_cell_rate')+
  geom_signif(comparisons = list(c('high','low')), 
              map_signif_level = TRUE, test = t.test, y_position = c(1),
              tip_length = c(0))#5cm*4cm
pdf("result/Figure/AI_plot_new/fig9/V5/fig9C.pdf",width = 8,height = 10)
print(a,newpage = F)
dev.off()
#fig9D
# b$VIM_log <- log2(b$VIM+1)
# b$CDH1_log <- log2(b$CDH1+1)
# 
# a <- ggplot(b, aes(x = CDH1_log, y = VIM_log)) +
#   geom_point(color = "steelblue", size = 2) +
#   geom_smooth(color="red",method="lm",se=FALSE)+
#   theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
#         plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
#         axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
#   labs(x = 'CDH1', y = 'VIM', subtitle = '')+
#   scale_y_continuous(expand = c(0,0),limits = c(0,13))+
#   scale_x_continuous(expand = c(0,0))+
#   stat_cor(label.x = 2.5, label.y = 12,method = 'spearman')
# pdf("result/Figure/AI_plot_new/fig9/V5/fig9D.pdf",width = 8,height = 8)
# print(a,newpage = F)
# dev.off()

b$VIM_log <- log2(b$VIM+1)
b$CDH1_log <- log2(b$CDH1+1)

a <- ggplot(b, aes(x = CDH1_log, y = VIM_log)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'VIM', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,13))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 2.5, label.y = 12,method = 'spearman')
pdf("result/Figure/AI_plot_new/fig9/V5/fig9D.pdf",width = 8,height = 8)
print(a,newpage = F)
dev.off()
#fig9E
b$CDH2_log <- log2(b$CDH2+1)
b$CDH1_log <- log2(b$CDH1+1)
a <- ggplot(b, aes(x = CDH1_log, y = CDH2_log)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'CDH2', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,8))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 2.5, label.y = 7.5,method = 'spearman')
pdf("result/Figure/AI_plot_new/fig9/V5/fig9E.pdf",width = 8,height = 8)
print(a,newpage = F)
dev.off()

b$TWIST2_log <- log2(b$TWIST2+1)
b$CDH1_log <- log2(b$CDH1+1)
a <- ggplot(b, aes(x = CDH1_log, y = TWIST2_log)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'TWIST2', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,8))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 2.5, label.y = 7.5,method = 'spearman')
pdf("result/Figure/AI_plot_new/fig9/V5/fig9E_v2.pdf",width = 8,height = 8)
print(a,newpage = F)
dev.off()
#fig9F
library(GSVA)
EMT_gene <- read.csv('/database/EMT_gene/EMT_marker_stromal_marker_PMID_30158554.csv')
EMT_gene <- EMT_gene[EMT_gene$source!='stromal_marker'&EMT_gene$source!='both',]
#单样本GSEA
geneset <- as.data.frame(EMT_gene$Gene)
colnames(geneset) <- 'EMT_score'
gs[[1]] <- gs[[1]][gs[[1]]%in%rownames(expression[[2]])]
gs <- as.list(geneset)

a <- as.matrix(log2(expression[[2]]+1))
a <- gsva(a,
          gs, method = "ssgsea", 
          kcdf="Gaussian",
          ssgsea.norm = TRUE, 
          verbose = TRUE)
a <- as.data.frame(t(a))
a$patient <- substring(text = rownames(a),first = 1,last = 12)
colnames(b)
b <- merge(b,a,by='patient',all=F)
b$EMT_score <- as.numeric(b$EMT_score)
a <- ggplot(b, aes(x = CDH1, y = EMT_score)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'CDH1', y = 'EMT_score', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,1))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 0.5, label.y = 0.5,method = 'spearman')

a <- ggplot(b, aes(x = EMT_score, y = immune_score)) +
  geom_point(color = "steelblue", size = 2) +
  geom_smooth(color="red",method="lm",se=FALSE)+
  theme(panel.grid = element_blank(), axis.line = element_line(colour = 'black', size = 1), panel.background = element_blank(), 
        plot.title = element_text(size = 20, hjust = 0.5), plot.subtitle = element_text(size = 15, hjust = 0.5), 
        axis.text = element_text(size = 20, color = 'black'), axis.title = element_text(size = 20, color = 'black')) +
  labs(x = 'EMT_score', y = 'immune_cell_rate', subtitle = '')+
  scale_y_continuous(expand = c(0,0),limits = c(0,1))+
  scale_x_continuous(expand = c(0,0))+
  stat_cor(label.x = 0.5, label.y = 0.5,method = 'spearman')

pdf("result/Figure/AI_plot_new/fig9/V5/fig9F.pdf",width = 8,height = 8)
print(a,newpage = F)
dev.off()

#fig4A
library(ggplot2)
data <- as.matrix(t(expression[[8]][which(rownames(expression[[8]])%in%hub_gene[[8]][,1]),]))
# for (i in 1:ncol(data)) {
#   data[,i] <- scale(as.numeric(data[,i]))
# }
data <- log2(data+1)
dist.e <- dist(data,method='euclidean')
model1 <- hclust(dist.e,method='ward.D2')##此处修改聚类方法
result <- cutree(model1,k=3)#分类
result <- as.data.frame(result)
paste(length(which(result[,1]==1)),'/',length(which(result[,1]==2)),'/',length(which(result[,1]==3)),sep = '')
b <- result
b[b[,1]=='1',1] <- 'MH'
b[b[,1]=='2',1] <- 'MM'
b[b[,1]=='3',1] <- 'ML'
b$sample_id <- rownames(b)
##画热图比较这两组样本的基因
hotmap <- rbind(data[rownames(data)%in%b[b[,1]=='ML',2],],
                data[rownames(data)%in%b[b[,1]=='MM',2],],
                data[rownames(data)%in%b[b[,1]=='MH',2],])
annotation_col <- as.data.frame(b[,1])
rownames(annotation_col) <- b[,2]
colnames(annotation_col) <- 'cluster'
annotation_col[,1] <- factor(annotation_col[,1])
colnames(annotation_col) <- c('cluster')
ann_colors = list(cluster = c(ML = "#72FCA0",MM = "#4498F2", MH = "#ED5163")) #连续数值型分组可设置成渐变  
# hotmap <- log2(hotmap+1)
hotmap <- t(hotmap)
# bk = unique(c(seq(-3,3, length=100)))
p <- pheatmap::pheatmap(hotmap,cluster_col = F,annotation_col = annotation_col,show_colnames = F,
                        # breaks = bk,
                        annotation_colors = ann_colors,color = c(colorRampPalette(c("navy","white"))(50),
                                                                 colorRampPalette(c("white","red"))(50)))#4cm*8cm
# pdf(paste('result/Figure/AI_plot_new/fig4/V5/fig4A.pdf',sep = ''), width=5, height=4)
# print(p,newpage = F)
# dev.off()
#全样本聚类分组的生存分析情况#supplymental
library('survival')
library('survminer')
b <- lifetime_all[[8]]
b <- b[b$Sample.ID%in%colnames(expression[[8]]),]
b[b[,6]%in%rownames(result)[result[,1]==1],7] <- 'MH'
b[b[,6]%in%rownames(result)[result[,1]==2],7] <- 'MM'
b[b[,6]%in%rownames(result)[result[,1]==3],7] <- 'ML'
b[b$V5>3650,2] <- 0
b[b$V5>3650,5] <- 3650
c <- survdiff(Surv(b[,5],as.numeric(b[,2]))~b[,7], data=b)
c <- survfit(Surv(b[,5],as.numeric(b[,2]))~b[,7], data = b)
plot <- ggsurvplot(c,            # 创建的拟合对象
                   conf.int = F,    # 显示置信区间
                   pval = T,        # 添加P值(对数秩检验（Log-Rank test）的p值)
                   pval.coord=c(2000,0.75),#P值的坐标
                   add.all = F,     # 添加总患者生存曲线
                   palette = c("blue","#F2CA20","#E24A0E"),    # 自定义调色板
                   surv.median.line = "hv",     # 添加中位生存时间线
                   risk.table = F,             # 添加风险表
                   xlab = "Follow up time(d)", # 指定x轴标签
                   legend = c(0.8,0.75),         # 指定图例位置
                   title = c('LUAD_cluster'),                 # 设置图例标题
                   #legend.labs = c('X','Y','Z'), # 指定图例分组标签，注意分组标签的顺序要与标签的排序名称一致(标签默认排序)，实在弄不清楚可以不加这个参数看看先
                   break.x.by = 1000,# 设置x轴刻度间距
                   pval.method=T,#P值方法是否显示
                   pval.method.coord=c(2000,1)#P值方法文本坐标
)
plot$plot+scale_x_continuous(expand = c(0,0),n.breaks = 5)+
  scale_y_continuous(expand = c(0,0))+
  scale_colour_discrete(type = c("#ED5163", "#4498F2","#89C890"),
                        breaks = plot$plot$plot_env$legend.labs[c(2,3,1)],#图例位置
                        labels = c("ML","MM","MH"))##对齐坐标轴原点#4cm*5cm
# pdf(paste('result/Figure/AI_plot_new/fig4/V5/sfig1.pdf',sep = ''), width=5, height=4)
# print(plot,newpage = F)
# dev.off()


#fig4B
####对每个病人进行定义,画出每个病人的高频低频突变的堆叠柱状图
##画柱状图看统计情况堆叠柱状图
library(ggplot2)
library(tidyr)
library(tidyverse)
library(ggtree)
library(aplot)
all_mut_table <- data.frame(sample_id=unique(LUAD_mut$Tumor_Sample_Barcode))
driver_gene_list <- c('KRAS','EGFR','BRAF','ERBB2')
for (i in 1:length(driver_gene_list)) {
  all_mut_table[all_mut_table$sample_id%in%LUAD_mut$Tumor_Sample_Barcode[which(LUAD_mut$Hugo_Symbol==driver_gene_list[i])],driver_gene_list[i]] <- 'yes'
  all_mut_table[is.na(all_mut_table[,driver_gene_list[i]]),driver_gene_list[i]] <- ''
}
luad_fusion <- read.csv('E:/database/TCGA/TCGA_new_version/Database/TCGA-LUAD/TCGA-LUAD_gene_fusion.csv')
luad_fusion$BarcodeID <- gsub(x = luad_fusion$BarcodeID,pattern = '-',replacement = '.')
driver_gene_list <- c('ALK','ROS1')
for (i in 1:length(driver_gene_list)) {
  all_mut_table[all_mut_table$sample_id%in%luad_fusion$BarcodeID[grepl(x = luad_fusion$Fusion_pair,pattern = driver_gene_list[i])],driver_gene_list[i]] <- 'yes'
  all_mut_table[is.na(all_mut_table[,driver_gene_list[i]]),driver_gene_list[i]] <- ''
}
# luad_cnv <- read.table('/database/TCGA/TCGA_new_version/Database/TCGA-LUAD/gene_level copy number/')
all_mut_table$sample_id <- gsub(x = all_mut_table$sample_id,pattern = '[.]',replacement = '-')
driver_gene_rate <- data.frame(row.names = c('ML','MM','MH'))
cnv <- 
  for (i in 1:(length(colnames(all_mut_table))-1)) {
    driver_gene_rate['ML',colnames(all_mut_table)[i+1]] <- sum(all_mut_table[all_mut_table$sample_id%in%b$case_id[b$File.Name=='ML'],colnames(all_mut_table)[i+1]]=='yes')/sum(all_mut_table[,colnames(all_mut_table)[i+1]]=='yes')
    driver_gene_rate['MM',colnames(all_mut_table)[i+1]] <- sum(all_mut_table[all_mut_table$sample_id%in%b$case_id[b$File.Name=='MM'],colnames(all_mut_table)[i+1]]=='yes')/sum(all_mut_table[,colnames(all_mut_table)[i+1]]=='yes')
    driver_gene_rate['MH',colnames(all_mut_table)[i+1]] <- sum(all_mut_table[all_mut_table$sample_id%in%b$case_id[b$File.Name=='MH'],colnames(all_mut_table)[i+1]]=='yes')/sum(all_mut_table[,colnames(all_mut_table)[i+1]]=='yes')
  }
for (i in 1:ncol(driver_gene_rate)) {
  driver_gene_rate[,i] <- driver_gene_rate[,i]/sum(driver_gene_rate[,i])
}
##画柱状图看统计情况堆叠柱状图
library(tidyr)
driver_gene_rate$cluster <- rownames(driver_gene_rate)
subtype_sum <- pivot_longer(data = driver_gene_rate,cols = 1:(ncol(driver_gene_rate)-1),
                            names_to = "driver_gene",##这一个参数是将列名命名为sample_size
                            values_to = "percents")##col

subtype_sum$driver_gene <- factor(subtype_sum$driver_gene,levels = c('KRAS','EGFR','BRAF','ERBB2','ALK','ROS1'))
subtype_sum$cluster <- factor(subtype_sum$cluster,levels = c('ML','MM','MH'))

p <- ggplot(subtype_sum, aes(x=driver_gene, y=percents,fill=cluster)) + #fill是柱内成分的列名
  geom_bar(stat="identity",position = "stack",color="black", width=0.6,size=0.25)+
  scale_fill_manual(values=c("blue","#F2CA20","#E24A0E"))+
  labs(x = "",y = "Percent")+
  scale_y_continuous(expand = c(0,0))+
  theme_classic()#6cm*5cm
p#6cm*5cm
pdf(paste('E:/Project/The stability of gene survival analysis in lung adenocarcinoma/verification/surv_results/process_2nd/result/Figure/total Figure/fig4/fig4B.pdf',sep = ''), width=8, height=6)
print(p,newpage = F)
dev.off()

#####fig2
####fig2C排版
####富集通路
library(clusterProfiler)
library(stringr)
library(ggplot2)

cancer_name <- read.csv('cancer_name.csv',header = F)
cancer_name <- as.character(cancer_name[,1])
# surv_data <- list()
# surv_data_sig <- list()
# for (j in 1:length(cancer_name)) {
#   surv_data[[j]] <- list()
#   names(surv_data)[j] <- cancer_name[j]
#   surv_data[[j]][[1]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_t.csv',sep = ''),row.names = 1)
#   surv_data[[j]][[2]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_up.csv',sep = ''),row.names = 1)
#   surv_data[[j]][[3]] <- read.csv(paste('result/',cancer_name[j],'/data/surv_down.csv',sep = ''),row.names = 1)
#   names(surv_data[[j]]) <- c('surv_t','surv_up','surv_down')
#   a <- apply(surv_data[[j]][[1]], 2, max)
#   b <- surv_data[[j]][[1]][,which.max(a[a!=0])]
#   surv_data_sig[[j]] <- surv_data[[j]]
#   surv_data_sig[[j]][[1]] <- surv_data_sig[[j]][[1]][which(surv_data_sig[[j]][[1]][,which.max(a[a!=0])] >= 0.8),]
#   surv_data_sig[[j]][[2]] <- surv_data_sig[[j]][[2]][which(surv_data_sig[[j]][[2]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
#   surv_data_sig[[j]][[3]] <- surv_data_sig[[j]][[3]][which(surv_data_sig[[j]][[3]][,which.max(a[a!=0])] >= min(surv_data_sig[[j]][[1]][,which.max(a[a!=0])])),]
# }##读取数据以及计算sig_gene
# names(surv_data_sig) <- cancer_name
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- rownames(surv_data_sig_V2[[i]][[1]])
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}
names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
sig_pathway_plot_all <- surv_sig_pathway
# sig_pathway_plot_all@compareClusterResult <- sig_pathway_plot_all@compareClusterResult[sig_pathway_plot_all@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
clusterProfiler::dotplot(sig_pathway_plot_all)


a <- sig_pathway_plot_all@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(7,8,6,11,2,15,5,3,9,1,14)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_all
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(7,8,6,11,2,15,5,3,9,1,14)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(7,8,6,11,2,15,5,3,9,1,14)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 50)

# pdf(paste('result/Figure/AI_plot_new/fig2/V5/fig2A.pdf',sep = ''), width=12, height=10)
# print(plot,newpage = F)
# dev.off()

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]
# write.csv(annotation_col,'result/Figure/total Figure/fig1/pathway.csv',row.names = F)
annotation_col <- read.csv('result/Figure/total Figure/fig1/pathway_annotation.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- unique(a)
}
y_color[y_color[,2]=='Others',3] <- 'black'
y_color[y_color[,2]=='Cell Cycle',3] <- 'red'
y_color[y_color[,2]=='Immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
# y_color$color <- factor(y_color$color,levels = c('black','red','blue'))
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))


a <- as.vector(y_color$type)
b <-as.vector(y_color$pathway)[c(which(a=='Others'),
                                 which(a=='Immune'),
                                 which(a=='Cell Cycle'))]
plot$data$Description <- factor(plot$data$Description,levels = b)

pdf(paste('result/Figure/total Figure/fig1/fig1C_v2.pdf',sep = ''), width=15, height=12)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(a=='Others'),
                                                           which(a=='Immune'),
                                                           which(a=='Cell Cycle'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_color_gradient(high="#59EF0A",low="#F77103")+
  scale_fill_manual(values=c("red","blue","black"))#10cm*12cm
dev.off()


####fig2C
# a <- surv_sig_dgree_V2[[2]]
# a$type[a$a%in%immune_system[,1]] <- 'immune'
# write.csv(a,'result/Figure/AI_plot_new/fig2/V5/BRCA_gene_type.csv',row.names = F)
# a <- surv_sig_dgree_V2[[8]]
# a$type[a$a%in%ref_path_mitotic] <- 'mitotic'
# write.csv(a,'result/Figure/AI_plot_new/fig2/V5/LUAD_gene_type.csv',row.names = F)
##对网络top10进行富集（dotplot）
surv_sig_gene <- list()
for (i in 1:15) {
  surv_sig_gene[[i]] <- hub_gene[[i]][1:10,1]
  surv_sig_gene[[i]] <- bitr(surv_sig_gene[[i]],fromType = 'SYMBOL', #数据源，fromtype是基因的id类型
                             toType = c('ENTREZID'), #totype指需要转换成的ID类型
                             OrgDb='org.Hs.eg.db')[,2]
}

names(surv_sig_gene) <- cancer_name
surv_sig_pathway <- compareCluster(surv_sig_gene,
                                   fun="enrichGO", 
                                   OrgDb="org.Hs.eg.db", 
                                   ont= "BP",
                                   pvalueCutoff=0.05,
                                   pAdjustMethod = "BH",
                                   qvalueCutoff = 0.05)
##提取指定层次的通路进行绘制通路图
sig_pathway_plot_top10 <- surv_sig_pathway
# sig_pathway_plot_top10@compareClusterResult <- sig_pathway_plot_top10@compareClusterResult[sig_pathway_plot_top10@compareClusterResult[,2]%in%go_basic[go_basic[,3]=='Level5',2],]
dotplot(sig_pathway_plot_top10,showCategory=5,includeAll=TRUE,label_format = 70)
a <- sig_pathway_plot_top10@compareClusterResult
b <- data.frame()
for (i in cancer_name[c(6,7,8,11,2,15,3,9,12,4,13)]) {
  c <- a[a[,1]%in%i,]
  b[(nrow(b)+1):(nrow(b)+nrow(c)),1:ncol(c)] <- c
}
a <- sig_pathway_plot_top10
a@compareClusterResult <- b
a@geneClusters <- a@geneClusters[cancer_name[c(6,7,8,11,2,15,3,9,12,4,13)]]
a@compareClusterResult$Cluster <- factor(a@compareClusterResult$Cluster,levels=cancer_name[c(6,7,8,11,2,15,3,9,12,4,13)])
plot <- dotplot(a,showCategory=5,includeAll=TRUE,label_format = 35)
# pdf(paste('result/Figure/AI_plot_new/fig2/V5/fig2C.pdf',sep = ''), width=12, height=10)
# print(plot,newpage = F)
# dev.off()
# write.csv(a@compareClusterResult,'result/Figure/total Figure/fig2/pathway_top10.csv')

annotation_col <- plot$data 
annotation_col$func <- 1:nrow(annotation_col)
annotation_col <- annotation_col[,c(ncol(annotation_col),1:(ncol(annotation_col)-1))]

write.csv(annotation_col,'result/Figure/total Figure/fig2/pathway_top10.csv',row.names = F)
annotation_col <- read.csv('result/Figure/total Figure/fig2/pathway_annotation_top10.csv')
y_color <- as.data.frame(levels(plot[["data"]][["Description"]]))
for (i in 1:nrow(y_color)) {
  a <- annotation_col[annotation_col[,4]==y_color[i,1],1]
  y_color[i,2] <- a[!duplicated(a)]
}
y_color[y_color[,2]=='Others',3] <- 'black'
y_color[y_color[,2]=='Cell Cycle',3] <- 'red'
y_color[y_color[,2]=='Immune',3] <- 'blue'
colnames(y_color) <- c('pathway','type','color')
y_color$xmin <- -Inf
y_color$xmax <- Inf

y_color$ymin <- as.numeric(rownames(y_color))-1
y_color$ymax <- as.numeric(rownames(y_color))

a <- as.vector(y_color$type)
b <-as.vector(y_color$pathway)[c(which(a=='Others'),
                                 which(a=='Cell Cycle'),
                                 which(a=='Immune'))]
plot$data$Description <- factor(plot$data$Description,levels = b)
plot+  
  theme(axis.text.y = element_text(color = y_color$color[c(which(a=='Others'),
                                                           which(a=='Cell Cycle'),
                                                           which(a=='Immune'))]))+
  geom_rect(data=y_color, inherit.aes=FALSE,show.legend = NA,
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymin,
                group=pathway, fill = type), alpha=1) + 
  scale_fill_manual(values=y_color$color[!duplicated(y_color$color)])#6cm*8cm

##ggplot2画sankey图
####top10sankey plot
library(tidyr)
# annotation_col <- read.csv('result/Figure/AI_plot_new/fig2/v5/pathway_annotation_top10.csv')
annotation_col <- annotation_col[annotation_col$Cluster%in%c('LGG\n(10)','LIHC\n(10)',"LUAD\n(10)","BRCA\n(10)","UCEC\n(9)"),]
b <- annotation_col[,c(1,2,4)]
b <- b[c(which(b$func=='Cell Cycle'),which(b$func=='Immune'),which(b$func=='Others')),]
b$weight <- 1
library("ggplot2")
library("ggalluvial")
colnames(b) <- c('pathway','cancer_type','pathway_name','weight')
b$cohort <- 1:nrow(b)
b <- pivot_longer(data = b[,c(1,2,5)],cols = 1:2,
                  names_to = "feature",##这一个参数是将列名命名为sample_size
                  values_to = "nodes")##col
b$nodes <- factor(b$nodes,levels = c(unique(b$nodes)[c(3,2,4,6,7,1,5,8)]))
mycol <- c("#F29530","#F29530","#F29530","#4FAAC8","#4FAAC8",'red','#245BAA','#D9D9D9')
plot <- ggplot(b,aes(x = feature, stratum = nodes, alluvium = cohort,
                     fill = nodes, label = nodes)) +
  scale_x_discrete(expand = c(0, 0)) + 
  geom_flow(width = 1/8) + #线跟方块间空隙的宽窄 
  geom_stratum(alpha = 1,width = 2/10) + #方块的透明度、宽度
  geom_text(stat = "stratum", size = 3,color="white") + #文字大小、颜色
  #不喜欢默认的配色方案，用前面自己写的配色方案
  scale_fill_manual(values = mycol) +
  xlab("") + ylab("") +
  theme_bw() + #去除背景色
  theme(panel.grid =element_blank()) + #去除网格线
  theme(panel.border = element_blank()) + #去除外层边框
  theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text = element_blank()) + #去掉坐标轴
  ggtitle("")+
  guides(fill = FALSE) #5cm*7cm

pdf(paste('result/Figure/total Figure/fig2/fig2D.pdf',sep = ''), width=7, height=5)
print(plot,newpage = F)
dev.off()

#fig3A-C
for (i in 1:15) {
  a <- mitotic_gene_expr_crispr[[i]]##LGG
  b <- apply(a, 1, mean)
  a <- a[order(b,decreasing = F),]
  annotation_row <- as.data.frame(rownames(a))
  rownames(annotation_row) <- annotation_row[,1]
  annotation_row[rownames(annotation_row)%in%ref_path_mitotic,1] <- 'mitotic'
  annotation_row[!rownames(annotation_row)%in%ref_path_mitotic,1] <- 'other'
  colnames(annotation_row) <- 'function'
  d <- factor(annotation_row[,1])
  annotation_row[,1] <- d
  bk = unique(c(seq(0,1, length=200)))
  ann_colors = list('function' = c(mitotic = "#CE4824", other = "gray"))
  a <- pheatmap::pheatmap(t(a),breaks = bk,show_rownames = F,main = cancer_name[i],
                          color = c(colorRampPalette(c("white",'navy'))(200)),
                          clustering_method = "mcquitty", show_colnames = T,cluster_rows = T,
                          cluster_cols = F,border = F,treeheight_col = 0,treeheight_row = 0,
                          annotation_col = annotation_row,annotation_colors = ann_colors)#4cm*5cm
  pdf(paste('result/Figure/total Figure/fig3/hub_gene_dependecy/','fig3_',cancer_name[i],'.pdf',sep = ''), width=5, height=4.1)
  print(a,newpage = F)
  dev.off()
}

#统计出现次数最多的基因
GaRP <- character()
for (i in 1:15) {
  GaRP <- c(GaRP,rownames(surv_data_sig_V2[[i]][[1]]))
}
GaRP_data <- data.frame(row.names = unique(GaRP))
for (i in 1:length(unique(GaRP))) {
  GaRP_data[i,1] <- sum(GaRP==unique(GaRP)[i])
}
for (i in 1:nrow(GaRP_data)) {
  a <- character()
  for (j in 1:15) {
    if (sum(rownames(surv_data_sig_V2[[j]][[1]])%in%rownames(GaRP_data)[i])>0) {
      a <- c(a,names(surv_data_sig_V2)[j])
    }
  }
  GaRP_data[i,2:(length(a)+1)] <- a
}

#导出显著概率top10的基因
surv_top10 <- data.frame()
for (i in 1:15) {
  apply(surv_data_V2[[1]],1,max)

}



# rm(surv_raw_data)#清除
# rm(brca_counts)
# rm(brca_tpm)
# rm(expr_data_raw)
# rm(expression_raw)
# rm(expr)
# rm(tra_expr_data)
# rm(dds)
# rm(TCGA_expr)
# rm(expression)
# rm(CCLE_maf_mut)
# rm(CCLE_mut)
# rm(surv_plot_immune)
# rm(immune_surv_plot)
# rm(CCLE_cell_mut)
# rm(cmap_effect_data)
# rm(cell_chem_expr)
# rm(z,x,X,w,variable,values,v,suppl,size,single_gene,s,se,n,Mean,l,l1,l2,l3,length1,k,k1,k2,k3,k4,k5)
# rm(j,J,j1,j2,j3,locate,mycol,obj,objname,I,g,g0,g1,formula,formula_for_multivariate,file_name)
# all_objects <- ls()
# objects_to_delete <- grep("^A", all_objects, value = TRUE)
# rm(list = objects_to_delete)
# objects_to_delete <- grep("^a", all_objects, value = TRUE)
# rm(list = objects_to_delete)
# objects_to_delete <- grep("^L", all_objects, value = TRUE)
# rm(list = objects_to_delete)
# objects_to_delete <- grep("^l", all_objects, value = TRUE)
# rm(list = objects_to_delete)
# objects_to_delete <- grep("^m", all_objects, value = TRUE)
# rm(list = objects_to_delete)
# objects_to_delete <- grep("^M", all_objects, value = TRUE)
# rm(list = objects_to_delete)

# 示例：保存所有变量到RData文件

save(surv_data_sig_V2, file = "R_data/surv_data_sig_V2.RData")

library(pryr)
# 列出所有对象的名称
all_objects <- ls()

# 创建一个空的数据框来存储对象名和对应的大小
object_sizes <- data.frame(Object = character(0), Size = numeric(0))

# 遍历所有对象，计算大小并存储到数据框中
for (obj_name in all_objects) {
  obj <- get(obj_name)
  size <- object_size(obj)
  object_sizes <- rbind(object_sizes, data.frame(Object = obj_name, Size = size))
}

# 打印对象及其大小
print(object_sizes)


